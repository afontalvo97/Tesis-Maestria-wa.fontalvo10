# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Interfaz2-SIR.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import numpy as np
import osmnx as ox
import networkx as nx
import pandas as pd
import folium as fl
from datetime import timedelta
from geopy.geocoders import Nominatim
import ipywidgets as widgets
import io
from ipywidgets import HTML
from IPython.display import display
import base64
from IPython.display import IFrame
import gurobipy as gp
from gurobipy import GRB
from gurobipy import *
import requests
import folium
import time
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLineEdit, QPushButton, QLabel, QRadioButton, QFileDialog, QProgressBar, QDialog, QCheckBox, QMessageBox, QFormLayout, QListWidget, QTimeEdit, QGridLayout, QSpinBox
from PyQt5.QtWebEngineWidgets import QWebEngineView
from PyQt5.QtCore import QUrl, QCoreApplication, QModelIndex, QRegExp
from PyQt5.QtGui import QFont, QStandardItemModel, QStandardItem, QPixmap
from geopy.geocoders import Nominatim
import funciones_tesis
from funciones_tesis import *
import warnings
from geopy.geocoders import ArcGIS
warnings.filterwarnings('ignore')
import os.path
import os
from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(QWidget):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1763, 910)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
        MainWindow.setSizePolicy(sizePolicy)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.centralwidget.sizePolicy().hasHeightForWidth())
        self.centralwidget.setSizePolicy(sizePolicy)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget.setGeometry(QtCore.QRect(10, 10, 1751, 851))
        self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.label = QtWidgets.QLabel(self.verticalLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(20)
        font.setBold(True)
        font.setWeight(75)
        self.label.setFont(font)
        self.label.setObjectName("label")
        self.verticalLayout.addWidget(self.label)
        self.tabWidget = QtWidgets.QTabWidget(self.verticalLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(12)
        self.tabWidget.setFont(font)
        self.tabWidget.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.tabWidget.setAutoFillBackground(False)
        self.tabWidget.setTabPosition(QtWidgets.QTabWidget.North)
        self.tabWidget.setTabShape(QtWidgets.QTabWidget.Rounded)
        self.tabWidget.setIconSize(QtCore.QSize(30, 23))
        self.tabWidget.setDocumentMode(False)
        self.tabWidget.setTabBarAutoHide(False)
        self.tabWidget.setObjectName("tabWidget")
        self.tab_clientes = QtWidgets.QWidget()
        self.tab_clientes.setObjectName("tab_clientes")
        self.verticalLayoutWidget_4 = QtWidgets.QWidget(self.tab_clientes)
        self.verticalLayoutWidget_4.setGeometry(QtCore.QRect(10, 120, 541, 291))
        self.verticalLayoutWidget_4.setObjectName("verticalLayoutWidget_4")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_4)
        self.verticalLayout_5.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.label_10 = QtWidgets.QLabel(self.verticalLayoutWidget_4)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_10.setFont(font)
        self.label_10.setAutoFillBackground(False)
        self.label_10.setText("")
        self.label_10.setObjectName("label_10")
        self.verticalLayout_5.addWidget(self.label_10)
        self.checkBox_3 = QtWidgets.QCheckBox(self.verticalLayoutWidget_4)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.checkBox_3.setFont(font)
        self.checkBox_3.setAutoFillBackground(True)
        self.checkBox_3.setChecked(True)
        self.checkBox_3.setObjectName("checkBox_3")
        self.verticalLayout_5.addWidget(self.checkBox_3)
        self.scrollArea_4 = QtWidgets.QScrollArea(self.verticalLayoutWidget_4)
        self.scrollArea_4.setWidgetResizable(True)
        self.scrollArea_4.setObjectName("scrollArea_4")
        self.scrollAreaWidgetContents_4 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_4.setGeometry(QtCore.QRect(0, 0, 537, 239))
        self.scrollAreaWidgetContents_4.setObjectName("scrollAreaWidgetContents_4")
        self.scrollArea_4.setWidget(self.scrollAreaWidgetContents_4)
        self.verticalLayout_5.addWidget(self.scrollArea_4)
        self.verticalLayoutWidget_10 = QtWidgets.QWidget(self.tab_clientes)
        self.verticalLayoutWidget_10.setGeometry(QtCore.QRect(10, 10, 541, 91))
        self.verticalLayoutWidget_10.setObjectName("verticalLayoutWidget_10")
        self.verticalLayout_15 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_10)
        self.verticalLayout_15.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_15.setObjectName("verticalLayout_15")
        self.label_3 = QtWidgets.QLabel(self.verticalLayoutWidget_10)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_3.setFont(font)
        self.label_3.setObjectName("label_3")
        self.verticalLayout_15.addWidget(self.label_3)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.pushButton = QtWidgets.QPushButton(self.verticalLayoutWidget_10)
        font = QtGui.QFont()
        font.setPointSize(8)
        self.pushButton.setFont(font)
        self.pushButton.setObjectName("pushButton")
        self.horizontalLayout_4.addWidget(self.pushButton)
        self.pushButton_4 = QtWidgets.QPushButton(self.verticalLayoutWidget_10)
        font = QtGui.QFont()
        font.setPointSize(8)
        self.pushButton_4.setFont(font)
        self.pushButton_4.setObjectName("pushButton_4")
        self.horizontalLayout_4.addWidget(self.pushButton_4)
        self.pushButton_2 = QtWidgets.QPushButton(self.verticalLayoutWidget_10)
        font = QtGui.QFont()
        font.setPointSize(8)
        self.pushButton_2.setFont(font)
        self.pushButton_2.setObjectName("pushButton_2")
        self.horizontalLayout_4.addWidget(self.pushButton_2)
        self.verticalLayout_15.addLayout(self.horizontalLayout_4)
        self.frame_3 = QtWidgets.QFrame(self.tab_clientes)
        self.frame_3.setGeometry(QtCore.QRect(570, 570, 541, 191))
        self.frame_3.setAutoFillBackground(True)
        self.frame_3.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_3.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_3.setObjectName("frame_3")
        self.label_8 = QtWidgets.QLabel(self.frame_3)
        self.label_8.setGeometry(QtCore.QRect(10, 10, 481, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_8.setFont(font)
        self.label_8.setObjectName("label_8")
        self.verticalLayoutWidget_17 = QtWidgets.QWidget(self.frame_3)
        self.verticalLayoutWidget_17.setGeometry(QtCore.QRect(20, 30, 491, 141))
        self.verticalLayoutWidget_17.setObjectName("verticalLayoutWidget_17")
        self.verticalLayout_19 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_17)
        self.verticalLayout_19.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_19.setObjectName("verticalLayout_19")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label_16 = QtWidgets.QLabel(self.verticalLayoutWidget_17)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_16.setFont(font)
        self.label_16.setObjectName("label_16")
        self.horizontalLayout.addWidget(self.label_16)
        self.lineEdit = QtWidgets.QLineEdit(self.verticalLayoutWidget_17)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit.setFont(font)
        self.lineEdit.setObjectName("lineEdit")
        self.horizontalLayout.addWidget(self.lineEdit)
        self.verticalLayout_19.addLayout(self.horizontalLayout)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.label_18 = QtWidgets.QLabel(self.verticalLayoutWidget_17)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_18.setFont(font)
        self.label_18.setObjectName("label_18")
        self.horizontalLayout_3.addWidget(self.label_18)
        self.lineEdit_2 = QtWidgets.QLineEdit(self.verticalLayoutWidget_17)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit_2.setFont(font)
        self.lineEdit_2.setObjectName("lineEdit_2")
        self.horizontalLayout_3.addWidget(self.lineEdit_2)
        self.verticalLayout_19.addLayout(self.horizontalLayout_3)
        self.pushButton_14 = QtWidgets.QPushButton(self.verticalLayoutWidget_17)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_14.setFont(font)
        self.pushButton_14.setObjectName("pushButton_14")
        self.verticalLayout_19.addWidget(self.pushButton_14)
        self.line = QtWidgets.QFrame(self.tab_clientes)
        self.line.setGeometry(QtCore.QRect(550, 10, 21, 711))
        self.line.setFrameShape(QtWidgets.QFrame.VLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName("line")
        self.verticalLayoutWidget_6 = QtWidgets.QWidget(self.tab_clientes)
        self.verticalLayoutWidget_6.setGeometry(QtCore.QRect(10, 430, 541, 121))
        self.verticalLayoutWidget_6.setObjectName("verticalLayoutWidget_6")
        self.verticalLayout_12 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_6)
        self.verticalLayout_12.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_12.setObjectName("verticalLayout_12")
        self.pushButton_11 = QtWidgets.QPushButton(self.verticalLayoutWidget_6)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_11.setFont(font)
        self.pushButton_11.setObjectName("pushButton_11")
        self.verticalLayout_12.addWidget(self.pushButton_11)
        self.pushButton_12 = QtWidgets.QPushButton(self.verticalLayoutWidget_6)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_12.setFont(font)
        self.pushButton_12.setObjectName("pushButton_12")
        self.verticalLayout_12.addWidget(self.pushButton_12)
        self.pushButton_23 = QtWidgets.QPushButton(self.verticalLayoutWidget_6)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_23.setFont(font)
        self.pushButton_23.setObjectName("pushButton_23")
        self.verticalLayout_12.addWidget(self.pushButton_23)
        self.verticalLayoutWidget_16 = QtWidgets.QWidget(self.tab_clientes)
        self.verticalLayoutWidget_16.setGeometry(QtCore.QRect(570, 10, 541, 91))
        self.verticalLayoutWidget_16.setObjectName("verticalLayoutWidget_16")
        self.verticalLayout_18 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_16)
        self.verticalLayout_18.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_18.setObjectName("verticalLayout_18")
        self.label_15 = QtWidgets.QLabel(self.verticalLayoutWidget_16)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_15.setFont(font)
        self.label_15.setObjectName("label_15")
        self.verticalLayout_18.addWidget(self.label_15)
        self.pushButton_13 = QtWidgets.QPushButton(self.verticalLayoutWidget_16)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_13.setFont(font)
        self.pushButton_13.setObjectName("pushButton_13")
        self.verticalLayout_18.addWidget(self.pushButton_13)
        self.verticalLayoutWidget_19 = QtWidgets.QWidget(self.tab_clientes)
        self.verticalLayoutWidget_19.setGeometry(QtCore.QRect(570, 120, 541, 291))
        self.verticalLayoutWidget_19.setObjectName("verticalLayoutWidget_19")
        self.verticalLayout_21 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_19)
        self.verticalLayout_21.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_21.setObjectName("verticalLayout_21")
        self.label_17 = QtWidgets.QLabel(self.verticalLayoutWidget_19)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_17.setFont(font)
        self.label_17.setAutoFillBackground(False)
        self.label_17.setText("")
        self.label_17.setObjectName("label_17")
        self.verticalLayout_21.addWidget(self.label_17)
        self.checkBox = QtWidgets.QCheckBox(self.verticalLayoutWidget_19)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.checkBox.setFont(font)
        self.checkBox.setAutoFillBackground(True)
        self.checkBox.setChecked(True)
        self.checkBox.setObjectName("checkBox")
        self.verticalLayout_21.addWidget(self.checkBox)
        self.scrollArea_6 = QtWidgets.QScrollArea(self.verticalLayoutWidget_19)
        self.scrollArea_6.setWidgetResizable(True)
        self.scrollArea_6.setObjectName("scrollArea_6")
        self.scrollAreaWidgetContents_6 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_6.setGeometry(QtCore.QRect(0, 0, 537, 239))
        self.scrollAreaWidgetContents_6.setObjectName("scrollAreaWidgetContents_6")
        self.scrollArea_6.setWidget(self.scrollAreaWidgetContents_6)
        self.verticalLayout_21.addWidget(self.scrollArea_6)
        self.frame_5 = QtWidgets.QFrame(self.tab_clientes)
        self.frame_5.setGeometry(QtCore.QRect(10, 570, 541, 191))
        self.frame_5.setAutoFillBackground(True)
        self.frame_5.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_5.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_5.setObjectName("frame_5")
        self.label_28 = QtWidgets.QLabel(self.frame_5)
        self.label_28.setGeometry(QtCore.QRect(10, 10, 481, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_28.setFont(font)
        self.label_28.setObjectName("label_28")
        self.verticalLayoutWidget_28 = QtWidgets.QWidget(self.frame_5)
        self.verticalLayoutWidget_28.setGeometry(QtCore.QRect(20, 30, 491, 141))
        self.verticalLayoutWidget_28.setObjectName("verticalLayoutWidget_28")
        self.verticalLayout_28 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_28)
        self.verticalLayout_28.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_28.setObjectName("verticalLayout_28")
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.label_29 = QtWidgets.QLabel(self.verticalLayoutWidget_28)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_29.setFont(font)
        self.label_29.setObjectName("label_29")
        self.horizontalLayout_8.addWidget(self.label_29)
        self.lineEdit_7 = QtWidgets.QLineEdit(self.verticalLayoutWidget_28)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit_7.setFont(font)
        self.lineEdit_7.setObjectName("lineEdit_7")
        self.horizontalLayout_8.addWidget(self.lineEdit_7)
        self.verticalLayout_28.addLayout(self.horizontalLayout_8)
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        self.label_30 = QtWidgets.QLabel(self.verticalLayoutWidget_28)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_30.setFont(font)
        self.label_30.setObjectName("label_30")
        self.horizontalLayout_9.addWidget(self.label_30)
        self.lineEdit_8 = QtWidgets.QLineEdit(self.verticalLayoutWidget_28)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit_8.setFont(font)
        self.lineEdit_8.setObjectName("lineEdit_8")
        self.horizontalLayout_9.addWidget(self.lineEdit_8)
        self.verticalLayout_28.addLayout(self.horizontalLayout_9)
        self.pushButton_26 = QtWidgets.QPushButton(self.verticalLayoutWidget_28)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_26.setFont(font)
        self.pushButton_26.setObjectName("pushButton_26")
        self.verticalLayout_28.addWidget(self.pushButton_26)
        self.verticalLayoutWidget_3 = QtWidgets.QWidget(self.tab_clientes)
        self.verticalLayoutWidget_3.setGeometry(QtCore.QRect(570, 430, 541, 121))
        self.verticalLayoutWidget_3.setObjectName("verticalLayoutWidget_3")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_3)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.pushButton_15 = QtWidgets.QPushButton(self.verticalLayoutWidget_3)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_15.setFont(font)
        self.pushButton_15.setObjectName("pushButton_15")
        self.verticalLayout_2.addWidget(self.pushButton_15)
        self.pushButton_16 = QtWidgets.QPushButton(self.verticalLayoutWidget_3)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_16.setFont(font)
        self.pushButton_16.setObjectName("pushButton_16")
        self.verticalLayout_2.addWidget(self.pushButton_16)
        self.pushButton_9 = QtWidgets.QPushButton(self.verticalLayoutWidget_3)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_9.setFont(font)
        self.pushButton_9.setObjectName("pushButton_9")
        self.verticalLayout_2.addWidget(self.pushButton_9)
        self.verticalLayoutWidget_27 = QtWidgets.QWidget(self.tab_clientes)
        self.verticalLayoutWidget_27.setGeometry(QtCore.QRect(1120, 40, 581, 391))
        self.verticalLayoutWidget_27.setObjectName("verticalLayoutWidget_27")
        self.verticalLayout_27 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_27)
        self.verticalLayout_27.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_27.setObjectName("verticalLayout_27")
        self.verticalLayoutWidget_32 = QtWidgets.QWidget(self.tab_clientes)
        self.verticalLayoutWidget_32.setGeometry(QtCore.QRect(1120, 10, 581, 31))
        self.verticalLayoutWidget_32.setObjectName("verticalLayoutWidget_32")
        self.verticalLayout_32 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_32)
        self.verticalLayout_32.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_32.setObjectName("verticalLayout_32")
        self.label_31 = QtWidgets.QLabel(self.verticalLayoutWidget_32)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_31.setFont(font)
        self.label_31.setObjectName("label_31")
        self.verticalLayout_32.addWidget(self.label_31)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("../.designer/backup/clientes_img.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.tabWidget.addTab(self.tab_clientes, icon, "")
        self.depots_tab = QtWidgets.QWidget()
        self.depots_tab.setObjectName("depots_tab")
        self.verticalLayoutWidget_11 = QtWidgets.QWidget(self.depots_tab)
        self.verticalLayoutWidget_11.setGeometry(QtCore.QRect(10, 10, 541, 91))
        self.verticalLayoutWidget_11.setObjectName("verticalLayoutWidget_11")
        self.verticalLayout_16 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_11)
        self.verticalLayout_16.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_16.setObjectName("verticalLayout_16")
        self.label_5 = QtWidgets.QLabel(self.verticalLayoutWidget_11)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_5.setFont(font)
        self.label_5.setObjectName("label_5")
        self.verticalLayout_16.addWidget(self.label_5)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.pushButton_3 = QtWidgets.QPushButton(self.verticalLayoutWidget_11)
        font = QtGui.QFont()
        font.setPointSize(8)
        self.pushButton_3.setFont(font)
        self.pushButton_3.setObjectName("pushButton_3")
        self.horizontalLayout_6.addWidget(self.pushButton_3)
        self.pushButton_5 = QtWidgets.QPushButton(self.verticalLayoutWidget_11)
        font = QtGui.QFont()
        font.setPointSize(8)
        self.pushButton_5.setFont(font)
        self.pushButton_5.setObjectName("pushButton_5")
        self.horizontalLayout_6.addWidget(self.pushButton_5)
        self.pushButton_6 = QtWidgets.QPushButton(self.verticalLayoutWidget_11)
        font = QtGui.QFont()
        font.setPointSize(8)
        self.pushButton_6.setFont(font)
        self.pushButton_6.setObjectName("pushButton_6")
        self.horizontalLayout_6.addWidget(self.pushButton_6)
        self.verticalLayout_16.addLayout(self.horizontalLayout_6)
        self.line_2 = QtWidgets.QFrame(self.depots_tab)
        self.line_2.setGeometry(QtCore.QRect(550, 10, 21, 711))
        self.line_2.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_2.setObjectName("line_2")
        self.verticalLayoutWidget_23 = QtWidgets.QWidget(self.depots_tab)
        self.verticalLayoutWidget_23.setGeometry(QtCore.QRect(570, 120, 541, 311))
        self.verticalLayoutWidget_23.setObjectName("verticalLayoutWidget_23")
        self.verticalLayout_22 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_23)
        self.verticalLayout_22.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_22.setObjectName("verticalLayout_22")
        self.label_19 = QtWidgets.QLabel(self.verticalLayoutWidget_23)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_19.setFont(font)
        self.label_19.setAutoFillBackground(False)
        self.label_19.setText("")
        self.label_19.setObjectName("label_19")
        self.verticalLayout_22.addWidget(self.label_19)
        self.checkBox_2 = QtWidgets.QCheckBox(self.verticalLayoutWidget_23)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.checkBox_2.setFont(font)
        self.checkBox_2.setAutoFillBackground(True)
        self.checkBox_2.setChecked(True)
        self.checkBox_2.setObjectName("checkBox_2")
        self.verticalLayout_22.addWidget(self.checkBox_2)
        self.scrollArea_7 = QtWidgets.QScrollArea(self.verticalLayoutWidget_23)
        self.scrollArea_7.setWidgetResizable(True)
        self.scrollArea_7.setObjectName("scrollArea_7")
        self.scrollAreaWidgetContents_7 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_7.setGeometry(QtCore.QRect(0, 0, 537, 259))
        self.scrollAreaWidgetContents_7.setObjectName("scrollAreaWidgetContents_7")
        self.scrollArea_7.setWidget(self.scrollAreaWidgetContents_7)
        self.verticalLayout_22.addWidget(self.scrollArea_7)
        self.verticalLayoutWidget_13 = QtWidgets.QWidget(self.depots_tab)
        self.verticalLayoutWidget_13.setGeometry(QtCore.QRect(10, 440, 541, 121))
        self.verticalLayoutWidget_13.setObjectName("verticalLayoutWidget_13")
        self.verticalLayout_24 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_13)
        self.verticalLayout_24.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_24.setObjectName("verticalLayout_24")
        self.pushButton_19 = QtWidgets.QPushButton(self.verticalLayoutWidget_13)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_19.setFont(font)
        self.pushButton_19.setObjectName("pushButton_19")
        self.verticalLayout_24.addWidget(self.pushButton_19)
        self.pushButton_20 = QtWidgets.QPushButton(self.verticalLayoutWidget_13)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_20.setFont(font)
        self.pushButton_20.setObjectName("pushButton_20")
        self.verticalLayout_24.addWidget(self.pushButton_20)
        self.pushButton_24 = QtWidgets.QPushButton(self.verticalLayoutWidget_13)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_24.setFont(font)
        self.pushButton_24.setObjectName("pushButton_24")
        self.verticalLayout_24.addWidget(self.pushButton_24)
        self.verticalLayoutWidget_24 = QtWidgets.QWidget(self.depots_tab)
        self.verticalLayoutWidget_24.setGeometry(QtCore.QRect(10, 120, 541, 311))
        self.verticalLayoutWidget_24.setObjectName("verticalLayoutWidget_24")
        self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_24)
        self.verticalLayout_6.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.label_11 = QtWidgets.QLabel(self.verticalLayoutWidget_24)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_11.setFont(font)
        self.label_11.setAutoFillBackground(False)
        self.label_11.setText("")
        self.label_11.setObjectName("label_11")
        self.verticalLayout_6.addWidget(self.label_11)
        self.checkBox_4 = QtWidgets.QCheckBox(self.verticalLayoutWidget_24)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.checkBox_4.setFont(font)
        self.checkBox_4.setAutoFillBackground(True)
        self.checkBox_4.setChecked(True)
        self.checkBox_4.setObjectName("checkBox_4")
        self.verticalLayout_6.addWidget(self.checkBox_4)
        self.scrollArea_5 = QtWidgets.QScrollArea(self.verticalLayoutWidget_24)
        self.scrollArea_5.setWidgetResizable(True)
        self.scrollArea_5.setObjectName("scrollArea_5")
        self.scrollAreaWidgetContents_5 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_5.setGeometry(QtCore.QRect(0, 0, 537, 237))
        self.scrollAreaWidgetContents_5.setObjectName("scrollAreaWidgetContents_5")
        self.scrollArea_5.setWidget(self.scrollAreaWidgetContents_5)
        self.verticalLayout_6.addWidget(self.scrollArea_5)
        self.label_37 = QtWidgets.QLabel(self.verticalLayoutWidget_24)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_37.setFont(font)
        self.label_37.setObjectName("label_37")
        self.verticalLayout_6.addWidget(self.label_37)
        self.verticalLayoutWidget_25 = QtWidgets.QWidget(self.depots_tab)
        self.verticalLayoutWidget_25.setGeometry(QtCore.QRect(570, 10, 541, 91))
        self.verticalLayoutWidget_25.setObjectName("verticalLayoutWidget_25")
        self.verticalLayout_25 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_25)
        self.verticalLayout_25.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_25.setObjectName("verticalLayout_25")
        self.label_20 = QtWidgets.QLabel(self.verticalLayoutWidget_25)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_20.setFont(font)
        self.label_20.setObjectName("label_20")
        self.verticalLayout_25.addWidget(self.label_20)
        self.pushButton_21 = QtWidgets.QPushButton(self.verticalLayoutWidget_25)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_21.setFont(font)
        self.pushButton_21.setObjectName("pushButton_21")
        self.verticalLayout_25.addWidget(self.pushButton_21)
        self.frame_4 = QtWidgets.QFrame(self.depots_tab)
        self.frame_4.setGeometry(QtCore.QRect(570, 570, 541, 201))
        self.frame_4.setAutoFillBackground(True)
        self.frame_4.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_4.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_4.setObjectName("frame_4")
        self.label_9 = QtWidgets.QLabel(self.frame_4)
        self.label_9.setGeometry(QtCore.QRect(10, 10, 481, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_9.setFont(font)
        self.label_9.setObjectName("label_9")
        self.verticalLayoutWidget_26 = QtWidgets.QWidget(self.frame_4)
        self.verticalLayoutWidget_26.setGeometry(QtCore.QRect(30, 30, 491, 141))
        self.verticalLayoutWidget_26.setObjectName("verticalLayoutWidget_26")
        self.verticalLayout_26 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_26)
        self.verticalLayout_26.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_26.setObjectName("verticalLayout_26")
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.label_21 = QtWidgets.QLabel(self.verticalLayoutWidget_26)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_21.setFont(font)
        self.label_21.setObjectName("label_21")
        self.horizontalLayout_7.addWidget(self.label_21)
        self.lineEdit_3 = QtWidgets.QLineEdit(self.verticalLayoutWidget_26)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit_3.setFont(font)
        self.lineEdit_3.setObjectName("lineEdit_3")
        self.horizontalLayout_7.addWidget(self.lineEdit_3)
        self.verticalLayout_26.addLayout(self.horizontalLayout_7)
        self.horizontalLayout_12 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_12.setObjectName("horizontalLayout_12")
        self.label_22 = QtWidgets.QLabel(self.verticalLayoutWidget_26)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_22.setFont(font)
        self.label_22.setObjectName("label_22")
        self.horizontalLayout_12.addWidget(self.label_22)
        self.lineEdit_4 = QtWidgets.QLineEdit(self.verticalLayoutWidget_26)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit_4.setFont(font)
        self.lineEdit_4.setObjectName("lineEdit_4")
        self.horizontalLayout_12.addWidget(self.lineEdit_4)
        self.verticalLayout_26.addLayout(self.horizontalLayout_12)
        self.pushButton_22 = QtWidgets.QPushButton(self.verticalLayoutWidget_26)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_22.setFont(font)
        self.pushButton_22.setObjectName("pushButton_22")
        self.verticalLayout_26.addWidget(self.pushButton_22)
        self.frame_6 = QtWidgets.QFrame(self.depots_tab)
        self.frame_6.setGeometry(QtCore.QRect(10, 570, 541, 201))
        self.frame_6.setAutoFillBackground(True)
        self.frame_6.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_6.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_6.setObjectName("frame_6")
        self.label_34 = QtWidgets.QLabel(self.frame_6)
        self.label_34.setGeometry(QtCore.QRect(10, 10, 481, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_34.setFont(font)
        self.label_34.setObjectName("label_34")
        self.verticalLayoutWidget_30 = QtWidgets.QWidget(self.frame_6)
        self.verticalLayoutWidget_30.setGeometry(QtCore.QRect(20, 30, 491, 141))
        self.verticalLayoutWidget_30.setObjectName("verticalLayoutWidget_30")
        self.verticalLayout_30 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_30)
        self.verticalLayout_30.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_30.setObjectName("verticalLayout_30")
        self.horizontalLayout_16 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_16.setObjectName("horizontalLayout_16")
        self.label_35 = QtWidgets.QLabel(self.verticalLayoutWidget_30)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_35.setFont(font)
        self.label_35.setObjectName("label_35")
        self.horizontalLayout_16.addWidget(self.label_35)
        self.lineEdit_11 = QtWidgets.QLineEdit(self.verticalLayoutWidget_30)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit_11.setFont(font)
        self.lineEdit_11.setObjectName("lineEdit_11")
        self.horizontalLayout_16.addWidget(self.lineEdit_11)
        self.verticalLayout_30.addLayout(self.horizontalLayout_16)
        self.horizontalLayout_17 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_17.setObjectName("horizontalLayout_17")
        self.label_36 = QtWidgets.QLabel(self.verticalLayoutWidget_30)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_36.setFont(font)
        self.label_36.setObjectName("label_36")
        self.horizontalLayout_17.addWidget(self.label_36)
        self.lineEdit_12 = QtWidgets.QLineEdit(self.verticalLayoutWidget_30)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit_12.setFont(font)
        self.lineEdit_12.setObjectName("lineEdit_12")
        self.horizontalLayout_17.addWidget(self.lineEdit_12)
        self.verticalLayout_30.addLayout(self.horizontalLayout_17)
        self.pushButton_28 = QtWidgets.QPushButton(self.verticalLayoutWidget_30)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_28.setFont(font)
        self.pushButton_28.setObjectName("pushButton_28")
        self.verticalLayout_30.addWidget(self.pushButton_28)
        self.verticalLayoutWidget_2 = QtWidgets.QWidget(self.depots_tab)
        self.verticalLayoutWidget_2.setGeometry(QtCore.QRect(570, 440, 541, 111))
        self.verticalLayoutWidget_2.setObjectName("verticalLayoutWidget_2")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_2)
        self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.pushButton_18 = QtWidgets.QPushButton(self.verticalLayoutWidget_2)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_18.setFont(font)
        self.pushButton_18.setObjectName("pushButton_18")
        self.verticalLayout_3.addWidget(self.pushButton_18)
        self.pushButton_17 = QtWidgets.QPushButton(self.verticalLayoutWidget_2)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_17.setFont(font)
        self.pushButton_17.setObjectName("pushButton_17")
        self.verticalLayout_3.addWidget(self.pushButton_17)
        self.pushButton_29 = QtWidgets.QPushButton(self.verticalLayoutWidget_2)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_29.setFont(font)
        self.pushButton_29.setObjectName("pushButton_29")
        self.verticalLayout_3.addWidget(self.pushButton_29)
        self.verticalLayoutWidget_29 = QtWidgets.QWidget(self.depots_tab)
        self.verticalLayoutWidget_29.setGeometry(QtCore.QRect(1120, 40, 581, 401))
        self.verticalLayoutWidget_29.setObjectName("verticalLayoutWidget_29")
        self.verticalLayout_31 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_29)
        self.verticalLayout_31.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_31.setObjectName("verticalLayout_31")
        self.verticalLayoutWidget_35 = QtWidgets.QWidget(self.depots_tab)
        self.verticalLayoutWidget_35.setGeometry(QtCore.QRect(1120, 10, 581, 31))
        self.verticalLayoutWidget_35.setObjectName("verticalLayoutWidget_35")
        self.verticalLayout_35 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_35)
        self.verticalLayout_35.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_35.setObjectName("verticalLayout_35")
        self.label_32 = QtWidgets.QLabel(self.verticalLayoutWidget_35)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_32.setFont(font)
        self.label_32.setObjectName("label_32")
        self.verticalLayout_35.addWidget(self.label_32)
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap("../.designer/backup/Depot.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.tabWidget.addTab(self.depots_tab, icon1, "")
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.verticalLayoutWidget_7 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_7.setGeometry(QtCore.QRect(10, 10, 491, 61))
        self.verticalLayoutWidget_7.setObjectName("verticalLayoutWidget_7")
        self.verticalLayout_13 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_7)
        self.verticalLayout_13.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_13.setObjectName("verticalLayout_13")
        self.label_25 = QtWidgets.QLabel(self.verticalLayoutWidget_7)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_25.setFont(font)
        self.label_25.setObjectName("label_25")
        self.verticalLayout_13.addWidget(self.label_25)
        self.verticalLayoutWidget_12 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_12.setGeometry(QtCore.QRect(10, 90, 501, 291))
        self.verticalLayoutWidget_12.setObjectName("verticalLayoutWidget_12")
        self.verticalLayout_17 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_12)
        self.verticalLayout_17.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_17.setObjectName("verticalLayout_17")
        self.label_26 = QtWidgets.QLabel(self.verticalLayoutWidget_12)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_26.setFont(font)
        self.label_26.setObjectName("label_26")
        self.verticalLayout_17.addWidget(self.label_26)
        self.checkBox_6 = QtWidgets.QCheckBox(self.verticalLayoutWidget_12)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.checkBox_6.setFont(font)
        self.checkBox_6.setAutoFillBackground(True)
        self.checkBox_6.setChecked(True)
        self.checkBox_6.setObjectName("checkBox_6")
        self.verticalLayout_17.addWidget(self.checkBox_6)
        self.scrollArea_8 = QtWidgets.QScrollArea(self.verticalLayoutWidget_12)
        self.scrollArea_8.setWidgetResizable(True)
        self.scrollArea_8.setObjectName("scrollArea_8")
        self.scrollAreaWidgetContents_8 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_8.setGeometry(QtCore.QRect(0, 0, 497, 217))
        self.scrollAreaWidgetContents_8.setObjectName("scrollAreaWidgetContents_8")
        self.scrollArea_8.setWidget(self.scrollAreaWidgetContents_8)
        self.verticalLayout_17.addWidget(self.scrollArea_8)
        self.label_42 = QtWidgets.QLabel(self.verticalLayoutWidget_12)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_42.setFont(font)
        self.label_42.setObjectName("label_42")
        self.verticalLayout_17.addWidget(self.label_42)
        self.frame_7 = QtWidgets.QFrame(self.tab)
        self.frame_7.setGeometry(QtCore.QRect(10, 540, 501, 191))
        self.frame_7.setAutoFillBackground(True)
        self.frame_7.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_7.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_7.setObjectName("frame_7")
        self.label_38 = QtWidgets.QLabel(self.frame_7)
        self.label_38.setGeometry(QtCore.QRect(10, 10, 481, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_38.setFont(font)
        self.label_38.setObjectName("label_38")
        self.verticalLayoutWidget_33 = QtWidgets.QWidget(self.frame_7)
        self.verticalLayoutWidget_33.setGeometry(QtCore.QRect(20, 30, 461, 141))
        self.verticalLayoutWidget_33.setObjectName("verticalLayoutWidget_33")
        self.verticalLayout_33 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_33)
        self.verticalLayout_33.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_33.setObjectName("verticalLayout_33")
        self.horizontalLayout_14 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_14.setObjectName("horizontalLayout_14")
        self.label_39 = QtWidgets.QLabel(self.verticalLayoutWidget_33)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_39.setFont(font)
        self.label_39.setObjectName("label_39")
        self.horizontalLayout_14.addWidget(self.label_39)
        self.lineEdit_13 = QtWidgets.QLineEdit(self.verticalLayoutWidget_33)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit_13.setFont(font)
        self.lineEdit_13.setObjectName("lineEdit_13")
        self.horizontalLayout_14.addWidget(self.lineEdit_13)
        self.verticalLayout_33.addLayout(self.horizontalLayout_14)
        self.horizontalLayout_15 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_15.setObjectName("horizontalLayout_15")
        self.label_40 = QtWidgets.QLabel(self.verticalLayoutWidget_33)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_40.setFont(font)
        self.label_40.setObjectName("label_40")
        self.horizontalLayout_15.addWidget(self.label_40)
        self.spinBox = QtWidgets.QSpinBox(self.verticalLayoutWidget_33)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.spinBox.setFont(font)
        self.spinBox.setAutoFillBackground(False)
        self.spinBox.setMaximum(999999999)
        self.spinBox.setObjectName("spinBox")
        self.horizontalLayout_15.addWidget(self.spinBox)
        self.verticalLayout_33.addLayout(self.horizontalLayout_15)
        self.pushButton_30 = QtWidgets.QPushButton(self.verticalLayoutWidget_33)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_30.setFont(font)
        self.pushButton_30.setObjectName("pushButton_30")
        self.verticalLayout_33.addWidget(self.pushButton_30)
        self.verticalLayoutWidget_34 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_34.setGeometry(QtCore.QRect(10, 400, 501, 121))
        self.verticalLayoutWidget_34.setObjectName("verticalLayoutWidget_34")
        self.verticalLayout_34 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_34)
        self.verticalLayout_34.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_34.setObjectName("verticalLayout_34")
        self.pushButton_32 = QtWidgets.QPushButton(self.verticalLayoutWidget_34)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_32.setFont(font)
        self.pushButton_32.setObjectName("pushButton_32")
        self.verticalLayout_34.addWidget(self.pushButton_32)
        self.pushButton_27 = QtWidgets.QPushButton(self.verticalLayoutWidget_34)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_27.setFont(font)
        self.pushButton_27.setObjectName("pushButton_27")
        self.verticalLayout_34.addWidget(self.pushButton_27)
        self.pushButton_25 = QtWidgets.QPushButton(self.verticalLayoutWidget_34)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_25.setFont(font)
        self.pushButton_25.setObjectName("pushButton_25")
        self.verticalLayout_34.addWidget(self.pushButton_25)
        self.line_3 = QtWidgets.QFrame(self.tab)
        self.line_3.setGeometry(QtCore.QRect(520, 30, 21, 711))
        self.line_3.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_3.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_3.setObjectName("line_3")
        self.verticalLayoutWidget_36 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_36.setGeometry(QtCore.QRect(550, 10, 531, 61))
        self.verticalLayoutWidget_36.setObjectName("verticalLayoutWidget_36")
        self.verticalLayout_36 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_36)
        self.verticalLayout_36.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_36.setObjectName("verticalLayout_36")
        self.label_33 = QtWidgets.QLabel(self.verticalLayoutWidget_36)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_33.setFont(font)
        self.label_33.setObjectName("label_33")
        self.verticalLayout_36.addWidget(self.label_33)
        self.verticalLayoutWidget_37 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_37.setGeometry(QtCore.QRect(550, 90, 531, 291))
        self.verticalLayoutWidget_37.setObjectName("verticalLayoutWidget_37")
        self.verticalLayout_37 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_37)
        self.verticalLayout_37.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_37.setObjectName("verticalLayout_37")
        self.label_41 = QtWidgets.QLabel(self.verticalLayoutWidget_37)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_41.setFont(font)
        self.label_41.setObjectName("label_41")
        self.verticalLayout_37.addWidget(self.label_41)
        self.scrollArea_9 = QtWidgets.QScrollArea(self.verticalLayoutWidget_37)
        self.scrollArea_9.setWidgetResizable(True)
        self.scrollArea_9.setObjectName("scrollArea_9")
        self.scrollAreaWidgetContents_9 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_9.setGeometry(QtCore.QRect(0, 0, 527, 243))
        self.scrollAreaWidgetContents_9.setObjectName("scrollAreaWidgetContents_9")
        self.scrollArea_9.setWidget(self.scrollAreaWidgetContents_9)
        self.verticalLayout_37.addWidget(self.scrollArea_9)
        self.label_44 = QtWidgets.QLabel(self.verticalLayoutWidget_37)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_44.setFont(font)
        self.label_44.setObjectName("label_44")
        self.verticalLayout_37.addWidget(self.label_44)
        self.verticalLayoutWidget_38 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_38.setGeometry(QtCore.QRect(550, 400, 531, 121))
        self.verticalLayoutWidget_38.setObjectName("verticalLayoutWidget_38")
        self.verticalLayout_38 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_38)
        self.verticalLayout_38.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_38.setObjectName("verticalLayout_38")
        self.pushButton_33 = QtWidgets.QPushButton(self.verticalLayoutWidget_38)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_33.setFont(font)
        self.pushButton_33.setObjectName("pushButton_33")
        self.verticalLayout_38.addWidget(self.pushButton_33)
        self.pushButton_31 = QtWidgets.QPushButton(self.verticalLayoutWidget_38)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_31.setFont(font)
        self.pushButton_31.setObjectName("pushButton_31")
        self.verticalLayout_38.addWidget(self.pushButton_31)
        self.line_4 = QtWidgets.QFrame(self.tab)
        self.line_4.setGeometry(QtCore.QRect(1090, 30, 21, 711))
        self.line_4.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_4.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_4.setObjectName("line_4")
        self.verticalLayoutWidget_39 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_39.setGeometry(QtCore.QRect(1120, 10, 601, 61))
        self.verticalLayoutWidget_39.setObjectName("verticalLayoutWidget_39")
        self.verticalLayout_39 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_39)
        self.verticalLayout_39.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_39.setObjectName("verticalLayout_39")
        self.label_43 = QtWidgets.QLabel(self.verticalLayoutWidget_39)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_43.setFont(font)
        self.label_43.setObjectName("label_43")
        self.verticalLayout_39.addWidget(self.label_43)
        self.verticalLayoutWidget_40 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_40.setGeometry(QtCore.QRect(1120, 90, 601, 291))
        self.verticalLayoutWidget_40.setObjectName("verticalLayoutWidget_40")
        self.verticalLayout_40 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_40)
        self.verticalLayout_40.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_40.setObjectName("verticalLayout_40")
        self.label_45 = QtWidgets.QLabel(self.verticalLayoutWidget_40)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_45.setFont(font)
        self.label_45.setObjectName("label_45")
        self.verticalLayout_40.addWidget(self.label_45)
        self.gridLayout_2 = QtWidgets.QGridLayout()
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.label_24 = QtWidgets.QLabel(self.verticalLayoutWidget_40)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_24.setFont(font)
        self.label_24.setObjectName("label_24")
        self.gridLayout_2.addWidget(self.label_24, 0, 1, 1, 1)
        self.label_23 = QtWidgets.QLabel(self.verticalLayoutWidget_40)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_23.setFont(font)
        self.label_23.setObjectName("label_23")
        self.gridLayout_2.addWidget(self.label_23, 0, 0, 1, 1)
        self.label_47 = QtWidgets.QLabel(self.verticalLayoutWidget_40)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_47.setFont(font)
        self.label_47.setObjectName("label_47")
        self.gridLayout_2.addWidget(self.label_47, 0, 2, 1, 1)
        self.verticalLayout_40.addLayout(self.gridLayout_2)
        self.scrollArea_10 = QtWidgets.QScrollArea(self.verticalLayoutWidget_40)
        self.scrollArea_10.setWidgetResizable(True)
        self.scrollArea_10.setObjectName("scrollArea_10")
        self.scrollAreaWidgetContents_10 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_10.setGeometry(QtCore.QRect(0, 0, 597, 219))
        self.scrollAreaWidgetContents_10.setObjectName("scrollAreaWidgetContents_10")
        self.scrollArea_10.setWidget(self.scrollAreaWidgetContents_10)
        self.verticalLayout_40.addWidget(self.scrollArea_10)
        self.label_46 = QtWidgets.QLabel(self.verticalLayoutWidget_40)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_46.setFont(font)
        self.label_46.setObjectName("label_46")
        self.verticalLayout_40.addWidget(self.label_46)
        self.verticalLayoutWidget_41 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_41.setGeometry(QtCore.QRect(1120, 400, 601, 121))
        self.verticalLayoutWidget_41.setObjectName("verticalLayoutWidget_41")
        self.verticalLayout_41 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_41)
        self.verticalLayout_41.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_41.setObjectName("verticalLayout_41")
        self.pushButton_34 = QtWidgets.QPushButton(self.verticalLayoutWidget_41)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_34.setFont(font)
        self.pushButton_34.setObjectName("pushButton_34")
        self.verticalLayout_41.addWidget(self.pushButton_34)
        self.pushButton_35 = QtWidgets.QPushButton(self.verticalLayoutWidget_41)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_35.setFont(font)
        self.pushButton_35.setObjectName("pushButton_35")
        self.verticalLayout_41.addWidget(self.pushButton_35)
        self.tabWidget.addTab(self.tab, "")
        self.tab_3 = QtWidgets.QWidget()
        self.tab_3.setObjectName("tab_3")
        self.verticalLayoutWidget_8 = QtWidgets.QWidget(self.tab_3)
        self.verticalLayoutWidget_8.setGeometry(QtCore.QRect(10, 10, 1091, 71))
        self.verticalLayoutWidget_8.setObjectName("verticalLayoutWidget_8")
        self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_8)
        self.verticalLayout_7.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.label_12 = QtWidgets.QLabel(self.verticalLayoutWidget_8)
        font = QtGui.QFont()
        font.setPointSize(14)
        font.setBold(True)
        font.setWeight(75)
        self.label_12.setFont(font)
        self.label_12.setObjectName("label_12")
        self.verticalLayout_7.addWidget(self.label_12)
        self.pushButton_8 = QtWidgets.QPushButton(self.verticalLayoutWidget_8)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_8.setFont(font)
        self.pushButton_8.setObjectName("pushButton_8")
        self.verticalLayout_7.addWidget(self.pushButton_8)
        self.verticalLayoutWidget_31 = QtWidgets.QWidget(self.tab_3)
        self.verticalLayoutWidget_31.setGeometry(QtCore.QRect(1110, 10, 621, 501))
        self.verticalLayoutWidget_31.setObjectName("verticalLayoutWidget_31")
        self.verticalLayout_29 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_31)
        self.verticalLayout_29.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_29.setObjectName("verticalLayout_29")
        self.label_27 = QtWidgets.QLabel(self.verticalLayoutWidget_31)
        self.label_27.setObjectName("label_27")
        self.verticalLayout_29.addWidget(self.label_27)
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        self.comboBox = QtWidgets.QComboBox(self.verticalLayoutWidget_31)
        self.comboBox.setObjectName("comboBox")
        self.horizontalLayout_10.addWidget(self.comboBox)
        self.pushButton_36 = QtWidgets.QPushButton(self.verticalLayoutWidget_31)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_36.setFont(font)
        self.pushButton_36.setObjectName("pushButton_36")
        self.horizontalLayout_10.addWidget(self.pushButton_36)
        self.verticalLayout_29.addLayout(self.horizontalLayout_10)
        self.scrollArea = QtWidgets.QScrollArea(self.verticalLayoutWidget_31)
        self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setObjectName("scrollArea")
        self.scrollAreaWidgetContents = QtWidgets.QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 617, 437))
        self.scrollAreaWidgetContents.setObjectName("scrollAreaWidgetContents")
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.verticalLayout_29.addWidget(self.scrollArea)
        self.verticalLayoutWidget_5 = QtWidgets.QWidget(self.tab_3)
        self.verticalLayoutWidget_5.setGeometry(QtCore.QRect(10, 90, 1091, 681))
        self.verticalLayoutWidget_5.setObjectName("verticalLayoutWidget_5")
        self.verticalLayout_8 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_5)
        self.verticalLayout_8.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.frame_8 = QtWidgets.QFrame(self.tab_3)
        self.frame_8.setGeometry(QtCore.QRect(1110, 530, 621, 231))
        self.frame_8.setAutoFillBackground(True)
        self.frame_8.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_8.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_8.setObjectName("frame_8")
        self.gridLayoutWidget = QtWidgets.QWidget(self.frame_8)
        self.gridLayoutWidget.setGeometry(QtCore.QRect(50, 20, 471, 131))
        self.gridLayoutWidget.setObjectName("gridLayoutWidget")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.gridLayoutWidget)
        self.gridLayout_3.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_3.setObjectName("gridLayout_3")
        self.label_53 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_53.setFont(font)
        self.label_53.setText("")
        self.label_53.setObjectName("label_53")
        self.gridLayout_3.addWidget(self.label_53, 0, 2, 1, 1)
        self.label_56 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.label_56.setFont(font)
        self.label_56.setObjectName("label_56")
        self.gridLayout_3.addWidget(self.label_56, 1, 1, 1, 1)
        self.label_52 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.label_52.setFont(font)
        self.label_52.setObjectName("label_52")
        self.gridLayout_3.addWidget(self.label_52, 0, 1, 1, 1)
        self.label_57 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_57.setFont(font)
        self.label_57.setText("")
        self.label_57.setObjectName("label_57")
        self.gridLayout_3.addWidget(self.label_57, 1, 2, 1, 1)
        self.label_54 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.label_54.setFont(font)
        self.label_54.setObjectName("label_54")
        self.gridLayout_3.addWidget(self.label_54, 2, 1, 1, 1)
        self.label_55 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_55.setFont(font)
        self.label_55.setText("")
        self.label_55.setObjectName("label_55")
        self.gridLayout_3.addWidget(self.label_55, 2, 2, 1, 1)
        self.label_58 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.label_58.setFont(font)
        self.label_58.setObjectName("label_58")
        self.gridLayout_3.addWidget(self.label_58, 3, 1, 1, 1)
        self.label_59 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_59.setFont(font)
        self.label_59.setText("")
        self.label_59.setObjectName("label_59")
        self.gridLayout_3.addWidget(self.label_59, 3, 2, 1, 1)
        self.label_60 = QtWidgets.QLabel(self.frame_8)
        self.label_60.setGeometry(QtCore.QRect(10, 190, 601, 29))
        font = QtGui.QFont()
        font.setPointSize(11)
        self.label_60.setFont(font)
        self.label_60.setObjectName("label_60")
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap("../.designer/backup/run.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.tabWidget.addTab(self.tab_3, icon2, "")
        self.tab_4 = QtWidgets.QWidget()
        self.tab_4.setObjectName("tab_4")
        self.verticalLayoutWidget_9 = QtWidgets.QWidget(self.tab_4)
        self.verticalLayoutWidget_9.setGeometry(QtCore.QRect(10, 10, 501, 31))
        self.verticalLayoutWidget_9.setObjectName("verticalLayoutWidget_9")
        self.verticalLayout_14 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_9)
        self.verticalLayout_14.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_14.setObjectName("verticalLayout_14")
        self.label_14 = QtWidgets.QLabel(self.verticalLayoutWidget_9)
        font = QtGui.QFont()
        font.setPointSize(14)
        font.setBold(True)
        font.setWeight(75)
        self.label_14.setFont(font)
        self.label_14.setObjectName("label_14")
        self.verticalLayout_14.addWidget(self.label_14)
        self.verticalLayoutWidget_15 = QtWidgets.QWidget(self.tab_4)
        self.verticalLayoutWidget_15.setGeometry(QtCore.QRect(10, 380, 501, 361))
        self.verticalLayoutWidget_15.setObjectName("verticalLayoutWidget_15")
        self.verticalLayout_20 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_15)
        self.verticalLayout_20.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_20.setObjectName("verticalLayout_20")
        self.verticalLayoutWidget_18 = QtWidgets.QWidget(self.tab_4)
        self.verticalLayoutWidget_18.setGeometry(QtCore.QRect(10, 260, 551, 91))
        self.verticalLayoutWidget_18.setObjectName("verticalLayoutWidget_18")
        self.verticalLayout_23 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_18)
        self.verticalLayout_23.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_23.setObjectName("verticalLayout_23")
        self.lineEdit_5 = QtWidgets.QLineEdit(self.verticalLayoutWidget_18)
        self.lineEdit_5.setObjectName("lineEdit_5")
        self.verticalLayout_23.addWidget(self.lineEdit_5)
        self.pushButton_7 = QtWidgets.QPushButton(self.verticalLayoutWidget_18)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_7.setFont(font)
        self.pushButton_7.setObjectName("pushButton_7")
        self.verticalLayout_23.addWidget(self.pushButton_7)
        self.verticalLayoutWidget_14 = QtWidgets.QWidget(self.tab_4)
        self.verticalLayoutWidget_14.setGeometry(QtCore.QRect(10, 60, 571, 21))
        self.verticalLayoutWidget_14.setObjectName("verticalLayoutWidget_14")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_14)
        self.verticalLayout_4.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.label_2 = QtWidgets.QLabel(self.verticalLayoutWidget_14)
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setItalic(False)
        self.label_2.setFont(font)
        self.label_2.setAcceptDrops(False)
        self.label_2.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.label_2.setAutoFillBackground(False)
        self.label_2.setFrameShadow(QtWidgets.QFrame.Plain)
        self.label_2.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.label_2.setWordWrap(True)
        self.label_2.setObjectName("label_2")
        self.verticalLayout_4.addWidget(self.label_2)
        self.verticalLayoutWidget_20 = QtWidgets.QWidget(self.tab_4)
        self.verticalLayoutWidget_20.setGeometry(QtCore.QRect(10, 90, 571, 41))
        self.verticalLayoutWidget_20.setObjectName("verticalLayoutWidget_20")
        self.verticalLayout_9 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_20)
        self.verticalLayout_9.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_9.setObjectName("verticalLayout_9")
        self.label_6 = QtWidgets.QLabel(self.verticalLayoutWidget_20)
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setItalic(False)
        self.label_6.setFont(font)
        self.label_6.setWordWrap(True)
        self.label_6.setObjectName("label_6")
        self.verticalLayout_9.addWidget(self.label_6)
        self.verticalLayoutWidget_21 = QtWidgets.QWidget(self.tab_4)
        self.verticalLayoutWidget_21.setGeometry(QtCore.QRect(10, 150, 571, 51))
        self.verticalLayoutWidget_21.setObjectName("verticalLayoutWidget_21")
        self.verticalLayout_10 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_21)
        self.verticalLayout_10.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_10.setObjectName("verticalLayout_10")
        self.label_7 = QtWidgets.QLabel(self.verticalLayoutWidget_21)
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setItalic(False)
        self.label_7.setFont(font)
        self.label_7.setWordWrap(True)
        self.label_7.setObjectName("label_7")
        self.verticalLayout_10.addWidget(self.label_7)
        self.verticalLayoutWidget_22 = QtWidgets.QWidget(self.tab_4)
        self.verticalLayoutWidget_22.setGeometry(QtCore.QRect(10, 210, 521, 31))
        self.verticalLayoutWidget_22.setObjectName("verticalLayoutWidget_22")
        self.verticalLayout_11 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_22)
        self.verticalLayout_11.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_11.setObjectName("verticalLayout_11")
        self.label_4 = QtWidgets.QLabel(self.verticalLayoutWidget_22)
        font = QtGui.QFont()
        font.setFamily("Lucida Sans")
        font.setPointSize(9)
        font.setItalic(False)
        font.setUnderline(True)
        self.label_4.setFont(font)
        self.label_4.setAcceptDrops(False)
        self.label_4.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.label_4.setAutoFillBackground(False)
        self.label_4.setFrameShadow(QtWidgets.QFrame.Plain)
        self.label_4.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.label_4.setWordWrap(True)
        self.label_4.setObjectName("label_4")
        self.verticalLayout_11.addWidget(self.label_4)
        icon3 = QtGui.QIcon()
        icon3.addPixmap(QtGui.QPixmap("../.designer/backup/settings.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.tabWidget.addTab(self.tab_4, icon3, "")
        self.verticalLayout.addWidget(self.tabWidget)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1763, 22))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)


        #########################################################################################################################################
        ##########################IMPORTANTE#####################################################################################################
        
        self.scroll_area_4_layout = QFormLayout(self.scrollAreaWidgetContents_4)
        self.scrollArea_6_layout = QFormLayout(self.scrollAreaWidgetContents_6)
        self.scrollArea_5_layout = QFormLayout(self.scrollAreaWidgetContents_5)
        self.scrollArea_7_layout = QFormLayout(self.scrollAreaWidgetContents_7)
        self.scrollArea_8_layout = QFormLayout(self.scrollAreaWidgetContents_8)
        self.scrollArea_9_layout = QFormLayout(self.scrollAreaWidgetContents_9)
        self.ScrollArea_layout = QFormLayout(self.scrollAreaWidgetContents)
        self.scrollArea_10_layout = QGridLayout(self.scrollAreaWidgetContents_10)
        ##self.scrollArea_layout = QFormLayout(self.scrollAreaWidgetContents)

        try:
            if os.path.isfile("Base_Datos_Clientes.txt"):
                base = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')

                if base.empty == False:
                    self.label_17.setText("Los clientes dentro de la base son:")
                    for i in range(base.shape[0]):
                        ID = base.loc[i,"ID"]
                        direccion = base.loc[i,"DIRECCION"]
                        self.display_in_scrollA(ID,direccion,self.scrollArea_6_layout)
        except:
            print('OK')
            
        try:
            if os.path.isfile("Base_Datos_Depots.txt"):
                base_dep = pd.read_csv('Base_Datos_Depots.txt', sep=';', encoding='latin-1')

                if base_dep.empty == False:
                    self.label_19.setText("Los clientes dentro de la base son:")
                    for i in range(base.shape[0]):
                        ID_dep = base_dep.loc[i,"ID"]
                        direccion_dep = base_dep.loc[i,"DIRECCION"]
                        self.display_in_scrollA(ID_dep,direccion_dep,self.scrollArea_7_layout)
        except:
            print('OK')

        try:
            if os.path.isfile("Base_Datos_vehiculos.txt"):
                base_veh = pd.read_csv('Base_Datos_vehiculos.txt', sep=';', encoding='latin-1')

                if base_veh.empty == False:
                    for i in range(base.shape[0]):
                        ID_veh = base_veh.loc[i,"ID"]
                        capacidad = base_veh.loc[i,"CAPACIDAD"]
                        self.display_in_scroll_spinbox_vehiculos(ID_veh,capacidad,self.scrollArea_8_layout)
        except:
            print('OK')
            
            


    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.label.setText(_translate("MainWindow", "Sistema Inteligente de Ruteo de Vehculos"))
        self.checkBox_3.setText(_translate("MainWindow", "Seleccionar/deseleccionar todos"))
        self.label_3.setText(_translate("MainWindow", "Clientes"))
        self.pushButton.setText(_translate("MainWindow", "Carga masiva de Clientes"))
        self.pushButton_4.setText(_translate("MainWindow", "Cargar Base de Clientes"))
        self.pushButton_2.setText(_translate("MainWindow", "Descargar Template"))
        self.label_8.setText(_translate("MainWindow", "Aadir cliente individual a base de datos"))
        self.label_16.setText(_translate("MainWindow", "ID:"))
        self.lineEdit.setPlaceholderText(_translate("MainWindow", "Uniandes"))
        self.label_18.setText(_translate("MainWindow", "Direccin:"))
        self.lineEdit_2.setPlaceholderText(_translate("MainWindow", "Carrera 1 18A 12, Bogot, Colombia"))
        self.pushButton_14.setText(_translate("MainWindow", "Aadir Cliente a la Base"))
        self.pushButton_11.setText(_translate("MainWindow", "Guardar datos de clientes para ruteo"))
        self.pushButton_12.setText(_translate("MainWindow", "Aadir los clientes seleccionados a la base de datos"))
        self.pushButton_23.setText(_translate("MainWindow", "Limpiar ventana"))
        self.label_15.setText(_translate("MainWindow", "Base de Clientes"))
        self.pushButton_13.setText(_translate("MainWindow", "Mostrar Base de Clientes"))
        self.checkBox.setText(_translate("MainWindow", "Seleccionar/deseleccionar todos"))
        self.label_28.setText(_translate("MainWindow", "Aadir cliente individual a orden"))
        self.label_29.setText(_translate("MainWindow", "ID:"))
        self.lineEdit_7.setPlaceholderText(_translate("MainWindow", "Uniandes"))
        self.label_30.setText(_translate("MainWindow", "Direccin:"))
        self.lineEdit_8.setPlaceholderText(_translate("MainWindow", "Carrera 1 18A 12, Bogot, Colombia"))
        self.pushButton_26.setText(_translate("MainWindow", "Aadir Cliente a la Orden"))
        self.pushButton_15.setText(_translate("MainWindow", "Limpiar ventana"))
        self.pushButton_16.setText(_translate("MainWindow", "Guardar cambios"))
        self.pushButton_9.setText(_translate("MainWindow", "Eliminar seleccin"))
        self.label_31.setText(_translate("MainWindow", "Ubicaciones de clientes"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_clientes), _translate("MainWindow", "Clientes"))
        self.label_5.setText(_translate("MainWindow", "Depsitos"))
        self.pushButton_3.setText(_translate("MainWindow", "Carga masiva depsitos"))
        self.pushButton_5.setText(_translate("MainWindow", "Cargar Base depsitos"))
        self.pushButton_6.setText(_translate("MainWindow", "Descargar Template"))
        self.checkBox_2.setText(_translate("MainWindow", "Seleccionar/deseleccionar todos"))
        self.pushButton_19.setText(_translate("MainWindow", "Guardar datos de depsito para ruteo"))
        self.pushButton_20.setText(_translate("MainWindow", "Aadir los depsitos seleccionados a la base de datos"))
        self.pushButton_24.setText(_translate("MainWindow", "Limpiar ventana"))
        self.checkBox_4.setText(_translate("MainWindow", "Seleccionar/deseleccionar todos"))
        self.label_37.setText(_translate("MainWindow", "Nota: nicamente seleccione un depsito"))
        self.label_20.setText(_translate("MainWindow", "Base de Depsitos"))
        self.pushButton_21.setText(_translate("MainWindow", "Cargar Base de Depsitos"))
        self.label_9.setText(_translate("MainWindow", "Aadir depsito individual a base de datos"))
        self.label_21.setText(_translate("MainWindow", "ID:"))
        self.lineEdit_3.setPlaceholderText(_translate("MainWindow", "Uniandes"))
        self.label_22.setText(_translate("MainWindow", "Direccin:"))
        self.lineEdit_4.setPlaceholderText(_translate("MainWindow", "Carrera 1 18A 12, Bogot, Colombia"))
        self.pushButton_22.setText(_translate("MainWindow", "Aadir Depsito a la Base"))
        self.label_34.setText(_translate("MainWindow", "Aadir depsito individual a la orden"))
        self.label_35.setText(_translate("MainWindow", "ID:"))
        self.lineEdit_11.setPlaceholderText(_translate("MainWindow", "Uniandes"))
        self.label_36.setText(_translate("MainWindow", "Direccin:"))
        self.lineEdit_12.setPlaceholderText(_translate("MainWindow", "Carrera 1 18A 12, Bogot, Colombia"))
        self.pushButton_28.setText(_translate("MainWindow", "Aadir Depsito a la orden"))
        self.pushButton_18.setText(_translate("MainWindow", "Limpiar Ventana"))
        self.pushButton_17.setText(_translate("MainWindow", "Guardar Cambios"))
        self.pushButton_29.setText(_translate("MainWindow", "Eliminar seleccin"))
        self.label_32.setText(_translate("MainWindow", "Ubicaciones"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.depots_tab), _translate("MainWindow", "Depsitos"))
        self.label_25.setText(_translate("MainWindow", "Vehculos"))
        self.label_26.setText(_translate("MainWindow", "Los vehculos guardados son:"))
        self.checkBox_6.setText(_translate("MainWindow", "Seleccionar/deseleccionar todos"))
        self.label_42.setText(_translate("MainWindow", "Nota: nicamente seleccione un vehculo."))
        self.label_38.setText(_translate("MainWindow", "Aadir vehculo"))
        self.label_39.setText(_translate("MainWindow", "ID:"))
        self.lineEdit_13.setPlaceholderText(_translate("MainWindow", "Vehculo 1"))
        self.label_40.setText(_translate("MainWindow", "Capacidad"))
        self.pushButton_30.setText(_translate("MainWindow", "Aadir vehculo"))
        self.pushButton_32.setText(_translate("MainWindow", "Guardar vehculo para ruteo"))
        self.pushButton_27.setText(_translate("MainWindow", "Guardar cambios"))
        self.pushButton_25.setText(_translate("MainWindow", "Eliminar seleccin"))
        self.label_33.setText(_translate("MainWindow", "Demandas"))
        self.label_41.setText(_translate("MainWindow", "Ingrese la demanda de cada cliente"))
        self.label_44.setText(_translate("MainWindow", "Ingrese nicamente nmeros."))
        self.pushButton_33.setText(_translate("MainWindow", "Guardar demandas"))
        self.pushButton_31.setText(_translate("MainWindow", "Limpiar ventana"))
        self.label_43.setText(_translate("MainWindow", "Ventanas de Tiempo"))
        self.label_45.setText(_translate("MainWindow", "Ingrese los tiempos de servicio de cada cliente"))
        self.label_24.setText(_translate("MainWindow", "Hora inicio"))
        self.label_23.setText(_translate("MainWindow", "ID"))
        self.label_47.setText(_translate("MainWindow", "Hora Fin"))
        self.label_46.setText(_translate("MainWindow", "Ingrese nicamente nmeros."))
        self.pushButton_34.setText(_translate("MainWindow", "Guardar ventanas de tiempo"))
        self.pushButton_35.setText(_translate("MainWindow", "Limpiar ventana"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("MainWindow", "Vehculos/Restricciones"))
        self.label_12.setText(_translate("MainWindow", "Ruteo"))
        self.pushButton_8.setText(_translate("MainWindow", "Establecer condiciones de ruteo"))
        self.label_27.setText(_translate("MainWindow", "Seleccione la ruta a mostrar:"))
        self.pushButton_36.setText(_translate("MainWindow", "Actualizar"))
        self.label_56.setText(_translate("MainWindow", "Distancia (kilometros):"))
        self.label_52.setText(_translate("MainWindow", "Distancia (metros):"))
        self.label_54.setText(_translate("MainWindow", "Tiempo prom. (minutos):"))
        self.label_58.setText(_translate("MainWindow", "Tiempo prom. (horas):"))
        self.label_60.setText(_translate("MainWindow", "Nota: Se asume una velocidad promedio de 60 km/h."))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_3), _translate("MainWindow", "Ruteo"))
        self.label_14.setText(_translate("MainWindow", "Opciones de corrida"))
        self.pushButton_7.setText(_translate("MainWindow", "Cambiar Ubicacin"))
        self.label_2.setText(_translate("MainWindow", "La ubicacin por default se encuentra en Bogot, Colombia."))
        self.label_6.setText(_translate("MainWindow", "Si desea cambiar la locacin, esto tomar un poco de tiempo."))
        self.label_7.setText(_translate("MainWindow", "Por favor ingrese a continuacin la nueva ubicacin con el siguiente formato:"))
        self.label_4.setText(_translate("MainWindow", "Ciudad, Departamento/Estado, Pas"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_4), _translate("MainWindow", "Ajustes"))

        ########################################## INTERFAZ ARRIBA ##################################################
        
        self.data_clientes = pd.DataFrame()
        self.data_deposito = pd.DataFrame()
        self.data_tiempos = pd.DataFrame()
        self.data_cargas = pd.DataFrame()
        self.data_vehiculo = pd.DataFrame()

        #Crear geolocator y mapa
        self.geolocator = ArcGIS()
        self.graph_area = "Bogot, Distrito Capital, Colombia"
        self.G = ox.graph_from_place(self.graph_area, network_type='drive', simplify=True)
        # OSM data are sometime incomplete so we use the speed module of osmnx to add missing edge speeds and travel times
        self.G = ox.add_edge_speeds(self.G)
        self.G = ox.add_edge_travel_times(self.G)        
        
        
        #Set up mapa depots
        self.web_view_depots = QWebEngineView()
        self.verticalLayout_31.addWidget(self.web_view_depots)
        # Set up Folium map- inicializacion
        # self.map = folium.Map(location=[4.6097, -74.06508], zoom_start=12)
        self.map_depots = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
        # Convert Folium map to HTML and display in web view
        self.html_depots = self.map_depots._repr_html_()
        self.web_view_depots.setHtml(self.html_depots)
        
        #Set up mapa clientes
        self.web_view_clientes = QWebEngineView()
        self.verticalLayout_27.addWidget(self.web_view_clientes)
        # Set up Folium map- inicializacion
        # self.map = folium.Map(location=[4.6097, -74.06508], zoom_start=12)
        self.map_clientes = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
        # Convert Folium map to HTML and display in web view
        self.html_clientes = self.map_clientes._repr_html_()
        self.web_view_clientes.setHtml(self.html_clientes)
        
        # Set up de mapa inicial ruteo
        self.web_view = QWebEngineView()
        self.verticalLayout_8.addWidget(self.web_view)
        # Set up Folium map- inicializacion
        # self.map = folium.Map(location=[4.60302, -74.06508], zoom_start=12)
        self.map = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
        # Convert Folium map to HTML and display in web view
        self.html = self.map._repr_html_()
        self.web_view.setHtml(self.html)
        
        #### Matrices
        self.matriz_distancias = []
        self.base_lat_lon = []
        self.capacidad_vehiculo = 99999999999999999999
        #Velocidad promedio 1000 m/min o 60km/h
        self.vel_promedio = 1000

        self.camino_sublistas =  []
        self.camino_entero = []

        self.mapa_completo = []

        self.subset_lat_lon = []
        
        #Link a botones-acciones
        self.pushButton.clicked.connect(self.carga_masiva_clientes)
        self.pushButton_4.clicked.connect(self.cargar_base_clientes)
        self.pushButton_2.clicked.connect(self.descargar_template_clientes)
        self.pushButton_23.clicked.connect(self.clear_layout_clientes)
        self.pushButton_12.clicked.connect(self.escribir_sobre_base_clientes)
        self.pushButton_11.clicked.connect(self.extraer_clientes_corrida)
        self.pushButton_13.clicked.connect(self.display_base_clientes)
        self.pushButton_16.clicked.connect(self.guardar_cambios_clientes)
        self.pushButton_15.clicked.connect(self.clear_layout_base_clientes)
        self.pushButton_26.clicked.connect(self.anadir_cliente_ind_orden)
        self.pushButton_14.clicked.connect(self.anadir_cliente_ind_base)
        self.pushButton_9.clicked.connect(self.eliminar_clientes)
        self.pushButton_3.clicked.connect(self.carga_masiva_depositos)
        self.pushButton_5.clicked.connect(self.cargar_base_depots)
        self.pushButton_6.clicked.connect(self.descargar_template_depots)
        self.pushButton_20.clicked.connect(self.escribir_sobre_base_depots)
        self.pushButton_24.clicked.connect(self.clear_layout_depots)
        self.pushButton_21.clicked.connect(self.display_base_depots)
        self.pushButton_17.clicked.connect(self.guardar_cambios_depots)
        self.pushButton_18.clicked.connect(self.clear_layout_base_depots)
        self.pushButton_29.clicked.connect(self.eliminar_depots)
        self.pushButton_28.clicked.connect(self.anadir_depot_ind_orden)
        self.pushButton_22.clicked.connect(self.anadir_depot_ind_base)
        self.pushButton_19.clicked.connect(self.extraer_deposito_corrida)
        self.pushButton_8.clicked.connect(self.abrir_opciones_correr)
        self.pushButton_7.clicked.connect(self.cambiar_ubicacion)
        self.pushButton_30.clicked.connect(self.agregar_vehiculo)
        self.pushButton_27.clicked.connect(self.guardar_cambios_vehiculos)
        self.pushButton_25.clicked.connect(self.eliminar_vehiculos)
        self.pushButton_31.clicked.connect(self.clear_layout_carga)
        self.pushButton_32.clicked.connect(self.extraer_capacidad_vehiculo)
        self.pushButton_33.clicked.connect(self.extraer_df_cargas)
        self.pushButton_34.clicked.connect(self.crear_dataframe_tiempos)
        self.pushButton_35.clicked.connect(self.clear_layout_tiempos)
        self.pushButton_36.clicked.connect(self.actualizar_resultado)



        self.checkBox.stateChanged.connect(self.seleccionar_todos_clientes_base)
        self.checkBox_3.stateChanged.connect(self.seleccionar_todos_clientes)
        self.checkBox_4.stateChanged.connect(self.seleccionar_todos_depots)
        self.checkBox_2.stateChanged.connect(self.seleccionar_todos_depots_base)
        self.checkBox_6.stateChanged.connect(self.seleccionar_todos_vehiculos)

        #self.comboBox.currentIndexChanged.connect(self.actualizar_resultado)
        
        
        #########################################################################################################################
        ############################### TAB CLIENTES ############################################################################
        #########################################################################################################################
        
    def carga_masiva_clientes(self):
        # open file dialog to select CSV file
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        fileFilters = "Text Files (*.txt);;All Files (*)"
        self.file_path, _ = QFileDialog.getOpenFileName(self, "Open File", "", fileFilters, options=options)
        try:    
            if self.file_path:
                direcciones_clientes = pd.read_csv(self.file_path, sep=';')
                if direcciones_clientes.shape[1] == 2:
                    self.checkboxes = []
                    comunes = []
                    self.label_10.setText("Los clientes de la orden son:")
                    for i in range(direcciones_clientes.shape[0]):
                        ID = direcciones_clientes.loc[i,"ID"]
                        direccion = direcciones_clientes.loc[i,"DIRECCION"]
                        geo_punto = self.geolocator.geocode(direccion, timeout=180)
                        if geo_punto:
                            self.display_in_scrollA(ID,direccion,self.scroll_area_4_layout)
                        else:
                            n = i + 1
                            string = ID + ' (Linea ' + str(n) + ')'
                            comunes.append(string)
                    if len(comunes) > 0:
                            array_str = ', '.join(str(elem) for elem in comunes)
                            text = f'Los siguientes IDs tienen una direccin invlida: {array_str}'
                            QMessageBox.warning(self, "Warning", text)
                    # else:
                    #     df_temp = self.crear_dataframe_clientes()
                        
                    #     self.df_lat_lon_clientes = sacar_lat_lon_clientes(df_temp,self.geolocator,self.G)
                    #     index_list = self.df_lat_lon_clientes.index.values.tolist()
                    #     m_temp = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
                    #     for i in range(0,self.df_lat_lon_clientes.shape[0]):
                    #         folium.Marker(location=[self.df_lat_lon_clientes.iloc[i]['lat'], self.df_lat_lon_clientes.iloc[i]['lon']], popup=index_list[i]).add_to(m_temp)
                    #     self.html_clientes = m_temp._repr_html_()
                    #     self.web_view_clientes.setHtml(self.html_clientes)
                else: 
                    QMessageBox.warning(self, "Warning", "Revise que el archivo cargado cumple con el formato")
            else:
                self.label_10.setText("Cargue un archivo vlido:")
        except:
            QMessageBox.warning(self, "Warning", "Verifique que el archivo cargado cumple con los requisitos")
            
    def display_in_scrollA(self,name, direction, scrollA):
        # layout = QHBoxLayout()

        checkbox = QCheckBox(name, self)
        checkbox.setObjectName(name)
        checkbox.setChecked(True)
        fc = checkbox.font()
        fc.setPointSize(7)
        checkbox.setFont(fc)

        lineedit = QLineEdit(direction)
        lineedit.setObjectName(name)
        f = lineedit.font()
        f.setPointSize(7)
        lineedit.setFont(f)
        
        scrollA.addRow(checkbox, lineedit)

    def display_in_scroll_con_carga_masiva(self,name, carga, scrollA):
        # layout = QHBoxLayout()

        checkbox = QCheckBox(name, self)
        checkbox.setObjectName(name)
        checkbox.setChecked(True)
        checkbox.setEnabled(False)
        fc = checkbox.font()
        fc.setPointSize(7)
        checkbox.setFont(fc)

        lineedit = QLineEdit()
        lineedit.setObjectName(name)
        lineedit.setText(str(carga))
        f = lineedit.font()
        f.setPointSize(7)
        lineedit.setFont(f)
        
        scrollA.addRow(checkbox, lineedit)

    def cargar_base_clientes(self):
        if os.path.isfile("Base_Datos_Clientes.txt"):
            direcciones_clientes = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
            self.checkboxes = []

            if direcciones_clientes.empty == False:
                self.label_10.setText("Seleccione los clientes para la orden:")
                for i in range(direcciones_clientes.shape[0]):
                    ID = direcciones_clientes.loc[i,"ID"]
                    direccion = direcciones_clientes.loc[i,"DIRECCION"]
                    self.display_in_scrollA(ID,direccion,self.scroll_area_4_layout)  
            else:
                QMessageBox.warning(self, "Warning", "La base de datos est vacia")
            return
        else:
            QMessageBox.warning(self, "Warning", "No existe base de datos")
        return

    def clear_layout_clientes(self):
        n = self.scroll_area_4_layout.rowCount()
        if n >0:
            for i in reversed(range(n)):
                self.scroll_area_4_layout.removeRow(i)          
        self.map_clientes = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
        # Convert Folium map to HTML and display in web view
        self.html_clientes = self.map_clientes._repr_html_()
        self.web_view_clientes.setHtml(self.html_clientes)
                         
    def descargar_template_clientes(self):
        # Get the URL of the file to download
        with open('Template Agregar Clientes.txt', 'w') as f:
            f.write("Para agregar clientes de forma masiva debe ingresarlos con el siguiente formato en un archivo .txt, separado por punto y coma:")
            f.write('\n')
            f.write('\n')
            f.write("Ejemplo 1: Clientes sin demanda/carga")
            f.write('\n')
            f.write("ID;DIRECCION")
            f.write("Uniandes;Carrera 1 18A 12, Bogot, Colombia")
            f.write('\n')
            f.write("Nota: Agregue nicamente un cliente por linea. Dejar en la primera linea 'ID;DIRECCION'")
        QMessageBox.information(self, "Information", "El template fue descargado en la misma carpeta que la aplicacin.")
            
    def crear_dataframe_clientes(self):
        items = self.scrollArea_4.findChildren(QWidget)
        data = []
        for item in items:
            if isinstance(item, QCheckBox) and item.isChecked():
                name = item.objectName()
                direction = item.parent().findChild(QLineEdit, name).text()
                data.append([name, direction])

        df = pd.DataFrame(data, columns=["ID", "DIRECCION"])
        return(df)   
    
    def extraer_clientes_corrida(self):
        self.data_clientes = self.crear_dataframe_clientes()
        if self.data_clientes.empty:
            QMessageBox.warning(self, "Warning", "Debe seleccionar al menos un cliente para la corrida")
        else:
            self.clear_layout_carga()
            self.clear_layout_tiempos()
            for i in range(self.data_clientes.shape[0]):
                ID = self.data_clientes.loc[i, "ID"]
                self.display_in_scroll_cargas(ID, self.scrollArea_9_layout)

            # Display en scroll tiempos
            for i in range(self.data_clientes.shape[0]):
                ID = self.data_clientes.loc[i, "ID"]

                checkbox = QCheckBox(ID,self)
                checkbox.setObjectName(ID)
                checkbox.setChecked(True)
                checkbox.setEnabled(False)
                fc = checkbox.font()
                fc.setPointSize(7)
                checkbox.setFont(fc)

                time_inicio = QTimeEdit()
                nombre_inicio = ID + "_inicio" 
                time_inicio.setObjectName(nombre_inicio)
                fc = time_inicio.font()
                fc.setPointSize(7)
                time_inicio.setFont(fc)

                time_fin = QTimeEdit()
                nombre_fin = ID + "_fin" 
                time_fin.setObjectName(nombre_fin)
                fc = time_fin.font()
                fc.setPointSize(7)
                time_fin.setFont(fc)

                self.scrollArea_10_layout.addWidget(checkbox, i, 0)
                self.scrollArea_10_layout.addWidget(time_inicio, i, 1)
                self.scrollArea_10_layout.addWidget(time_fin, i, 2)

                if os.path.isfile("Base_lat_lon.txt"):
                    try:
                        base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep = ";", index_col = 0, encoding='latin-1')
                        self.df_lat_lon_clientes = base_lat_lon.loc[self.data_clientes["ID"]]
                        index_list = self.df_lat_lon_clientes.index.values.tolist()
                        m_temp = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
                        for i in range(0,self.df_lat_lon_clientes.shape[0]):
                            folium.Marker(location=[self.df_lat_lon_clientes.iloc[i]['lat'], self.df_lat_lon_clientes.iloc[i]['lon']], popup=index_list[i]).add_to(m_temp)
                        self.html_clientes = m_temp._repr_html_()
                        self.web_view_clientes.setHtml(self.html_clientes)
                    except:
                        self.df_lat_lon_clientes = sacar_lat_lon_clientes(self.data_clientes,self.geolocator,self.G)
                        index_list = self.df_lat_lon_clientes.index.values.tolist()
                        m_temp = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
                        for i in range(0,self.df_lat_lon_clientes.shape[0]):
                            folium.Marker(location=[self.df_lat_lon_clientes.iloc[i]['lat'], self.df_lat_lon_clientes.iloc[i]['lon']], popup=index_list[i]).add_to(m_temp)
                        self.html_clientes = m_temp._repr_html_()
                        self.web_view_clientes.setHtml(self.html_clientes)

                else:
                    self.df_lat_lon_clientes = sacar_lat_lon_clientes(self.data_clientes,self.geolocator,self.G)
                    index_list = self.df_lat_lon_clientes.index.values.tolist()
                    m_temp = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
                    for i in range(0,self.df_lat_lon_clientes.shape[0]):
                        folium.Marker(location=[self.df_lat_lon_clientes.iloc[i]['lat'], self.df_lat_lon_clientes.iloc[i]['lon']], popup=index_list[i]).add_to(m_temp)
                    self.html_clientes = m_temp._repr_html_()
                    self.web_view_clientes.setHtml(self.html_clientes)

            QMessageBox.information(self, "Information", "El/Los Clientes han sido guardados, puede continuar.")
         
    def escribir_sobre_base_clientes(self):
        QMessageBox.information(self, "Information", "A continuacin almacenar los clientes a la base de datos y guardar su distancia entre ellos mismos, esto tomar un poco de tiempo.\nPor favor, no oprima ningn botn hasta que el sistema indique que los clientes fueron agregados a la base ")
        df = self.crear_dataframe_clientes()
        self.base_lat_lon = sacar_lat_lon_clientes(df,self.geolocator,self.G)
        if df.empty == False:
            if os.path.isfile("Base_Datos_Clientes.txt"):
                base = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
                common_elements = base[base['ID'].isin(df['ID'])]['ID']
                if common_elements.empty == False:
                    array_str = ', '.join(str(elem) for elem in common_elements)
                    text = f'Los siguientes IDs ya se encuentran en la base de datos: {array_str}'
                    QMessageBox.warning(self, "Warning", text)
                else:

                    f = open('Base_Datos_Clientes.txt', "a")
                    f.write("\n")
                    for index, row in df.iterrows():
                        f.write(row["ID"] + ";" + row["DIRECCION"] + "\n")
                    f.close()

                    #Escribir en base de lat lon 
                    if os.path.isfile("Base_lat_lon.txt"):
                        with open("Base_lat_lon.txt", mode="a") as f:
                            self.base_lat_lon.to_csv(f, sep=";", header=False)
                    else:
                        self.base_lat_lon.to_csv("Base_lat_lon.txt", sep=";", index=True)

                    if os.path.isfile("matriz_distancias.txt"):
                        matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                        base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                        derecha_temporal = pd.DataFrame(index = matriz_distancias.index, columns = df['ID'])
                        for fila in matriz_distancias.index:
                            nodoA = base_lat_lon.loc[fila,'nodo']
                            for col in df['ID']:
                                nodoB = base_lat_lon.loc[col,'nodo']
                                try:
                                    distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                    derecha_temporal.loc[fila,col] = distancia
                                except:
                                    distancia = "NoDisponible"
                                    derecha_temporal.loc[fila,col] = distancia

                        abajo_temporal = pd.DataFrame(index = df['ID'], columns = matriz_distancias.index)
                        for fila in df['ID']:
                            nodoA = base_lat_lon.loc[fila,'nodo']
                            for col in matriz_distancias.index:
                                nodoB = base_lat_lon.loc[col,'nodo']
                                try:
                                    distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                    abajo_temporal.loc[fila,col] = distancia
                                except:
                                    distancia = "NoDisponible"
                                    abajo_temporal.loc[fila,col] = distancia

                        identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                        concat1 = pd.concat([matriz_distancias, abajo_temporal])
                        concat2 = pd.concat([derecha_temporal, identidad_temporal])

                        nueva_matriz = pd.concat([concat1, concat2], axis = 1)

                        ids_NoDisponibles = []
                        for fila in nueva_matriz.index:
                            conteo = 0
                            # Iterar sobre las columnas del DataFrame
                            for col in nueva_matriz.index:
                                if nueva_matriz.loc[fila,col] == "NoDisponible":
                                    conteo += 1
                            if conteo == nueva_matriz.shape[1] -1:
                                ids_NoDisponibles.append(fila)

                        if len(ids_NoDisponibles) > 0:
                            nueva_matriz = nueva_matriz.drop(ids_NoDisponibles, axis = 1)
                            nueva_matriz = nueva_matriz.drop(ids_NoDisponibles)
                            array_str = ', '.join(str(elem) for elem in ids_NoDisponibles)
                            text = f'Los siguientes IDs tienen una direccin fuera de la geografa delimitada: {array_str}. \n Por favor revise'
                            QMessageBox.warning(self, "Warning", text)

                            base_clientes = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
                            base_clientes = base_clientes.drop(ids_NoDisponibles)
                            base_clientes.to_csv('Base_Datos_Clientes.txt', index = True, sep=';')

                            base_lat_lon = pd.read_csv('Base_lat_lon.txt', sep=';', encoding='latin-1')
                            base_lat_lon = base_lat_lon.drop(ids_NoDisponibles)
                            base_lat_lon.to_csv('Base_lat_lon.txt', index = True, sep=';')


                        nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                        QMessageBox.information(self, "Information", "El/Los clientes han sido agregados a la base de datos")
                    else:
                        nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                        ids_NoDisponibles = []
                        for fila in nueva_matriz.index:
                            conteo = 0
                            # Iterar sobre las columnas del DataFrame
                            for col in nueva_matriz.index:
                                if nueva_matriz.loc[fila,col] == "NoDisponible":
                                    conteo += 1
                            if conteo == nueva_matriz.shape[1] -1:
                                ids_NoDisponibles.append(fila)

                        if len(ids_NoDisponibles) > 0:
                            nueva_matriz = nueva_matriz.drop(ids_NoDisponibles, axis = 1)
                            nueva_matriz = nueva_matriz.drop(ids_NoDisponibles)
                            array_str = ', '.join(str(elem) for elem in ids_NoDisponibles)
                            text = f'Los siguientes IDs tienen una direccin fuera de la geografa delimitada: {array_str}'
                            QMessageBox.warning(self, "Warning", text)

                            base_clientes = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
                            base_clientes = base_clientes.drop(ids_NoDisponibles)
                            base_clientes.to_csv('Base_Datos_Clientes.txt', index = True, sep=';')

                            base_lat_lon = pd.read_csv('Base_lat_lon.txt', sep=';', encoding='latin-1')
                            base_lat_lon = base_lat_lon.drop(ids_NoDisponibles)
                            base_lat_lon.to_csv('Base_lat_lon.txt', index = True, sep=';')

                        nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')    
                        QMessageBox.information(self, "Information", "El/Los clientes han sido agregados a la base de datos")  

                    self.clear_layout_clientes()
                    self.clear_layout_base_clientes()
                    time.sleep(0.02)
                    self.display_base_clientes()
            else:
                f = open('Base_Datos_Clientes.txt', "a")
                f.write("ID;DIRECCION")
                f.write("\n")
                for index, row in df.iterrows():
                    f.write(row["ID"] + ";" + row["DIRECCION"] + "\n")
                f.close()
                
                if os.path.isfile("Base_lat_lon.txt"):
                    with open("Base_lat_lon.txt", mode="a") as f:
                        self.base_lat_lon.to_csv(f, sep=";", header=False)
                else:
                    self.base_lat_lon.to_csv("Base_lat_lon.txt", sep=";", index=True)
                
                if os.path.isfile("matriz_distancias.txt"):
                    matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                    base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                    derecha_temporal = pd.DataFrame(index = matriz_distancias.index, columns = df['ID'])
                    for fila in matriz_distancias.index:
                        nodoA = base_lat_lon.loc[fila,'nodo']
                        for col in df['ID']:
                            nodoB = base_lat_lon.loc[col,'nodo']
                            try:
                                distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                derecha_temporal.loc[fila,col] = distancia
                            except:
                                distancia = "NoDisponible"
                                derecha_temporal.loc[fila,col] = distancia

                    abajo_temporal = pd.DataFrame(index = df['ID'], columns = matriz_distancias.index)
                    for fila in df['ID']:
                        nodoA = base_lat_lon.loc[fila,'nodo']
                        for col in matriz_distancias.index:
                            nodoB = base_lat_lon.loc[col,'nodo']
                            try:
                                distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                abajo_temporal.loc[fila,col] = distancia
                            except:
                                distancia = "NoDisponible"
                                abajo_temporal.loc[fila,col] = distancia

                    identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                    concat1 = pd.concat([matriz_distancias, abajo_temporal])
                    concat2 = pd.concat([derecha_temporal, identidad_temporal])

                    nueva_matriz = pd.concat([concat1, concat2], axis = 1)

                    ids_NoDisponibles = []
                    for fila in nueva_matriz.index:
                        conteo = 0
                        # Iterar sobre las columnas del DataFrame
                        for col in nueva_matriz.index:
                            if nueva_matriz.loc[fila,col] == "NoDisponible":
                                conteo += 1
                        if conteo == nueva_matriz.shape[1] -1:
                            ids_NoDisponibles.append(fila)

                    if len(ids_NoDisponibles) > 0:
                        nueva_matriz = nueva_matriz.drop(ids_NoDisponibles, axis = 1)
                        nueva_matriz = nueva_matriz.drop(ids_NoDisponibles)
                        array_str = ', '.join(str(elem) for elem in ids_NoDisponibles)
                        text = f'Los siguientes IDs tienen una direccin fuera de la geografa delimitada: {array_str}. \n Por favor revise'
                        QMessageBox.warning(self, "Warning", text)

                        base_clientes = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
                        base_clientes = base_clientes.drop(ids_NoDisponibles)
                        base_clientes.to_csv('Base_Datos_Clientes.txt', index = True, header = True, sep=';')

                        base_lat_lon = pd.read_csv('Base_lat_lon.txt', sep=';', encoding='latin-1')
                        base_lat_lon = base_lat_lon.drop(ids_NoDisponibles)
                        base_lat_lon.to_csv('Base_lat_lon.txt', index = True, header = True, sep=';')


                    nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')

                    QMessageBox.information(self, "Information", "El/Los clientes han sido agregados a la base de datos")
                else:
                    nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                    nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')  
                    ids_NoDisponibles = []
                    for fila in nueva_matriz.index:
                        conteo = 0
                        # Iterar sobre las columnas del DataFrame
                        for col in nueva_matriz.index:
                            if nueva_matriz.loc[fila,col] == "NoDisponible":
                                conteo += 1
                        if conteo == nueva_matriz.shape[1] -1:
                            ids_NoDisponibles.append(fila)

                    if len(ids_NoDisponibles) > 0:
                        nueva_matriz = nueva_matriz.drop(ids_NoDisponibles, axis = 1)
                        nueva_matriz = nueva_matriz.drop(ids_NoDisponibles)
                        array_str = ', '.join(str(elem) for elem in ids_NoDisponibles)
                        text = f'Los siguientes IDs tienen una direccin fuera de la geografa delimitada: {array_str}'
                        QMessageBox.warning(self, "Warning", text)

                        base_clientes = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
                        base_clientes = base_clientes.drop(ids_NoDisponibles)
                        base_clientes.to_csv('Base_Datos_Clientes.txt', index = True, sep=';')

                        base_lat_lon = pd.read_csv('Base_lat_lon.txt', sep=';', encoding='latin-1')
                        base_lat_lon = base_lat_lon.drop(ids_NoDisponibles)
                        base_lat_lon.to_csv('Base_lat_lon.txt', index = True, sep=';')

                    nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')                  
                    QMessageBox.information(self, "Information", "El/Los clientes han sido agregados a la base de datos")
                self.clear_layout_clientes()
                self.clear_layout_base_clientes()
                time.sleep(0.02)
                self.display_base_clientes()
        else:
            QMessageBox.warning(self, "Warning", "Debe seleccionar al menos un cliente para ser guardado en la base de datos")
        
    def display_base_clientes(self):
        if os.path.isfile("Base_Datos_Clientes.txt"):
            base = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
            self.checkboxes_base_clientes = []

            if base.empty == False:
                self.label_17.setText("Los clientes dentro de la base son:")
                for i in range(base.shape[0]):
                    ID = base.loc[i,"ID"]
                    direccion = base.loc[i,"DIRECCION"]
                    self.display_in_scrollA(ID,direccion,self.scrollArea_6_layout)  
            else:
                QMessageBox.warning(self, "Warning", "La base de datos est vacia")
            return
        else:
            QMessageBox.warning(self, "Warning", "No existen registros en la base")
        return
     
    def guardar_cambios_clientes(self):
        QMessageBox.information(self, "Information", "A continuacin guardar los cambios y actualizar la base de datos, esto tomar un poco de tiempo. \nPor favor, no oprima ningn botn hasta que el sistema indique que los datos fueron guardados")
        items = self.scrollArea_6.findChildren(QWidget)
        data = []
        if items is not None:
            for item in items:
                if isinstance(item, QCheckBox):
                    name = item.objectName()
                    direction = item.parent().findChild(QLineEdit, name).text()
                    data.append([name, direction])

            df = pd.DataFrame(data, columns=["ID", "DIRECCION"])
            f = open('Base_Datos_Clientes.txt', "w")
            f.write("ID;DIRECCION")
            f.write("\n")
            for index, row in df.iterrows():
                f.write(row["ID"] + ";" + row["DIRECCION"] + "\n")
            f.close()

            try:
                self.base_lat_lon = sacar_lat_lon_clientes(df,self.geolocator,self.G)
                #Escribir en base de lat lon 
                if os.path.isfile("Base_lat_lon.txt"):
                    base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                    mascara = ~base_lat_lon.index.isin(df['ID'])
                    base_filtrada = base_lat_lon[mascara]
                    nueva_base = pd.concat([base_filtrada, self.base_lat_lon])
                    nueva_base.to_csv("Base_lat_lon.txt", sep=";", index=True)

                if os.path.isfile("matriz_distancias.txt"):
                    matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                    if matriz_distancias.empty == True:
                        nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                        ids_NoDisponibles = []
                        for fila in nueva_matriz.index:
                            conteo = 0
                            # Iterar sobre las columnas del DataFrame
                            for col in nueva_matriz.index:
                                if nueva_matriz.loc[fila,col] == "NoDisponible":
                                    conteo += 1
                            if conteo == nueva_matriz.shape[1] -1:
                                ids_NoDisponibles.append(fila)

                        if len(ids_NoDisponibles) > 0:
                            nueva_matriz = nueva_matriz.drop(ids_NoDisponibles, axis = 1)
                            nueva_matriz = nueva_matriz.drop(ids_NoDisponibles)
                            array_str = ', '.join(str(elem) for elem in ids_NoDisponibles)
                            text = f'Los siguientes IDs tienen una direccin fuera de la geografa delimitada: {array_str}'
                            QMessageBox.warning(self, "Warning", text)

                            base_clientes = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
                            base_clientes = base_clientes.drop(ids_NoDisponibles)
                            base_clientes.to_csv('Base_Datos_Clientes.txt', index = True, sep=';')

                            base_lat_lon = pd.read_csv('Base_lat_lon.txt', sep=';', encoding='latin-1')
                            base_lat_lon = base_lat_lon.drop(ids_NoDisponibles)
                            base_lat_lon.to_csv('Base_lat_lon.txt', index = True, sep=';')

                        nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                    else:
                        submatriz_depots = matriz_distancias.drop(index = df['ID'], columns = df['ID'])

                        base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                        derecha_temporal = pd.DataFrame(index = submatriz_depots.index, columns = df['ID'])
                        for fila in submatriz_depots.index:
                            nodoA = base_lat_lon.loc[fila,'nodo']
                            for col in df['ID']:
                                nodoB = base_lat_lon.loc[col,'nodo']
                                try:
                                    distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                    derecha_temporal.loc[fila,col] = distancia
                                except:
                                    distancia = "NoDisponible"
                                    derecha_temporal.loc[fila,col] = distancia

                        abajo_temporal = pd.DataFrame(index = df['ID'], columns = submatriz_depots.index)
                        for fila in df['ID']:
                            nodoA = base_lat_lon.loc[fila,'nodo']
                            for col in submatriz_depots.index:
                                nodoB = base_lat_lon.loc[col,'nodo']
                                try:
                                    distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                    abajo_temporal.loc[fila,col] = distancia
                                except:
                                    distancia = "NoDisponible"
                                    abajo_temporal.loc[fila,col] = distancia

                        identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                        concat1 = pd.concat([submatriz_depots, abajo_temporal])
                        concat2 = pd.concat([derecha_temporal, identidad_temporal])

                        nueva_matriz = pd.concat([concat1, concat2], axis = 1)

                        ids_NoDisponibles = []
                        for fila in nueva_matriz.index:
                            conteo = 0
                            # Iterar sobre las columnas del DataFrame
                            for col in nueva_matriz.index:
                                if nueva_matriz.loc[fila,col] == "NoDisponible":
                                    conteo += 1
                            if conteo == nueva_matriz.shape[1] -1:
                                ids_NoDisponibles.append(fila)

                        if len(ids_NoDisponibles) > 0:
                            nueva_matriz = nueva_matriz.drop(ids_NoDisponibles, axis = 1)
                            nueva_matriz = nueva_matriz.drop(ids_NoDisponibles)
                            array_str = ', '.join(str(elem) for elem in ids_NoDisponibles)
                            text = f'Los siguientes IDs tienen una direccin fuera de la geografa delimitada: {array_str}'
                            QMessageBox.warning(self, "Warning", text)

                            base_clientes = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
                            base_clientes = base_clientes.drop(ids_NoDisponibles)
                            base_clientes.to_csv('Base_Datos_Clientes.txt', index = True, sep=';')

                            base_lat_lon = pd.read_csv('Base_lat_lon.txt', sep=';', encoding='latin-1')
                            base_lat_lon = base_lat_lon.drop(ids_NoDisponibles)
                            base_lat_lon.to_csv('Base_lat_lon.txt', index = True, sep=';')

                        nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')

                else:
                    nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                    ids_NoDisponibles = []
                    for fila in nueva_matriz.index:
                        conteo = 0
                        # Iterar sobre las columnas del DataFrame
                        for col in nueva_matriz.index:
                            if nueva_matriz.loc[fila,col] == "NoDisponible":
                                conteo += 1
                        if conteo == nueva_matriz.shape[1] -1:
                            ids_NoDisponibles.append(fila)

                    if len(ids_NoDisponibles) > 0:
                        nueva_matriz = nueva_matriz.drop(ids_NoDisponibles, axis = 1)
                        nueva_matriz = nueva_matriz.drop(ids_NoDisponibles)
                        array_str = ', '.join(str(elem) for elem in ids_NoDisponibles)
                        text = f'Los siguientes IDs tienen una direccin fuera de la geografa delimitada: {array_str}'
                        QMessageBox.warning(self, "Warning", text)

                        base_clientes = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
                        base_clientes = base_clientes.drop(ids_NoDisponibles)
                        base_clientes.to_csv('Base_Datos_Clientes.txt', index = True, sep=';')

                        base_lat_lon = pd.read_csv('Base_lat_lon.txt', sep=';', encoding='latin-1')
                        base_lat_lon = base_lat_lon.drop(ids_NoDisponibles)
                        base_lat_lon.to_csv('Base_lat_lon.txt', index = True, sep=';')

                    nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                QMessageBox.information(self, "Information", "Los cambios han sido guardados")
                self.clear_layout_base_clientes()
                time.sleep(0.03)
                self.display_base_clientes()
            except:
                QMessageBox.warning(self, "Warning", 'Alguna direccin modificada no es vlida')
    
    def clear_layout_base_clientes(self):
        n = self.scrollArea_6_layout.rowCount()
        if n >0:
            for i in reversed(range(n)):
                self.scrollArea_6_layout.removeRow(i)
                
    def anadir_cliente_ind_orden(self):
        name = self.lineEdit_7.text()
        direction = self.lineEdit_8.text()
        if name == "" or direction == "":
            QMessageBox.warning(self, "Warning", "Agregue un ID y direccin vlida")
        else:
            self.lineEdit_7.clear()
            self.lineEdit_8.clear()
            geo_punto = self.geolocator.geocode(direction, timeout=180)
            if geo_punto:
                self.display_in_scrollA(name, direction, self.scroll_area_4_layout)
            else:
                QMessageBox.warning(self, "Warning", "La direccin ingresada no existe")
            
    def anadir_cliente_ind_base(self):
        name = self.lineEdit.text()
        direction = self.lineEdit_2.text()
        geo_punto = self.geolocator.geocode(direction, timeout=180)
        
        if name == "" or direction == "":
            QMessageBox.warning(self, "Warning", "Agregue un ID y direccin vlida")
        else:
            if geo_punto:
                try:
                    if os.path.isfile("Base_Datos_Clientes.txt"):
                        base = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')

                        if name in base["ID"].values:
                            text = f'El cliente con el ID: "{name}" ya se encuentra en la base de datos'
                            QMessageBox.warning(self, "Warning", text)
                        else:
                            f = open('Base_Datos_Clientes.txt', "a")
                            f.write("\n"+ name + ";" + direction)
                            f.close()
                            QMessageBox.information(self, "Information", "Aadir un cliente tomar un tiempo ya que se deben recalcular ciertos parmetros.\nPor favor, no oprima ningn botn hasta que el sistema indique que los datos fueron guardados")
                            self.lineEdit.clear()
                            self.lineEdit_2.clear()
                            time.sleep(0.03)
                            
                            data = {"ID": [name], "DIRECCION": [direction]}
                            # Creamos el DataFrame a partir del diccionario
                            df = pd.DataFrame(data)
                            self.base_lat_lon = sacar_lat_lon_clientes(df,self.geolocator,self.G)
                
                            #Escribir en base de lat lon 
                            if os.path.isfile("Base_lat_lon.txt"):
                                with open("Base_lat_lon.txt", mode="a") as f:
                                    self.base_lat_lon.to_csv(f, sep=";", header=False)
                            else:
                                self.base_lat_lon.to_csv("Base_lat_lon.txt", sep=";", index=True)
                                                    
                            if os.path.isfile("matriz_distancias.txt"):
                                matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                                base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                                derecha_temporal = pd.DataFrame(index = matriz_distancias.index, columns = [name])
                                for fila in matriz_distancias.index:
                                    nodoA = base_lat_lon.loc[fila,'nodo']
                                    nodoB = base_lat_lon.loc[name,'nodo']
                                    distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                    derecha_temporal.loc[fila,name] = distancia

                                abajo_temporal = pd.DataFrame(index = [name], columns = matriz_distancias.index)
                                nodoA = base_lat_lon.loc[name,'nodo']
                                for col in matriz_distancias.index:
                                    nodoB = base_lat_lon.loc[col,'nodo']
                                    distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                    abajo_temporal.loc[name,col] = distancia

                                identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                                concat1 = pd.concat([matriz_distancias, abajo_temporal])
                                concat2 = pd.concat([derecha_temporal, identidad_temporal])

                                nueva_matriz = pd.concat([concat1, concat2], axis = 1)
                                nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                                QMessageBox.information(self, "Information", "El/Los clientes han sido agregados a la base de datos")
                            else:
                                nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                                nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')    
                                QMessageBox.information(self, "Information", "El/Los clientes han sido agregados a la base de datos")
                            self.clear_layout_base_clientes()
                            time.sleep(0.05)
                            self.display_base_clientes()
                    else:
                        f = open('Base_Datos_Clientes.txt', "a")
                        f.write("ID;DIRECCION")
                        f.write("\n")
                        f.write(name + ";" + direction)
                        f.close()
                        
                        self.lineEdit.clear()
                        self.lineEdit_2.clear()
                        time.sleep(0.03)
                        
                        data = {"ID": [name], "DIRECCION": [direction]}
                        # Creamos el DataFrame a partir del diccionario
                        df = pd.DataFrame(data)
                        self.base_lat_lon = sacar_lat_lon_clientes(df,self.geolocator,self.G)
                
                        if os.path.isfile("Base_lat_lon.txt"):
                            with open("Base_lat_lon.txt", mode="a") as f:
                                self.base_lat_lon.to_csv(f, sep=";", header=False)
                        else:
                            self.base_lat_lon.to_csv("Base_lat_lon.txt", sep=";", index=True)
                                
                        if os.path.isfile("matriz_distancias.txt"):
                            matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                            base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                            derecha_temporal = pd.DataFrame(index = matriz_distancias.index, columns = [name])
                            for fila in matriz_distancias.index:
                                nodoA = base_lat_lon.loc[fila,'nodo']
                                nodoB = base_lat_lon.loc[name,'nodo']
                                distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                derecha_temporal.loc[fila,name] = distancia

                            abajo_temporal = pd.DataFrame(index = [name], columns = matriz_distancias.index)
                            nodoA = base_lat_lon.loc[name,'nodo']
                            for col in matriz_distancias.index:
                                nodoB = base_lat_lon.loc[col,'nodo']
                                distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                abajo_temporal.loc[name,col] = distancia

                            identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                            concat1 = pd.concat([matriz_distancias, abajo_temporal])
                            concat2 = pd.concat([derecha_temporal, identidad_temporal])

                            nueva_matriz = pd.concat([concat1, concat2], axis = 1)
                            nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                            QMessageBox.information(self, "Information", "El/Los clientes han sido agregados a la base de datos")
                        else:
                            nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                            nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep=";")    
                            QMessageBox.information(self, "Information", "El/Los clientes han sido agregados a la base de datos")
                        self.clear_layout_base_clientes()
                        time.sleep(0.05)
                        self.display_base_clientes()
                except:
                    QMessageBox.warning(self, "Warning", "La direccin ingresada no es vlida dentro de la geografa limitada")
            else:
                QMessageBox.warning(self, "Warning", "La direccin ingresada no existe")
                
    def eliminar_clientes(self):
        if os.path.isfile("Base_Datos_Clientes.txt"):
            reply = QMessageBox.question(self, 'Confirmar Accin', 'Desea eliminar los clientes seleccionados?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.Yes:
                base = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1', index_col = 0)
                items = self.scrollArea_6.findChildren(QWidget)
                data = []
                if items is not None:
                    for item in items:
                        if isinstance(item, QCheckBox) and item.isChecked():
                            name = item.objectName()
                            direction = item.parent().findChild(QLineEdit, name).text()
                            data.append([name, direction])

                    df = pd.DataFrame(data, columns=["ID", "DIRECCION"])


                    if df.shape[0] == base.shape[0]:
                        os.remove('Base_Datos_Clientes.txt')
                    else:
                        mascara = ~base.index.isin(df['ID'])
                        base_filtrada = base[mascara]
                        with open("Base_Datos_Clientes.txt", mode="w") as f:
                            base_filtrada.to_csv(f, sep=";", header=True)

                    if os.path.isfile("matriz_distancias.txt"):
                        try:
                            matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                            sub_matriz = matriz_distancias.drop(index = df['ID'], columns = df['ID'])
                            sub_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                        except:
                            QMessageBox.warning(self, "Warning", "Error Fatal, debe reestablecer el sistema. Dirijase a la ventana de ajustes y oprima el boton reestablecer. Esto eliminar todos los datos guardados ")
                        

                    if os.path.isfile("Base_lat_lon.txt"):
                        try:
                            base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                            mascara = ~base_lat_lon.index.isin(df['ID'])
                            base_filtrada = base_lat_lon[mascara]
                            with open("Base_lat_lon.txt", mode="w") as f:
                                base_filtrada.to_csv(f, sep=";", header=True)
                        except:
                            QMessageBox.warning(self, "Warning", "Error Fatal, debe reestablecer el sistema. Dirijase a la ventana de ajustes y oprima el boton reestablecer. Esto eliminar todos los datos guardados ")
                        

                self.clear_layout_base_clientes()
                time.sleep(0.03)
                self.display_base_clientes()
                QMessageBox.information(self, "Information", "Los clientes han sido eliminados")
        else:
            QMessageBox.information(self, "Information", "No hay registro de clientes en la base de datos")
              
    def seleccionar_todos_clientes_base(self, state):
        widgets = self.scrollArea_6.findChildren(QWidget)
        if widgets:
            for widget in widgets:
                if isinstance(widget, QCheckBox):
                    widget.setCheckState(state)

    def seleccionar_todos_clientes(self, state):
        widgets = self.scrollArea_4.findChildren(QWidget)
        if widgets:
            for widget in widgets:
                if isinstance(widget, QCheckBox):
                    widget.setCheckState(state)

            
            
###############################################################################################################################################################            
############################### TAB DEPOSITOS ################################################################################################################
##################################################################################################################################################################


    def display_in_scroll_depots(self,name, direction, scrollA):
        # layout = QHBoxLayout()

        checkbox = QCheckBox(name, self)
        checkbox.setObjectName(name)
        checkbox.setChecked(True)
        fc = checkbox.font()
        fc.setPointSize(7)
        checkbox.setFont(fc)

        lineedit = QLineEdit(direction)
        lineedit.setObjectName(name)
        f = lineedit.font()
        f.setPointSize(7)
        lineedit.setFont(f)
        
        scrollA.addRow(checkbox, lineedit)    
        
    def carga_masiva_depositos(self):
        # open file dialog to select CSV file
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        fileFilters = "Text Files (*.txt);;All Files (*)"
        self.file_path_depots, _ = QFileDialog.getOpenFileName(self, "Select Excel File", "", fileFilters, options=options)
        try:    
            if self.file_path_depots:
                direcciones_depots = pd.read_csv(self.file_path_depots, sep=';')
                self.checkboxes = []
                comunes = []
                self.label_11.setText("Seleccione el depsito de salida")
                for i in range(direcciones_depots.shape[0]):
                    ID = direcciones_depots.loc[i,"ID"]
                    direccion = direcciones_depots.loc[i,"DIRECCION"]
                    geo_punto = self.geolocator.geocode(direccion, timeout=180)
                    if geo_punto:
                        self.display_in_scroll_depots(ID,direccion,self.scrollArea_5_layout)
                    else:
                        n = i + 1
                        string = ID + ' (Linea ' + str(n) + ')'
                        comunes.append(string)
                        
                if len(comunes) > 0:
                        array_str = ', '.join(str(elem) for elem in comunes)
                        text = f'Los siguientes IDs tienen una direccin invlida: {array_str}'
                        QMessageBox.warning(self, "Warning", text)
            else:
                self.label_10.setText("Cargue un archivo vlido:")
        except:
            QMessageBox.warning(self, "Warning", "Verifique que el archivo cargado cumple con los requisitos")

    def cargar_base_depots(self):
        if os.path.isfile("Base_Datos_Depots.txt"):
            direcciones_depots = pd.read_csv('Base_Datos_Depots.txt', sep=';', encoding='latin-1')
            self.checkboxes_depots = []

            if direcciones_depots.empty == False:
                self.label_11.setText("Seleccione el depsito de salida.")
                for i in range(direcciones_depots.shape[0]):
                    ID = direcciones_depots.loc[i,"ID"]
                    direccion = direcciones_depots.loc[i,"DIRECCION"]
                    self.display_in_scroll_depots(ID,direccion,self.scrollArea_5_layout)  
            else:
                QMessageBox.warning(self, "Warning", "La base de datos est vacia")
            return
        else:
            QMessageBox.warning(self, "Warning", "No existen registros en la base de datos")
        return

    def descargar_template_depots(self):
        # Get the URL of the file to download
        with open('Template Agregar Depsitos.txt', 'w') as f:
            f.write("Para agregar depsitos de forma masiva debe ingresarlos con el siguiente formato en un archivo .txt:")
            f.write('\n')
            f.write('\n')
            f.write("ID;Direccion")
            f.write('\n')
            f.write('\n')
            f.write("Ejemplo:")
            f.write('\n')
            f.write("ID;Direccion")
            f.write('\n')
            f.write("Uniandes;Carrera 1 18A 12, Bogot, Colombia")
            f.write('\n')
            f.write('\n')
            f.write("Nota: Agregue nicamente un depsito por linea. Dejar en la primera linea 'ID;Direccion'")
        QMessageBox.information(self, "Information", "El template fue descargado en la misma carpeta que la aplicacin.")
        
    def crear_dataframe_depots(self):
        items = self.scrollArea_5.findChildren(QWidget)
        data = []
        for item in items:
            if isinstance(item, QCheckBox) and item.isChecked():
                name = item.objectName()
                direction = item.parent().findChild(QLineEdit, name).text()
                data.append([name, direction])

        df = pd.DataFrame(data, columns=["ID", "DIRECCION"])
        return(df)
           
    def escribir_sobre_base_depots(self):
        QMessageBox.information(self, "Information", "A continuacin almacenar los depsitos a la base de datos y guardar sus atributos, esto tomar un poco de tiempo.\nPor favor, no oprima ningn botn hasta que el sistema indique que los depsitos fueron agregados a la base ")
        df = self.crear_dataframe_depots()
        self.base_lat_lon = sacar_lat_lon_clientes(df,self.geolocator,self.G)
        if df.empty == False:
            if os.path.isfile("Base_Datos_Depots.txt"):
                base = pd.read_csv('Base_Datos_Depots.txt', sep=';', encoding='latin-1')
                common_elements = base[base['ID'].isin(df['ID'])]['ID']
                if common_elements.empty == False:
                    array_str = ', '.join(str(elem) for elem in common_elements)
                    text = f'Los siguientes IDs ya se encuentran en la base de datos: {array_str}'
                    QMessageBox.warning(self, "Warning", text)
                else:
                    f = open('Base_Datos_Depots.txt', "a")
                    f.write("\n")
                    for index, row in df.iterrows():
                        f.write(row["ID"] + ";" + row["DIRECCION"] + "\n")
                    f.close()

                    #Escribir en base de lat lon 
                    if os.path.isfile("Base_lat_lon.txt"):
                        with open("Base_lat_lon.txt", mode="a") as f:
                            self.base_lat_lon.to_csv(f, sep=";", header=False)
                    else:
                        self.base_lat_lon.to_csv("Base_lat_lon.txt", sep=";", index=True)
                    
                    if os.path.isfile("matriz_distancias.txt"):
                        matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                        base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                        derecha_temporal = pd.DataFrame(index = matriz_distancias.index, columns = df['ID'])
                        for fila in matriz_distancias.index:
                            nodoA = base_lat_lon.loc[fila,'nodo']
                            for col in df['ID']:
                                nodoB = base_lat_lon.loc[col,'nodo']
                                distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                derecha_temporal.loc[fila,col] = distancia

                        abajo_temporal = pd.DataFrame(index = df['ID'], columns = matriz_distancias.index)
                        for fila in df['ID']:
                            nodoA = base_lat_lon.loc[fila,'nodo']
                            for col in matriz_distancias.index:
                                nodoB = base_lat_lon.loc[col,'nodo']
                                distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                abajo_temporal.loc[fila,col] = distancia

                        identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                        concat1 = pd.concat([matriz_distancias, abajo_temporal])
                        concat2 = pd.concat([derecha_temporal, identidad_temporal])

                        nueva_matriz = pd.concat([concat1, concat2], axis = 1)
                        nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                        QMessageBox.information(self, "Information", "El/Los depsitos han sido agregados a la base de datos")
                    else:
                        nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                        nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')   
                        QMessageBox.information(self, "Information", "El/Los depsitos han sido agregados a la base de datos") 
                    self.clear_layout_depots()
                    self.clear_layout_base_depots()
                    time.sleep(0.02)
                    self.display_base_depots()
            else:
                f = open('Base_Datos_Depots.txt', "a")
                f.write("ID;DIRECCION")
                f.write("\n")
                for index, row in df.iterrows():
                    f.write(row["ID"] + ";" + row["DIRECCION"] + "\n")
                f.close()
                
                if os.path.isfile("Base_lat_lon.txt"):
                    with open("Base_lat_lon.txt", mode="a") as f:
                        self.base_lat_lon.to_csv(f, sep=";", header=False)
                else:
                    self.base_lat_lon.to_csv("Base_lat_lon.txt", sep=";", index=True)
                
                if os.path.isfile("matriz_distancias.txt"):
                    matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                    base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                    derecha_temporal = pd.DataFrame(index = matriz_distancias.index, columns = df['ID'])
                    for fila in matriz_distancias.index:
                        nodoA = base_lat_lon.loc[fila,'nodo']
                        for col in df['ID']:
                            nodoB = base_lat_lon.loc[col,'nodo']
                            distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                            derecha_temporal.loc[fila,col] = distancia

                    abajo_temporal = pd.DataFrame(index = df['ID'], columns = matriz_distancias.index)
                    for fila in df['ID']:
                        nodoA = base_lat_lon.loc[fila,'nodo']
                        for col in matriz_distancias.index:
                            nodoB = base_lat_lon.loc[col,'nodo']
                            distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                            abajo_temporal.loc[fila,col] = distancia

                    identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                    concat1 = pd.concat([matriz_distancias, abajo_temporal])
                    concat2 = pd.concat([derecha_temporal, identidad_temporal])

                    nueva_matriz = pd.concat([concat1, concat2], axis = 1)
                    nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')

                    QMessageBox.information(self, "Information", "El/Los depsitos han sido agregados a la base de datos")
                else:
                    nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                    nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')                  
                    QMessageBox.information(self, "Information", "El/Los depsitos han sido agregados a la base de datos")
                self.clear_layout_depots()
                self.clear_layout_base_depots()
                time.sleep(0.02)
                self.display_base_depots()
        else:
            QMessageBox.warning(self, "Warning", "Debe selccionar algun depsito para ser aadido a la base de datos")
            
    def clear_layout_depots(self):
        n = self.scrollArea_5_layout.rowCount()
        if n >0:
            for i in reversed(range(n)):
                self.scrollArea_5_layout.removeRow(i)
        self.map_depots = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
        # Convert Folium map to HTML and display in web view
        self.html_depots = self.map_depots._repr_html_()
        self.web_view_depots.setHtml(self.html_depots)
                
    def display_base_depots(self):
        if os.path.isfile("Base_Datos_Depots.txt"):
            base = pd.read_csv('Base_Datos_Depots.txt', sep=';', encoding='latin-1')
            self.checkboxes_base_depots = []

            if base.empty == False:
                self.label_19.setText("Los depsitos en la base son:")
                for i in range(base.shape[0]):
                    ID = base.loc[i,"ID"]
                    direccion = base.loc[i,"DIRECCION"]
                    self.display_in_scrollA(ID,direccion,self.scrollArea_7_layout)  
            else:
                QMessageBox.warning(self, "Warning", "La base de datos est vacia")
            return
        else:
            QMessageBox.warning(self, "Warning", "No existen registros de depsitos en la base de datos")
        return

    def guardar_cambios_depots(self):
        QMessageBox.information(self, "Information", "A continuacin guardar los cambios y actualizar la base de datos, esto puede tomar un poco de tiempo. \nPor favor, no oprima ningn botn hasta que el sistema indique que los datos fueron guardados")
        items = self.scrollArea_7.findChildren(QWidget)
        data = []
        if items is not None:
            for item in items:
                if isinstance(item, QCheckBox):
                    name = item.objectName()
                    direction = item.parent().findChild(QLineEdit, name).text()
                    data.append([name, direction])

            df = pd.DataFrame(data, columns=["ID", "DIRECCION"])
            f = open('Base_Datos_Depots.txt', "w")
            f.write("ID;DIRECCION")
            f.write("\n")
            for index, row in df.iterrows():
                f.write(row["ID"] + ";" + row["DIRECCION"] + "\n")
            f.close()
    
            try:
                self.base_lat_lon = sacar_lat_lon_clientes(df,self.geolocator,self.G)
                #Escribir en base de lat lon 
                if os.path.isfile("Base_lat_lon.txt"):
                    base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                    mascara = ~base_lat_lon.index.isin(df['ID'])
                    base_filtrada = base_lat_lon[mascara]
                    nueva_base = pd.concat([base_filtrada, self.base_lat_lon])
                    nueva_base.to_csv("Base_lat_lon.txt", sep=";", index=True)

                if os.path.isfile("matriz_distancias.txt"):
                    matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                    submatriz_depots = matriz_distancias.drop(index = df['ID'], columns = df['ID'])

                    base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                    derecha_temporal = pd.DataFrame(index = submatriz_depots.index, columns = df['ID'])
                    for fila in submatriz_depots.index:
                        nodoA = base_lat_lon.loc[fila,'nodo']
                        for col in df['ID']:
                            nodoB = base_lat_lon.loc[col,'nodo']
                            distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                            derecha_temporal.loc[fila,col] = distancia

                    abajo_temporal = pd.DataFrame(index = df['ID'], columns = submatriz_depots.index)
                    for fila in df['ID']:
                        nodoA = base_lat_lon.loc[fila,'nodo']
                        for col in submatriz_depots.index:
                            nodoB = base_lat_lon.loc[col,'nodo']
                            distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                            abajo_temporal.loc[fila,col] = distancia

                    identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                    concat1 = pd.concat([submatriz_depots, abajo_temporal])
                    concat2 = pd.concat([derecha_temporal, identidad_temporal])

                    nueva_matriz = pd.concat([concat1, concat2], axis = 1)
                    nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                else:
                    nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                    nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                QMessageBox.information(self, "Information", "Los cambios han sido guardados")
                self.clear_layout_base_clientes()
                time.sleep(0.03)
                self.display_base_clientes()
            except:
                QMessageBox.warning(self, "Warning", 'Alguna direccin modificada no es vlida')   
    
    def clear_layout_base_depots(self):
        n = self.scrollArea_7_layout.rowCount()
        if n >0:
            for i in reversed(range(n)):
                self.scrollArea_7_layout.removeRow(i)
    
    def eliminar_depots(self):
        if os.path.isfile("Base_Datos_Depots.txt"):
            reply = QMessageBox.question(self, 'Confirmar Accin', 'Desea eliminar el/los depsitos seleccionados?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.Yes:
                base = pd.read_csv('Base_Datos_Depots.txt', sep=';', encoding='latin-1', index_col = 0)
                items = self.scrollArea_7.findChildren(QWidget)
                data = []
                if items is not None:
                    for item in items:
                        if isinstance(item, QCheckBox) and item.isChecked():
                            name = item.objectName()
                            direction = item.parent().findChild(QLineEdit, name).text()
                            data.append([name, direction])

                    df = pd.DataFrame(data, columns=["ID", "DIRECCION"])

                    mascara = ~base.index.isin(df['ID'])
                    base_filtrada = base[mascara]
                    with open("Base_Datos_Depots.txt", mode="w") as f:
                        base_filtrada.to_csv(f, sep=";", header=True)

                    if os.path.isfile("matriz_distancias.txt"):
                        matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                        sub_matriz = matriz_distancias.drop(index = df['ID'], columns = df['ID'])
                        sub_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                        

                    if os.path.isfile("Base_lat_lon.txt"):
                        base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                        mascara = ~base_lat_lon.index.isin(df['ID'])
                        base_filtrada = base_lat_lon[mascara]
                        with open("Base_lat_lon.txt", mode="w") as f:
                            base_filtrada.to_csv(f, sep=";", header=True)

                    self.clear_layout_base_depots()
                    time.sleep(0.03)
                    self.display_base_depots()
                    QMessageBox.information(self, "Information", "Los depsitos han sido eliminados")
        else:
            QMessageBox.information(self, "Information", "No hay registro de depsitos en la base de datos")
            
    def anadir_depot_ind_orden(self):
        name = self.lineEdit_11.text()
        direction = self.lineEdit_12.text()
        if name == "" or direction == "":
            QMessageBox.warning(self, "Warning", "Agregue un ID y direccin vlida")
        else:
            self.lineEdit_11.clear()
            self.lineEdit_12.clear()
            geo_punto = self.geolocator.geocode(direction, timeout=180)
            if geo_punto:
                self.display_in_scrollA(name, direction, self.scrollArea_5_layout)
                time.sleep(0.01)
                df_temp = self.crear_dataframe_depots()
                df = sacar_lat_lon_clientes(df_temp,self.geolocator,self.G)
                index_list = df.index.values.tolist()
                m_temp = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
                for i in range(0,df.shape[0]):
                    folium.Marker(location=[df.iloc[i]['lat'], df.iloc[i]['lon']], popup=index_list[i]).add_to(m_temp)
                self.html_depots = m_temp._repr_html_()
                self.web_view_depots.setHtml(self.html_depots)
            else:
                QMessageBox.warning(self, "Warning", "La direccin ingresada no existe")

    def anadir_depot_ind_base(self):
        QMessageBox.information(self, "Information", "Aadir un depsito podr tomar un tiempo ya que se deben recalcular ciertos parmetros.\nPor favor, no oprima ningn botn hasta que el sistema indique que los datos fueron guardados")
        name = self.lineEdit_3.text()
        direction = self.lineEdit_4.text()
        geo_punto = self.geolocator.geocode(direction, timeout=180)
        if name == "" or direction == "":
            QMessageBox.warning(self, "Warning", "Agregue un ID y direccin vlida")
        else:
            if geo_punto:
                if os.path.isfile("Base_Datos_Depots.txt"):
                    base = pd.read_csv('Base_Datos_Depots.txt', sep=';', encoding='latin-1')

                    if name in base["ID"].values:
                        text = f'El depsito con el ID: "{name}" ya se encuentra en la base de datos'
                        QMessageBox.warning(self, "Warning", text)
                    else:
                        f = open('Base_Datos_Depots.txt', "a")
                        f.write("\n"+ name + ";" + direction)
                        f.close()
                        self.lineEdit_3.clear()
                        self.lineEdit_4.clear()
                        time.sleep(0.03)
                        
                        data = {"ID": [name], "DIRECCION": [direction]}
                        # Creamos el DataFrame a partir del diccionario
                        df = pd.DataFrame(data)
                        self.base_lat_lon = sacar_lat_lon_clientes(df,self.geolocator,self.G)

                        #Escribir en base de lat lon 
                        if os.path.isfile("Base_lat_lon.txt"):
                            with open("Base_lat_lon.txt", mode="a") as f:
                                self.base_lat_lon.to_csv(f, sep=";", header=False)
                        else:
                            self.base_lat_lon.to_csv("Base_lat_lon.txt", sep=";", index=True)
                        
                        if os.path.isfile("matriz_distancias.txt"):
                            matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                            base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                            derecha_temporal = pd.DataFrame(index = matriz_distancias.index, columns = [name])
                            for fila in matriz_distancias.index:
                                nodoA = base_lat_lon.loc[fila,'nodo']
                                nodoB = base_lat_lon.loc[name,'nodo']
                                distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                derecha_temporal.loc[fila,name] = distancia

                            abajo_temporal = pd.DataFrame(index = [name], columns = matriz_distancias.index)
                            nodoA = base_lat_lon.loc[name,'nodo']
                            for col in matriz_distancias.index:
                                nodoB = base_lat_lon.loc[col,'nodo']
                                distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                abajo_temporal.loc[name,col] = distancia

                            identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                            concat1 = pd.concat([matriz_distancias, abajo_temporal])
                            concat2 = pd.concat([derecha_temporal, identidad_temporal])

                            nueva_matriz = pd.concat([concat1, concat2], axis = 1)
                            nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                            QMessageBox.information(self, "Information", "El depsito han sido agregado a la base de datos")
                        else:
                            nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                            nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')    
                            QMessageBox.information(self, "Information", "El depsito han sido agregado a la base de datos")
                        self.clear_layout_base_depots()
                        time.sleep(0.03)
                        self.display_base_depots()
                else:
                    f = open('Base_Datos_Depots.txt', "a")
                    f.write("ID;DIRECCION")
                    f.write("\n")
                    f.write(name + ";" + direction)
                    f.close()
                    
                    self.lineEdit_3.clear()
                    self.lineEdit_4.clear()
                    time.sleep(0.03)
                    
                    data = {"ID": [name], "DIRECCION": [direction]}
                    # Creamos el DataFrame a partir del diccionario
                    df = pd.DataFrame(data)
                    self.base_lat_lon = sacar_lat_lon_clientes(df,self.geolocator,self.G)

                    if os.path.isfile("Base_lat_lon.txt"):
                        with open("Base_lat_lon.txt", mode="a") as f:
                            self.base_lat_lon.to_csv(f, sep=";", header=False)
                    else:
                        self.base_lat_lon.to_csv("Base_lat_lon.txt", sep=";", index=True)
                    
                    if os.path.isfile("matriz_distancias.txt"):
                        matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                        base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                        derecha_temporal = pd.DataFrame(index = matriz_distancias.index, columns = [name])
                        for fila in matriz_distancias.index:
                            nodoA = base_lat_lon.loc[fila,'nodo']
                            nodoB = base_lat_lon.loc[name,'nodo']
                            distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                            derecha_temporal.loc[fila,name] = distancia

                        abajo_temporal = pd.DataFrame(index = [name], columns = matriz_distancias.index)
                        nodoA = base_lat_lon.loc[name,'nodo']
                        for col in matriz_distancias.index:
                            nodoB = base_lat_lon.loc[col,'nodo']
                            distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                            abajo_temporal.loc[name,col] = distancia

                        identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                        concat1 = pd.concat([matriz_distancias, abajo_temporal])
                        concat2 = pd.concat([derecha_temporal, identidad_temporal])

                        nueva_matriz = pd.concat([concat1, concat2], axis = 1)
                        nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                        QMessageBox.information(self, "Information", "El depsito han sido agregado a la base de datos")
                    else:
                        nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                        nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')    
                        QMessageBox.information(self, "Information", "El depsito han sido agregado a la base de datos")
                    self.clear_layout_base_depots()
                    time.sleep(0.03)
                    self.display_base_depots()
            else:
                QMessageBox.warning(self, "Warning", "La direccin ingresada no existe") 
    
    def extraer_deposito_corrida(self):
        self.data_deposito = self.crear_dataframe_depots()
        if self.data_deposito.empty:
            QMessageBox.warning(self, "Warning", "Debe seleccionar un depsito para el ruteo.")
        elif self.data_deposito.shape[0] > 1:
            QMessageBox.warning(self, "Warning", "Debe seleccionar NICAMENTE un depsito para el ruteo.")
        else:             
            
            if os.path.isfile("Base_lat_lon.txt"):
                try:
                    base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep = ";", index_col = 0, encoding='latin-1')
                    self.df_lat_lon_depots = base_lat_lon.loc[self.data_deposito["ID"]]
                    index_list = self.df_lat_lon_depots.index.values.tolist()
                    m_temp = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=10)
                    for i in range(0,self.df_lat_lon_depots.shape[0]):
                        folium.Marker(location=[self.df_lat_lon_depots.iloc[i]['lat'], self.df_lat_lon_depots.iloc[i]['lon']], popup=index_list[i]).add_to(m_temp)
                    self.html_depots = m_temp._repr_html_()
                    self.web_view_depots.setHtml(self.html_depots)
                except:
                    self.df_lat_lon_depots = sacar_lat_lon_clientes(self.data_deposito,self.geolocator,self.G)
                    index_list = self.df_lat_lon_depots.index.values.tolist()
                    m_temp = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=10)
                    for i in range(0,self.df_lat_lon_depots.shape[0]):
                        folium.Marker(location=[self.df_lat_lon_depots.iloc[i]['lat'], self.df_lat_lon_depots.iloc[i]['lon']], popup=index_list[i]).add_to(m_temp)
                    self.html_depots = m_temp._repr_html_()
                    self.web_view_depots.setHtml(self.html_depots)
            else:

                self.df_lat_lon_depots = sacar_lat_lon_clientes(self.data_deposito,self.geolocator,self.G)
                index_list = self.df_lat_lon_depots.index.values.tolist()
                m_temp = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=10)
                for i in range(0,self.df_lat_lon_depots.shape[0]):
                    folium.Marker(location=[self.df_lat_lon_depots.iloc[i]['lat'], self.df_lat_lon_depots.iloc[i]['lon']], popup=index_list[i]).add_to(m_temp)
                self.html_depots = m_temp._repr_html_()
                self.web_view_depots.setHtml(self.html_depots)

            QMessageBox.information(self, "Information", "El depsito ha sido guardado, puede continuar.") 
  


    def seleccionar_todos_depots(self, state):
        widgets = self.scrollArea_5.findChildren(QWidget)
        if widgets:
            for widget in widgets:
                if isinstance(widget, QCheckBox):
                    widget.setCheckState(state)

    def seleccionar_todos_depots_base(self, state):
        widgets = self.scrollArea_7.findChildren(QWidget)
        if widgets:
            for widget in widgets:
                if isinstance(widget, QCheckBox):
                    widget.setCheckState(state)    

    def clear_layout_resultado(self):
            n = self.ScrollArea_layout.rowCount()
            if n >0:
                for i in reversed(range(n)):
                    self.ScrollArea_layout.removeRow(i)

    def display_resultado(self,name, direction, scrollA):
        # layout = QHBoxLayout()

        label_id = QLabel(name, self)
        #checkbox.setObjectName(name)
        #checkbox.setChecked(True)
        fc = label_id.font()
        fc.setPointSize(11)
        label_id.setFont(fc)

        direccion = QLabel(direction)
        direccion.setObjectName(name)
        f = direccion.font()
        f.setPointSize(11)
        direccion.setFont(f)
        
        scrollA.addRow(label_id, direccion) 
    
    def cambiar_ubicacion(self):
        self.graph_area = self.lineEdit_5.text()
        try:
            self.G = ox.graph_from_place(self.graph_area, network_type='drive', simplify=True)
            # OSM data are sometime incomplete so we use the speed module of osmnx to add missing edge speeds and travel times
            self.G = ox.add_edge_speeds(self.G)
            self.G = ox.add_edge_travel_times(self.G)  
            QMessageBox.information(self, "Information", "La ciudad fue cambiada con xito")
            self.lineEdit_5.clear()
        except:
            QMessageBox.warning(self, "Warning", "La ciudad ingresada no puede ser cargada, intente nuevamente")
            self.lineEdit_5.clear()

###############################################################################################################################################################            
############################### RESTRICCIONES ################################################################################################################
##################################################################################################################################################################

    def crear_dataframe_cargas(self):
        items = self.scrollArea_9.findChildren(QWidget)
        data = []
        for item in items:
            if isinstance(item, QCheckBox) and item.isChecked():
                name = item.objectName()
                carga = item.parent().findChild(QSpinBox, name).value()
                data.append([name, carga])

        df = pd.DataFrame(data, columns=["ID", "CARGA"])
        return(df)

    def extraer_df_cargas(self):
        self.data_cargas = self.crear_dataframe_cargas()
        QMessageBox.warning(self, "Information", "Las demandas han sido guardadas, puede continuar")
        
    def clear_layout_carga(self):
        n = self.scrollArea_9_layout.rowCount()
        if n >0:
            for i in reversed(range(n)):
                self.scrollArea_9_layout.removeRow(i)

    def clear_layout_tiempos(self):
        for i in reversed(range(self.scrollArea_10_layout.count())):
            item = self.scrollArea_10_layout.itemAt(i)
            if item is not None:
                widget = item.widget()
                self.scrollArea_10_layout.removeWidget(widget)
                widget.deleteLater()
        time.sleep(0.5)

    def display_in_scroll_cargas(self,name, scrollA):
        # layout = QHBoxLayout()
        checkbox = QCheckBox(name, self)
        checkbox.setObjectName(name)
        checkbox.setChecked(True)
        checkbox.setEnabled(False)
        fc = checkbox.font()
        fc.setPointSize(7)
        checkbox.setFont(fc)

        spin_carga = QSpinBox()
        spin_carga.setRange(0,999999999)
        spin_carga.setObjectName(name)
        f = spin_carga.font()
        f.setPointSize(7)
        spin_carga.setFont(f)
        
        scrollA.addRow(checkbox, spin_carga)

    def crear_dataframe_tiempos(self):
        items = self.scrollArea_10.findChildren(QWidget)
        data = []
        for item in items:
            if isinstance(item, QCheckBox) and item.isChecked():
                name = item.objectName()
                nombre_inicio = name + "_inicio"
                nombre_fin = name + "_fin"
                tiempo_inicio = item.parent().findChild(QTimeEdit, nombre_inicio).time()
                tiempo_inicio_str = tiempo_inicio.toString()
                tiempo_fin = item.parent().findChild(QTimeEdit, nombre_fin).time()
                tiempo_fin_str = tiempo_fin.toString()

                data.append([name, tiempo_inicio_str, tiempo_fin_str])

        df = pd.DataFrame(data, columns=["ID", "HORA_INICIO", "HORA_FIN"])
        self.data_tiempos = df
        print(self.data_tiempos)
        QMessageBox.warning(self, "Information", "Las ventanas de tiempo han sido guardadas, puede continuar")
        

###############################################################################################################################################################            
###############################  VEHICULOS ################################################################################################################
##################################################################################################################################################################
    
    def display_in_scroll_spinbox_vehiculos(self, name, capacidad, scrollA):
        checkbox = QCheckBox(name, self)
        checkbox.setObjectName(name)
        checkbox.setChecked(True)
        fc = checkbox.font()
        fc.setPointSize(7)
        checkbox.setFont(fc)

        spin_carga = QSpinBox()
        spin_carga.setRange(0,999999999)
        spin_carga.setObjectName(name)
        spin_carga.setValue(capacidad)
        f = spin_carga.font()
        f.setPointSize(7)
        spin_carga.setFont(f)
        
        scrollA.addRow(checkbox, spin_carga)

    def display_in_scroll_spinbox(self, name, capacidad, scrollA):
        checkbox = QCheckBox(name, self)
        checkbox.setObjectName(name)
        checkbox.setChecked(True)
        checkbox.setEnabled(False)
        fc = checkbox.font()
        fc.setPointSize(7)
        checkbox.setFont(fc)

        spin_carga = QSpinBox()
        spin_carga.setRange(0,999999999)
        spin_carga.setObjectName(name)
        spin_carga.setValue(capacidad)
        f = spin_carga.font()
        f.setPointSize(7)
        spin_carga.setFont(f)
        
        scrollA.addRow(checkbox, spin_carga)

    def agregar_vehiculo(self):
        name = self.lineEdit_13.text()
        capacidad = self.spinBox.value()
        if os.path.isfile("Base_Datos_vehiculos.txt"):
            base = pd.read_csv('Base_Datos_vehiculos.txt', sep=';', encoding='latin-1')
            if base.empty == True:
                f = open('Base_Datos_vehiculos.txt', "a")
                f.write("ID;CAPACIDAD")
                f.write("\n")
                f.write(name + ";" + str(capacidad))
                f.close()
                self.lineEdit_13.clear()
                self.spinBox.setValue(0)
                self.display_in_scroll_spinbox_vehiculos(name, capacidad, self.scrollArea_8_layout)
            else:
                if name in base["ID"].values:
                    text = f'El vehculo con el ID: "{name}" ya se encuentra en la base de datos'
                    QMessageBox.warning(self, "Warning", text)
                else:
                    f = open('Base_Datos_vehiculos.txt', "a")
                    f.write("\n"+ name + ";" + str(capacidad))
                    f.close()
                    self.lineEdit_13.clear()
                    self.spinBox.setValue(0)
                    self.display_in_scroll_spinbox_vehiculos(name, capacidad, self.scrollArea_8_layout)
        else:
            f = open('Base_Datos_vehiculos.txt', "a")
            f.write("ID;CAPACIDAD")
            f.write("\n")
            f.write(name + ";" + str(capacidad))
            f.close()
            self.lineEdit_13.clear()
            self.spinBox.setValue(0)
            self.display_in_scroll_spinbox_vehiculos(name, capacidad, self.scrollArea_8_layout)

    def clear_vehiculos(self):
        n = self.scrollArea_8_layout.rowCount()
        if n >0:
            for i in reversed(range(n)):
                self.scrollArea_8_layout.removeRow(i)

    def eliminar_vehiculos(self):
        if os.path.isfile("Base_Datos_vehiculos.txt"):
            reply = QMessageBox.question(self, 'Confirmar Accin', 'Desea eliminar el/los vehculos seleccionados?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.Yes:
                base = pd.read_csv('Base_Datos_vehiculos.txt', sep=';', encoding='latin-1', index_col = 0)
                items = self.scrollArea_8.findChildren(QWidget)
                data = []
                if items is not None:
                    for item in items:
                        if isinstance(item, QCheckBox) and item.isChecked():
                            name = item.objectName()
                            capacidad = item.parent().findChild(QSpinBox, name).value()
                            data.append([name, capacidad])

                    df = pd.DataFrame(data, columns=["ID", "CAPACIDAD"])

                    mascara = ~base.index.isin(df['ID'])
                    base_filtrada = base[mascara]
                    with open("Base_Datos_vehiculos.txt", mode="w") as f:
                        base_filtrada.to_csv(f, sep=";", header=True)

                    self.clear_vehiculos()
                    time.sleep(0.02)
                    self.display_base_vehiculos()

    def display_base_vehiculos(self):
        if os.path.isfile("Base_Datos_vehiculos.txt"):
            base = pd.read_csv('Base_Datos_vehiculos.txt', sep=';', encoding='latin-1')
            self.checkboxes_base_depots = []

            if base.empty == False:
                for i in range(base.shape[0]):
                    ID = base.loc[i,"ID"]
                    capacidad = base.loc[i,"CAPACIDAD"]
                    self.display_in_scroll_spinbox_vehiculos(ID,capacidad,self.scrollArea_8_layout)  
            else:
                QMessageBox.warning(self, "Warning", "La base de datos est vacia")
            return
        else:
            QMessageBox.warning(self, "Warning", "No existen registros de depsitos en la base de datos")
        return

    def guardar_cambios_vehiculos(self):
        items = self.scrollArea_8.findChildren(QWidget)
        data = []
        if items is not None:
            for item in items:
                if isinstance(item, QCheckBox):
                    name = item.objectName()
                    direction = item.parent().findChild(QSpinBox, name).value()
                    data.append([name, direction])

            df = pd.DataFrame(data, columns=["ID", "CAPACIDAD"])
            df.to_csv('Base_Datos_vehiculos.txt', index = False, sep = ';')
            self.clear_vehiculos()
            time.sleep(0.02)
            self.display_base_vehiculos()
            QMessageBox.warning(self, "Information", 'Los cambios fueron guardados')

    def crear_dataframe_vehiculo(self):
        items = self.scrollArea_8.findChildren(QWidget)
        data = []
        for item in items:
            if isinstance(item, QCheckBox) and item.isChecked():
                name = item.objectName()
                capacidad = item.parent().findChild(QSpinBox, name).value()
                data.append([name, capacidad])

        df = pd.DataFrame(data, columns=["ID", "CAPACIDAD"])
        return(df)

    def extraer_capacidad_vehiculo(self):
        df = self.crear_dataframe_vehiculo()
        if df.empty:
            QMessageBox.warning(self, "Warning", "Debe seleccionar un vehculo para el ruteo")
        elif df.shape[0] > 1:
            QMessageBox.warning(self, "Warning", "Debe seleccionar NICAMENTE un vehculo para el ruteo")
        else:             
            QMessageBox.information(self, "Information", "El vehculo ha sido guardado, puede continuar a la pestaa de ruteo.")
            self.data_vehiculo = df
            self.capacidad_vehiculo = df.loc[0, "CAPACIDAD"]

    def seleccionar_todos_vehiculos(self, state):
        widgets = self.scrollArea_8.findChildren(QWidget)
        if widgets:
            for widget in widgets:
                if isinstance(widget, QCheckBox):
                    widget.setCheckState(state)

    def hacer_sub_caminos(self, camino):
        ###### OJO: Si el camino retorna a depsito, se debe omitir el ultimo elemento de las sublistas porque esta vacio. Si no retorna, tomar completo
        lista = camino
        sublistas = []
        sublista_actual = []

        for elemento in lista:
            if elemento == 0:
                if sublista_actual:
                    sublista_actual.append(0)
                    sublistas.append(sublista_actual)
                    sublista_actual = [0]
                else:
                    sublista_actual.append(0)
            else:
                sublista_actual.append(elemento)

        if sublista_actual:
            sublista_actual.append(0)
            sublistas.append(sublista_actual)

        return(sublistas)

    def anadir_elementos_comboBox(self,n):
        self.comboBox.clear()
        self.comboBox.addItem("Ruta completa")
        if n > 1:
            for i in range(1,n+1):
                ruta = f"Ruta {i}"
                self.comboBox.addItem(ruta)

    def actualizar_resultado(self,index):
        opcion_actual = self.comboBox.currentText()

        if opcion_actual == "":
            QMessageBox.information(self, "information", "Debe correr un modelo")
        elif opcion_actual == "Ruta completa":
            self.clear_layout_resultado()
            self.map = self.mapa_completo
            self.html = self.map._repr_html_()
            self.web_view.setHtml(self.html)
            for i in self.camino_entero:
                self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

            #self.distancia_total = acumular_distancia(self.subset_matriz_dist,self.secuencia_completa)
            self.label_53.setText(str(round(self.distancia_total,2)))
            self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
            self.label_57.setText(str(round(self.distancia_total/1000,2)))
            self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))

        else:
            self.clear_layout_resultado()
            indice_espacio = opcion_actual.find(" ")
            subcadena = opcion_actual[indice_espacio + 1:]
            indice = int(subcadena) - 1
            camino_temporal = self.camino_sublistas[indice]
            secuencia = self.data_completa.loc[camino_temporal, 'ID']
            direcciones = self.data_completa.loc[camino_temporal, 'DIRECCION']
            rutas_pegadas = ruta_nodos(camino_temporal,self.subset_lat_lon,self.G)
            mapa = mapa_ruta_auxiliar(rutas_pegadas, self.subset_lat_lon, self.G, secuencia)
            self.map = mapa
            self.html = self.map._repr_html_()
            self.web_view.setHtml(self.html)
            for i in camino_temporal:
                self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

            distancia = acumular_distancia(self.subset_matriz_dist,secuencia)
            self.label_53.setText(str(round(distancia,2)))
            self.label_55.setText(str(round(distancia/self.vel_promedio,2)))
            self.label_57.setText(str(round(distancia/1000,2)))
            self.label_59.setText(str(round((distancia/self.vel_promedio)/60,2)))

    def abrir_opciones_correr(self):
        dialog = CustomDialog2()
        if dialog.exec_() == QDialog.Accepted:
            radioB_1 = dialog.radioButton_heuris_nn
            radioB_2 = dialog.radioButton_2
            radioB_3 = dialog.radioButton_3

            #Checkbuox para usar demandas/ventanas de tiempo y retorno a deposito al finalizar
            check_demandas = dialog.checkBox_demandas
            check_time_win = dialog.checkBox_vent_tiempo
            check_no_retorna = dialog.checkBox_regreso

            if self.data_clientes.empty or self.data_deposito.empty:
                QMessageBox.warning(self, "Warning", "Debe seleccionar y guardar al menos un cliente y un depsito para el ruteo")
            else:
                self.distancia_total = 0
                self.clear_layout_resultado()
                self.comboBox.clear()
                time.sleep(0.04)
                if radioB_1.isChecked():
                    if check_time_win.isChecked():
                        QMessageBox.warning(self, "Warning", "Opciones an no disponibles.")

                    #Correr con demandas
                    elif  check_demandas.isChecked() == True:
                        if self.data_cargas.empty or self.capacidad_vehiculo == 99999999999999999999:
                            QMessageBox.warning(self, "Warning", "No se han guardado demandas o vehculo, por favor revise e intente nuevamente")
                        else:
                            df_cargas1 = self.data_cargas
                            df_cargas = df_cargas1.drop("ID", axis = 1)
                            clientes_con_cargas = pd.concat([self.data_clientes, df_cargas], axis = 1)
                            df_depot_aux = self.data_deposito
                            df_depot_aux["CARGA"] = 0

                            frames = [df_depot_aux, clientes_con_cargas]
                            self.data_completa = pd.concat(frames, ignore_index = True)
                            self.label_27.setText('Seleccione la ruta a mostrar:')

                            try:
                                matriz_distancias  = pd.read_csv("matriz_distancias.txt", sep=";", index_col = 0)
                                self.subset_matriz_dist = matriz_distancias.loc[self.data_completa["ID"],self.data_completa["ID"]]
                                base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep = ";", index_col = 0, encoding='latin-1')
                                self.subset_lat_lon = base_lat_lon.loc[self.data_completa["ID"]]

                                if check_no_retorna.isChecked():
                                    vuelve = "No"
                                    camino = heuristica_nn_carga(self.subset_matriz_dist, self.data_completa, capacidad = self.capacidad_vehiculo)
                                    print(camino)
                                    if camino == 'Infactible':
                                        QMessageBox.warning(self, "Warning", "El problema es infactible, alguna de las demandas es mayor a la capacidad del vehculo")
                                    else:
                                        camino_sin_ultimo = camino[:-1]
                                        secuencia = self.data_completa.loc[camino_sin_ultimo, 'ID']
                                        direcciones = self.data_completa.loc[camino_sin_ultimo, 'DIRECCION']
                                        completo = secuencia + ": " + direcciones

                                        rutas_pegadas = ruta_nodos(camino_sin_ultimo,self.subset_lat_lon,self.G)

                                        mapa = mapa_ruta(rutas_pegadas,self.subset_lat_lon,self.G,secuencia, vuelve)
                                        self.mapa_completo = mapa
                                        self.map = mapa
                                        self.html = self.map._repr_html_()
                                        self.web_view.setHtml(self.html)
                                        
                                        for i in camino_sin_ultimo:
                                            self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

                                        self.camino_entero = camino_sin_ultimo
                                        self.camino_sublistas = self.hacer_sub_caminos(camino_sin_ultimo)
                                        n = len(self.camino_sublistas)
                                        self.anadir_elementos_comboBox(n)

                                        self.distancia_total = acumular_distancia(self.subset_matriz_dist,secuencia)
                                        self.label_53.setText(str(round(self.distancia_total,2)))
                                        self.secuencia_completa = secuencia
                                        self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
                                        self.label_57.setText(str(round(self.distancia_total/1000,2)))
                                        self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))


                                else:
                                    vuelve = "Si"
                                    camino = heuristica_nn_carga(self.subset_matriz_dist, self.data_completa, capacidad = self.capacidad_vehiculo)
                                    print(camino)
                                    if camino == 'Infactible':
                                        QMessageBox.warning(self, "Warning", "El problema es infactible, alguna de las demandas es mayor a la capacidad del vehculo")
                                    else:
                                        secuencia = self.data_completa.loc[camino, 'ID']
                                        print(secuencia)
                                        direcciones = self.data_completa.loc[camino, 'DIRECCION']
                                        completo = secuencia + ": " + direcciones
                                        rutas_pegadas = ruta_nodos(camino,self.subset_lat_lon,self.G)

                                        mapa = mapa_ruta(rutas_pegadas,self.subset_lat_lon,self.G,secuencia, vuelve)
                                        self.mapa_completo = mapa
                                        self.map = mapa
                                        self.html = self.map._repr_html_()
                                        self.web_view.setHtml(self.html)
                                        
                                        for i in camino:
                                            self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

                                        self.camino_entero = camino
                                        self.camino_sublistas = self.hacer_sub_caminos(camino)
                                        self.camino_sublistas = self.camino_sublistas[:-1]
                                        n = len(self.camino_sublistas)
                                        self.anadir_elementos_comboBox(n)

                                        self.distancia_total = acumular_distancia(self.subset_matriz_dist,secuencia)
                                        self.label_53.setText(str(round(self.distancia_total,2)))
                                        self.secuencia_completa = secuencia
                                        self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
                                        self.label_57.setText(str(round(self.distancia_total/1000,2)))
                                        self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))

                            except:
                                reply = QMessageBox.question(self, 'Confirmar Accin', 'Alguno de los clientes o depsito no est en la base de datos. Se sugiere guardarlo. Si desea continuar, la solucin tardar un tiempo considerable. \nDesea continuar?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                                if reply == QMessageBox.Yes:
                                    if check_no_retorna.isChecked():
                                        vuelve = "No"
                                        df = sacar_lat_lon_clientes(self.data_completa, self.geolocator, self.G)
                                        self.subset_lat_lon = df
                                        matriz = crear_matriz_distancias(self.data_completa, df, self.G)
                                        self.subset_matriz_dist = matriz
                                        camino = heuristica_nn_carga(matriz,self.data_completa, capacidad = self.capacidad_vehiculo)
                                        if camino == 'Infactible':
                                            QMessageBox.warning(self, "Warning", "El problema es infactible, alguna de las demandas es mayor a la capacidad del vehculo")
                                        else:
                                            camino_sin_ultimo = camino[:-1]
                                            secuencia = self.data_completa.loc[camino_sin_ultimo, 'ID']
                                            direcciones = self.data_completa.loc[camino_sin_ultimo, 'DIRECCION']
                                            completo = secuencia + ": " + direcciones

                                            rutas_pegadas = ruta_nodos(camino_sin_ultimo,df,self.G)

                                            mapa = mapa_ruta(rutas_pegadas,df,self.G,secuencia, vuelve)
                                            self.mapa_completo = mapa
                                            self.map = mapa
                                            self.html = self.map._repr_html_()
                                            self.web_view.setHtml(self.html)
                                            
                                            for i in camino_sin_ultimo:
                                                self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

                                            self.camino_entero = camino_sin_ultimo
                                            self.camino_sublistas = self.hacer_sub_caminos(camino_sin_ultimo)
                                            n = len(self.camino_sublistas)
                                            self.anadir_elementos_comboBox(n)

                                            self.distancia_total = acumular_distancia(self.subset_matriz_dist,secuencia)
                                            self.label_53.setText(str(round(self.distancia_total,2)))
                                            self.secuencia_completa = secuencia
                                            self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
                                            self.label_57.setText(str(round(self.distancia_total/1000,2)))
                                            self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))

                                    else:
                                        metodo = "h"
                                        vuelve = "Si"
                                        df = sacar_lat_lon_clientes(self.data_completa,self.geolocator,self.G)
                                        self.subset_lat_lon = df
                                        matriz = crear_matriz_distancias(self.data_completa,df,self.G)
                                        self.subset_matriz_dist = matriz
                                        camino = heuristica_nn_carga(matriz,self.data_completa, capacidad = self.capacidad_vehiculo)
                                        if camino == 'Infactible':
                                            QMessageBox.warning(self, "Warning", "El problema es infactible, alguna de las demandas es mayor a la capacidad del vehculo")
                                        else:
                                            secuencia = self.data_completa.loc[camino, 'ID']
                                            direcciones = self.data_completa.loc[camino, 'DIRECCION']
                                            completo = secuencia + ": " + direcciones
                                            rutas_pegadas = ruta_nodos(camino, df, self.G)
                                            mapa = mapa_ruta(rutas_pegadas, df, self.G, secuencia, vuelve)
                                            #mapa, camino= todo(self.data_completa,metodo,self.geolocator,self.G, secuencia, vuelve)
                                            self.mapa_completo = mapa
                                            self.map = mapa
                                            self.html = self.map._repr_html_()
                                            self.web_view.setHtml(self.html)
                                            
                                            for i in camino:
                                                self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

                                            self.camino_entero = camino
                                            self.camino_sublistas = self.hacer_sub_caminos(camino)
                                            self.camino_sublistas = self.camino_sublistas[:-1]
                                            n = len(self.camino_sublistas)
                                            self.anadir_elementos_comboBox(n)

                                            self.distancia_total = acumular_distancia(self.subset_matriz_dist,secuencia)
                                            self.label_53.setText(str(round(self.distancia_total,2)))
                                            self.secuencia_completa = secuencia
                                            self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
                                            self.label_57.setText(str(round(self.distancia_total/1000,2)))
                                            self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))

                    #Correr sin demandas
                    elif check_demandas.isChecked() == False: 
                        self.capacidad_vehiculo == 99999999999999999999
                        frames = [self.data_deposito, self.data_clientes]
                        self.data_completa = pd.concat(frames, ignore_index = True)
                        self.label_27.setText('Seleccione la ruta a mostrar:')

                        try:
                            matriz_distancias  = pd.read_csv("matriz_distancias.txt", sep=";", index_col = 0)
                            self.subset_matriz_dist = matriz_distancias.loc[self.data_completa["ID"],self.data_completa["ID"]]
                            base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep = ";", index_col = 0, encoding='latin-1')
                            self.subset_lat_lon = base_lat_lon.loc[self.data_completa["ID"]]

                            if check_no_retorna.isChecked():
                                vuelve = "No"
                                camino = heuristica_nn(self.subset_matriz_dist)
                                camino_sin_ultimo = camino[:-1]
                                secuencia = self.data_completa.loc[camino_sin_ultimo, 'ID']
                                direcciones = self.data_completa.loc[camino_sin_ultimo, 'DIRECCION']
                                completo = secuencia + ": " + direcciones

                                rutas_pegadas = ruta_nodos(camino_sin_ultimo,self.subset_lat_lon,self.G)

                                mapa = mapa_ruta(rutas_pegadas,self.subset_lat_lon,self.G,secuencia, vuelve)
                                self.mapa_completo = mapa
                                self.map = mapa
                                self.html = self.map._repr_html_()
                                self.web_view.setHtml(self.html)
                                
                                for i in camino_sin_ultimo:
                                    self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

                                self.camino_entero = camino_sin_ultimo
                                self.camino_sublistas = self.hacer_sub_caminos(camino_sin_ultimo)
                                n = len(self.camino_sublistas)
                                self.anadir_elementos_comboBox(n)

                                self.distancia_total = acumular_distancia(self.subset_matriz_dist,secuencia)
                                self.label_53.setText(str(round(self.distancia_total,2)))
                                self.secuencia_completa = secuencia
                                self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
                                self.label_57.setText(str(round(self.distancia_total/1000,2)))
                                self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))

                            else:
                                vuelve = "Si"
                                camino = heuristica_nn(self.subset_matriz_dist)
                                secuencia = self.data_completa.loc[camino, 'ID']
                                direcciones = self.data_completa.loc[camino, 'DIRECCION']
                                completo = secuencia + ": " + direcciones
                                rutas_pegadas = ruta_nodos(camino,self.subset_lat_lon,self.G)

                                mapa = mapa_ruta(rutas_pegadas,self.subset_lat_lon,self.G,secuencia, vuelve)
                                self.mapa_completo = mapa
                                self.map = mapa
                                self.html = self.map._repr_html_()
                                self.web_view.setHtml(self.html)
                                
                                for i in camino:
                                    self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

                                self.camino_entero = camino
                                self.camino_sublistas = self.hacer_sub_caminos(camino)
                                self.camino_sublistas = self.camino_sublistas[:-1]
                                n = len(self.camino_sublistas)
                                self.anadir_elementos_comboBox(n)

                                self.distancia_total = acumular_distancia(self.subset_matriz_dist,secuencia)
                                self.label_53.setText(str(round(self.distancia_total,2)))
                                self.secuencia_completa = secuencia
                                self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
                                self.label_57.setText(str(round(self.distancia_total/1000,2)))
                                self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))
                        except:
                                reply = QMessageBox.question(self, 'Confirmar Accin', 'Alguno de los clientes o depsito no est en la base de datos. Se sugiere guardarlo. Si desea continuar, la solucin tardar un tiempo considerable. \nDesea continuar?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                                if reply == QMessageBox.Yes:
                                    if check_no_retorna.isChecked():
                                        vuelve = "No"
                                        df = sacar_lat_lon_clientes(self.data_completa, self.geolocator, self.G)
                                        self.subset_lat_lon = df
                                        matriz = crear_matriz_distancias(self.data_completa, df, self.G)
                                        self.subset_matriz_dist = matriz
                                        camino = heuristica_nn(matriz)
                                        camino_sin_ultimo = camino[:-1]
                                        secuencia = self.data_completa.loc[camino_sin_ultimo, 'ID']
                                        direcciones = self.data_completa.loc[camino_sin_ultimo, 'DIRECCION']
                                        completo = secuencia + ": " + direcciones

                                        rutas_pegadas = ruta_nodos(camino_sin_ultimo,df,self.G)

                                        mapa = mapa_ruta(rutas_pegadas,df,self.G,secuencia, vuelve)
                                        self.mapa_completo = mapa
                                        self.map = mapa
                                        self.html = self.map._repr_html_()
                                        self.web_view.setHtml(self.html)
                                        
                                        for i in camino_sin_ultimo:
                                            self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

                                        self.camino_entero = camino_sin_ultimo
                                        self.camino_sublistas = self.hacer_sub_caminos(camino_sin_ultimo)
                                        n = len(self.camino_sublistas)
                                        self.anadir_elementos_comboBox(n)

                                        self.distancia_total = acumular_distancia(self.subset_matriz_dist,secuencia)
                                        self.label_53.setText(str(round(self.distancia_total,2)))
                                        self.secuencia_completa = secuencia
                                        self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
                                        self.label_57.setText(str(round(self.distancia_total/1000,2)))
                                        self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))

                                    else:
                                        vuelve = "Si"
                                        df = sacar_lat_lon_clientes(self.data_completa,self.geolocator,self.G)
                                        self.subset_lat_lon = df
                                        matriz = crear_matriz_distancias(self.data_completa,df,self.G)
                                        self.subset_matriz_dist = matriz
                                        camino = heuristica_nn(matriz)
                                        secuencia = self.data_completa.loc[camino, 'ID']
                                        direcciones = self.data_completa.loc[camino, 'DIRECCION']
                                        completo = secuencia + ": " + direcciones
                                        rutas_pegadas = ruta_nodos(camino, df, self.G)
                                        mapa = mapa_ruta(rutas_pegadas, df, self.G, secuencia, vuelve)
                                        #mapa, camino= todo(self.data_completa,metodo,self.geolocator,self.G, secuencia, vuelve)
                                        self.mapa_completo = mapa
                                        self.map = mapa
                                        self.html = self.map._repr_html_()
                                        self.web_view.setHtml(self.html)
                                        
                                        for i in camino:
                                            self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

                                        self.camino_entero = camino
                                        self.camino_sublistas = self.hacer_sub_caminos(camino)
                                        self.camino_sublistas = self.camino_sublistas[:-1]
                                        n = len(self.camino_sublistas)
                                        self.anadir_elementos_comboBox(n)

                                        self.distancia_total = acumular_distancia(self.subset_matriz_dist,secuencia)
                                        self.label_53.setText(str(round(self.distancia_total,2)))
                                        self.secuencia_completa = secuencia
                                        self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
                                        self.label_57.setText(str(round(self.distancia_total/1000,2)))
                                        self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))


                elif radioB_2.isChecked():
                    QMessageBox.warning(self, "Warning", "Opciones an no disponibles.")
                elif radioB_3.isChecked():
                    QMessageBox.warning(self, "Warning", "Opciones an no disponibles.")




class CustomDialog2(QDialog):
    def __init__(self):
        super().__init__()

        self.setWindowTitle("Opciones de Ruteo")
        self.resize(300,200)
        #self.setGeometry(200, 200, 500, 300)

        titulo = QLabel("Opciones de Ruteo")
        font = QtGui.QFont()
        font.setPointSize(14)
        font.setBold(True)
        font.setWeight(75)
        titulo.setFont(font)

        label_aux = QLabel("Seleccione las configuraciones para el ruteo")
        font = QtGui.QFont()
        font.setPointSize(10)
        label_aux.setFont(font)


        layout = QVBoxLayout()
        layout.addWidget(titulo)
        layout.addWidget(label_aux)

        hor_layout = QHBoxLayout()

        self.radioButton_heuris_nn = QRadioButton("Heurstica vecino ms cercano")
        self.radioButton_heuris_nn.setFont(font)
        self.radioButton_heuris_nn.setAutoFillBackground(True)
        self.radioButton_heuris_nn.setChecked(True)
        self.radioButton_heuris_nn.setFont(font)
        self.radioButton_heuris_nn.setObjectName("radioButton_heuris_nn")

        self.radioButton_2 = QRadioButton("Botn disponible para trabajo futuro")
        self.radioButton_2.setFont(font)
        self.radioButton_2.setAutoFillBackground(True)
        self.radioButton_2.setChecked(False)
        self.radioButton_2.setFont(font)
        self.radioButton_2.setObjectName("radioButton_2")

        self.radioButton_3 = QRadioButton("Botn disponible para trabajo futuro")
        self.radioButton_3.setFont(font)
        self.radioButton_3.setAutoFillBackground(True)
        self.radioButton_3.setChecked(False)
        self.radioButton_3.setFont(font)
        self.radioButton_3.setObjectName("radioButton_3")

        
        self.checkBox_demandas = QCheckBox("Utilizar demandas")
        self.checkBox_demandas.setFont(font)
        self.checkBox_demandas.setObjectName("checkBox_demandas")

        self.checkBox_vent_tiempo = QCheckBox("Utilizar ventanas de tiempo")
        self.checkBox_vent_tiempo.setFont(font)
        self.checkBox_vent_tiempo.setObjectName("checkBox_vent_tiempo")

        self.checkBox_regreso = QCheckBox("No regresar al depsito al finalizar")
        self.checkBox_regreso.setFont(font)
        self.checkBox_regreso.setObjectName("checkBox_regreso")

        v1_layout = QVBoxLayout()
        v2_layout = QVBoxLayout()

        v1_layout.addWidget(self.radioButton_heuris_nn)
        v1_layout.addWidget(self.radioButton_2)
        v1_layout.addWidget(self.radioButton_3)

        v2_layout.addWidget(self.checkBox_demandas)
        v2_layout.addWidget(self.checkBox_vent_tiempo)
        v2_layout.addWidget(self.checkBox_regreso)

        hor_layout.addLayout(v1_layout)
        hor_layout.addLayout(v2_layout)

        layout.addLayout(hor_layout)

        ok_button = QPushButton("Correr")
        cancel_button = QPushButton("Cancelar")

        h2_layout = QHBoxLayout()

        h2_layout.addWidget(ok_button)
        h2_layout.addWidget(cancel_button)

        layout.addLayout(h2_layout)


        # Set the layout for the dialog
        self.setLayout(layout)

        # Connect the button signals to slots
        ok_button.clicked.connect(self.accept)
        cancel_button.clicked.connect(self.reject) 

class Load_Window(QDialog):
    def __init__(self):
        QDialog.__init__(self)
        #self.setGeometry(QtCore.QRect(400,400,500,300))

        self.setWindowTitle("SIR- Uniandes wa.fontalvo10")
        self.resize(500,300)

        title = QLabel(self)
        pixmap = QPixmap('inicio2.jpg')
        title.setPixmap(pixmap)
        self.resize(pixmap.width(),pixmap.height())
        #title.setAlignment(QtCore.Qt.AlignCenter)
        #title.move(200,200)
        self.show()



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
     # Create a QLabel instance with the desired message
    LoadWin = Load_Window()
    app.processEvents()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    # Hide the prompt label and show the main window
    LoadWin.close()
    MainWindow.show()
    sys.exit(app.exec_())
