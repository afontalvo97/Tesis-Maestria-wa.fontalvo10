# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Interfaz2-SIR.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import numpy as np
import osmnx as ox
import networkx as nx
import pandas as pd
import folium as fl
from datetime import timedelta
from geopy.geocoders import Nominatim
import ipywidgets as widgets
import io
from ipywidgets import HTML
from IPython.display import display
import base64
from IPython.display import IFrame
import gurobipy as gp
from gurobipy import GRB
from gurobipy import *
import requests
import folium
import time
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLineEdit, QPushButton, QLabel, QRadioButton, QFileDialog, QProgressBar, QDialog, QCheckBox, QMessageBox, QFormLayout, QListWidget, QTimeEdit, QGridLayout, QSpinBox
from PyQt5.QtWebEngineWidgets import QWebEngineView
from PyQt5.QtCore import QUrl, QCoreApplication, QModelIndex, QRegExp
from PyQt5.QtGui import QFont, QStandardItemModel, QStandardItem, QPixmap
from geopy.geocoders import Nominatim
import funciones_tesis
from funciones_tesis import *
import warnings
from geopy.geocoders import ArcGIS
warnings.filterwarnings('ignore')
import os.path
import os
from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(QWidget):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1763, 910)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
        MainWindow.setSizePolicy(sizePolicy)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.centralwidget.sizePolicy().hasHeightForWidth())
        self.centralwidget.setSizePolicy(sizePolicy)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.verticalLayoutWidget.setGeometry(QtCore.QRect(10, 10, 1751, 851))
        self.verticalLayoutWidget.setObjectName("verticalLayoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.verticalLayoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.label = QtWidgets.QLabel(self.verticalLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(20)
        font.setBold(True)
        font.setWeight(75)
        self.label.setFont(font)
        self.label.setObjectName("label")
        self.verticalLayout.addWidget(self.label)
        self.tabWidget = QtWidgets.QTabWidget(self.verticalLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(12)
        self.tabWidget.setFont(font)
        self.tabWidget.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.tabWidget.setAutoFillBackground(False)
        self.tabWidget.setTabPosition(QtWidgets.QTabWidget.North)
        self.tabWidget.setTabShape(QtWidgets.QTabWidget.Rounded)
        self.tabWidget.setIconSize(QtCore.QSize(30, 23))
        self.tabWidget.setDocumentMode(False)
        self.tabWidget.setTabBarAutoHide(False)
        self.tabWidget.setObjectName("tabWidget")
        self.tab_clientes = QtWidgets.QWidget()
        self.tab_clientes.setObjectName("tab_clientes")
        self.verticalLayoutWidget_4 = QtWidgets.QWidget(self.tab_clientes)
        self.verticalLayoutWidget_4.setGeometry(QtCore.QRect(10, 120, 541, 291))
        self.verticalLayoutWidget_4.setObjectName("verticalLayoutWidget_4")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_4)
        self.verticalLayout_5.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.label_10 = QtWidgets.QLabel(self.verticalLayoutWidget_4)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_10.setFont(font)
        self.label_10.setAutoFillBackground(False)
        self.label_10.setText("")
        self.label_10.setObjectName("label_10")
        self.verticalLayout_5.addWidget(self.label_10)
        self.checkBox_3 = QtWidgets.QCheckBox(self.verticalLayoutWidget_4)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.checkBox_3.setFont(font)
        self.checkBox_3.setAutoFillBackground(True)
        self.checkBox_3.setChecked(True)
        self.checkBox_3.setObjectName("checkBox_3")
        self.verticalLayout_5.addWidget(self.checkBox_3)
        self.scrollArea_4 = QtWidgets.QScrollArea(self.verticalLayoutWidget_4)
        self.scrollArea_4.setWidgetResizable(True)
        self.scrollArea_4.setObjectName("scrollArea_4")
        self.scrollAreaWidgetContents_4 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_4.setGeometry(QtCore.QRect(0, 0, 537, 239))
        self.scrollAreaWidgetContents_4.setObjectName("scrollAreaWidgetContents_4")
        self.scrollArea_4.setWidget(self.scrollAreaWidgetContents_4)
        self.verticalLayout_5.addWidget(self.scrollArea_4)
        self.verticalLayoutWidget_10 = QtWidgets.QWidget(self.tab_clientes)
        self.verticalLayoutWidget_10.setGeometry(QtCore.QRect(10, 10, 541, 91))
        self.verticalLayoutWidget_10.setObjectName("verticalLayoutWidget_10")
        self.verticalLayout_15 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_10)
        self.verticalLayout_15.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_15.setObjectName("verticalLayout_15")
        self.label_3 = QtWidgets.QLabel(self.verticalLayoutWidget_10)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_3.setFont(font)
        self.label_3.setObjectName("label_3")
        self.verticalLayout_15.addWidget(self.label_3)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.pushButton = QtWidgets.QPushButton(self.verticalLayoutWidget_10)
        font = QtGui.QFont()
        font.setPointSize(8)
        self.pushButton.setFont(font)
        self.pushButton.setObjectName("pushButton")
        self.horizontalLayout_4.addWidget(self.pushButton)
        self.pushButton_4 = QtWidgets.QPushButton(self.verticalLayoutWidget_10)
        font = QtGui.QFont()
        font.setPointSize(8)
        self.pushButton_4.setFont(font)
        self.pushButton_4.setObjectName("pushButton_4")
        self.horizontalLayout_4.addWidget(self.pushButton_4)
        self.pushButton_2 = QtWidgets.QPushButton(self.verticalLayoutWidget_10)
        font = QtGui.QFont()
        font.setPointSize(8)
        self.pushButton_2.setFont(font)
        self.pushButton_2.setObjectName("pushButton_2")
        self.horizontalLayout_4.addWidget(self.pushButton_2)
        self.verticalLayout_15.addLayout(self.horizontalLayout_4)
        self.frame_3 = QtWidgets.QFrame(self.tab_clientes)
        self.frame_3.setGeometry(QtCore.QRect(570, 570, 541, 191))
        self.frame_3.setAutoFillBackground(True)
        self.frame_3.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_3.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_3.setObjectName("frame_3")
        self.label_8 = QtWidgets.QLabel(self.frame_3)
        self.label_8.setGeometry(QtCore.QRect(10, 10, 481, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_8.setFont(font)
        self.label_8.setObjectName("label_8")
        self.verticalLayoutWidget_17 = QtWidgets.QWidget(self.frame_3)
        self.verticalLayoutWidget_17.setGeometry(QtCore.QRect(20, 30, 491, 141))
        self.verticalLayoutWidget_17.setObjectName("verticalLayoutWidget_17")
        self.verticalLayout_19 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_17)
        self.verticalLayout_19.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_19.setObjectName("verticalLayout_19")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label_16 = QtWidgets.QLabel(self.verticalLayoutWidget_17)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_16.setFont(font)
        self.label_16.setObjectName("label_16")
        self.horizontalLayout.addWidget(self.label_16)
        self.lineEdit = QtWidgets.QLineEdit(self.verticalLayoutWidget_17)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit.setFont(font)
        self.lineEdit.setObjectName("lineEdit")
        self.horizontalLayout.addWidget(self.lineEdit)
        self.verticalLayout_19.addLayout(self.horizontalLayout)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.label_18 = QtWidgets.QLabel(self.verticalLayoutWidget_17)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_18.setFont(font)
        self.label_18.setObjectName("label_18")
        self.horizontalLayout_3.addWidget(self.label_18)
        self.lineEdit_2 = QtWidgets.QLineEdit(self.verticalLayoutWidget_17)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit_2.setFont(font)
        self.lineEdit_2.setObjectName("lineEdit_2")
        self.horizontalLayout_3.addWidget(self.lineEdit_2)
        self.verticalLayout_19.addLayout(self.horizontalLayout_3)
        self.pushButton_14 = QtWidgets.QPushButton(self.verticalLayoutWidget_17)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_14.setFont(font)
        self.pushButton_14.setObjectName("pushButton_14")
        self.verticalLayout_19.addWidget(self.pushButton_14)
        self.line = QtWidgets.QFrame(self.tab_clientes)
        self.line.setGeometry(QtCore.QRect(550, 10, 21, 711))
        self.line.setFrameShape(QtWidgets.QFrame.VLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName("line")
        self.verticalLayoutWidget_6 = QtWidgets.QWidget(self.tab_clientes)
        self.verticalLayoutWidget_6.setGeometry(QtCore.QRect(10, 430, 541, 121))
        self.verticalLayoutWidget_6.setObjectName("verticalLayoutWidget_6")
        self.verticalLayout_12 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_6)
        self.verticalLayout_12.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_12.setObjectName("verticalLayout_12")
        self.pushButton_11 = QtWidgets.QPushButton(self.verticalLayoutWidget_6)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_11.setFont(font)
        self.pushButton_11.setObjectName("pushButton_11")
        self.verticalLayout_12.addWidget(self.pushButton_11)
        self.pushButton_12 = QtWidgets.QPushButton(self.verticalLayoutWidget_6)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_12.setFont(font)
        self.pushButton_12.setObjectName("pushButton_12")
        self.verticalLayout_12.addWidget(self.pushButton_12)
        self.pushButton_23 = QtWidgets.QPushButton(self.verticalLayoutWidget_6)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_23.setFont(font)
        self.pushButton_23.setObjectName("pushButton_23")
        self.verticalLayout_12.addWidget(self.pushButton_23)
        self.verticalLayoutWidget_16 = QtWidgets.QWidget(self.tab_clientes)
        self.verticalLayoutWidget_16.setGeometry(QtCore.QRect(570, 10, 541, 91))
        self.verticalLayoutWidget_16.setObjectName("verticalLayoutWidget_16")
        self.verticalLayout_18 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_16)
        self.verticalLayout_18.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_18.setObjectName("verticalLayout_18")
        self.label_15 = QtWidgets.QLabel(self.verticalLayoutWidget_16)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_15.setFont(font)
        self.label_15.setObjectName("label_15")
        self.verticalLayout_18.addWidget(self.label_15)
        self.pushButton_13 = QtWidgets.QPushButton(self.verticalLayoutWidget_16)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_13.setFont(font)
        self.pushButton_13.setObjectName("pushButton_13")
        self.verticalLayout_18.addWidget(self.pushButton_13)
        self.verticalLayoutWidget_19 = QtWidgets.QWidget(self.tab_clientes)
        self.verticalLayoutWidget_19.setGeometry(QtCore.QRect(570, 120, 541, 291))
        self.verticalLayoutWidget_19.setObjectName("verticalLayoutWidget_19")
        self.verticalLayout_21 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_19)
        self.verticalLayout_21.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_21.setObjectName("verticalLayout_21")
        self.label_17 = QtWidgets.QLabel(self.verticalLayoutWidget_19)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_17.setFont(font)
        self.label_17.setAutoFillBackground(False)
        self.label_17.setText("")
        self.label_17.setObjectName("label_17")
        self.verticalLayout_21.addWidget(self.label_17)
        self.checkBox = QtWidgets.QCheckBox(self.verticalLayoutWidget_19)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.checkBox.setFont(font)
        self.checkBox.setAutoFillBackground(True)
        self.checkBox.setChecked(True)
        self.checkBox.setObjectName("checkBox")
        self.verticalLayout_21.addWidget(self.checkBox)
        self.scrollArea_6 = QtWidgets.QScrollArea(self.verticalLayoutWidget_19)
        self.scrollArea_6.setWidgetResizable(True)
        self.scrollArea_6.setObjectName("scrollArea_6")
        self.scrollAreaWidgetContents_6 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_6.setGeometry(QtCore.QRect(0, 0, 537, 239))
        self.scrollAreaWidgetContents_6.setObjectName("scrollAreaWidgetContents_6")
        self.scrollArea_6.setWidget(self.scrollAreaWidgetContents_6)
        self.verticalLayout_21.addWidget(self.scrollArea_6)
        self.frame_5 = QtWidgets.QFrame(self.tab_clientes)
        self.frame_5.setGeometry(QtCore.QRect(10, 570, 541, 191))
        self.frame_5.setAutoFillBackground(True)
        self.frame_5.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_5.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_5.setObjectName("frame_5")
        self.label_28 = QtWidgets.QLabel(self.frame_5)
        self.label_28.setGeometry(QtCore.QRect(10, 10, 481, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_28.setFont(font)
        self.label_28.setObjectName("label_28")
        self.verticalLayoutWidget_28 = QtWidgets.QWidget(self.frame_5)
        self.verticalLayoutWidget_28.setGeometry(QtCore.QRect(20, 30, 491, 141))
        self.verticalLayoutWidget_28.setObjectName("verticalLayoutWidget_28")
        self.verticalLayout_28 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_28)
        self.verticalLayout_28.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_28.setObjectName("verticalLayout_28")
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.label_29 = QtWidgets.QLabel(self.verticalLayoutWidget_28)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_29.setFont(font)
        self.label_29.setObjectName("label_29")
        self.horizontalLayout_8.addWidget(self.label_29)
        self.lineEdit_7 = QtWidgets.QLineEdit(self.verticalLayoutWidget_28)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit_7.setFont(font)
        self.lineEdit_7.setObjectName("lineEdit_7")
        self.horizontalLayout_8.addWidget(self.lineEdit_7)
        self.verticalLayout_28.addLayout(self.horizontalLayout_8)
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        self.label_30 = QtWidgets.QLabel(self.verticalLayoutWidget_28)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_30.setFont(font)
        self.label_30.setObjectName("label_30")
        self.horizontalLayout_9.addWidget(self.label_30)
        self.lineEdit_8 = QtWidgets.QLineEdit(self.verticalLayoutWidget_28)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit_8.setFont(font)
        self.lineEdit_8.setObjectName("lineEdit_8")
        self.horizontalLayout_9.addWidget(self.lineEdit_8)
        self.verticalLayout_28.addLayout(self.horizontalLayout_9)
        self.pushButton_26 = QtWidgets.QPushButton(self.verticalLayoutWidget_28)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_26.setFont(font)
        self.pushButton_26.setObjectName("pushButton_26")
        self.verticalLayout_28.addWidget(self.pushButton_26)
        self.verticalLayoutWidget_3 = QtWidgets.QWidget(self.tab_clientes)
        self.verticalLayoutWidget_3.setGeometry(QtCore.QRect(570, 430, 541, 121))
        self.verticalLayoutWidget_3.setObjectName("verticalLayoutWidget_3")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_3)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.pushButton_15 = QtWidgets.QPushButton(self.verticalLayoutWidget_3)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_15.setFont(font)
        self.pushButton_15.setObjectName("pushButton_15")
        self.verticalLayout_2.addWidget(self.pushButton_15)
        self.pushButton_16 = QtWidgets.QPushButton(self.verticalLayoutWidget_3)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_16.setFont(font)
        self.pushButton_16.setObjectName("pushButton_16")
        self.verticalLayout_2.addWidget(self.pushButton_16)
        self.pushButton_9 = QtWidgets.QPushButton(self.verticalLayoutWidget_3)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_9.setFont(font)
        self.pushButton_9.setObjectName("pushButton_9")
        self.verticalLayout_2.addWidget(self.pushButton_9)
        self.verticalLayoutWidget_27 = QtWidgets.QWidget(self.tab_clientes)
        self.verticalLayoutWidget_27.setGeometry(QtCore.QRect(1120, 40, 581, 391))
        self.verticalLayoutWidget_27.setObjectName("verticalLayoutWidget_27")
        self.verticalLayout_27 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_27)
        self.verticalLayout_27.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_27.setObjectName("verticalLayout_27")
        self.verticalLayoutWidget_32 = QtWidgets.QWidget(self.tab_clientes)
        self.verticalLayoutWidget_32.setGeometry(QtCore.QRect(1120, 10, 581, 31))
        self.verticalLayoutWidget_32.setObjectName("verticalLayoutWidget_32")
        self.verticalLayout_32 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_32)
        self.verticalLayout_32.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_32.setObjectName("verticalLayout_32")
        self.label_31 = QtWidgets.QLabel(self.verticalLayoutWidget_32)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_31.setFont(font)
        self.label_31.setObjectName("label_31")
        self.verticalLayout_32.addWidget(self.label_31)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("../.designer/backup/clientes_img.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.tabWidget.addTab(self.tab_clientes, icon, "")
        self.depots_tab = QtWidgets.QWidget()
        self.depots_tab.setObjectName("depots_tab")
        self.verticalLayoutWidget_11 = QtWidgets.QWidget(self.depots_tab)
        self.verticalLayoutWidget_11.setGeometry(QtCore.QRect(10, 10, 541, 91))
        self.verticalLayoutWidget_11.setObjectName("verticalLayoutWidget_11")
        self.verticalLayout_16 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_11)
        self.verticalLayout_16.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_16.setObjectName("verticalLayout_16")
        self.label_5 = QtWidgets.QLabel(self.verticalLayoutWidget_11)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_5.setFont(font)
        self.label_5.setObjectName("label_5")
        self.verticalLayout_16.addWidget(self.label_5)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.pushButton_3 = QtWidgets.QPushButton(self.verticalLayoutWidget_11)
        font = QtGui.QFont()
        font.setPointSize(8)
        self.pushButton_3.setFont(font)
        self.pushButton_3.setObjectName("pushButton_3")
        self.horizontalLayout_6.addWidget(self.pushButton_3)
        self.pushButton_5 = QtWidgets.QPushButton(self.verticalLayoutWidget_11)
        font = QtGui.QFont()
        font.setPointSize(8)
        self.pushButton_5.setFont(font)
        self.pushButton_5.setObjectName("pushButton_5")
        self.horizontalLayout_6.addWidget(self.pushButton_5)
        self.pushButton_6 = QtWidgets.QPushButton(self.verticalLayoutWidget_11)
        font = QtGui.QFont()
        font.setPointSize(8)
        self.pushButton_6.setFont(font)
        self.pushButton_6.setObjectName("pushButton_6")
        self.horizontalLayout_6.addWidget(self.pushButton_6)
        self.verticalLayout_16.addLayout(self.horizontalLayout_6)
        self.line_2 = QtWidgets.QFrame(self.depots_tab)
        self.line_2.setGeometry(QtCore.QRect(550, 10, 21, 711))
        self.line_2.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_2.setObjectName("line_2")
        self.verticalLayoutWidget_23 = QtWidgets.QWidget(self.depots_tab)
        self.verticalLayoutWidget_23.setGeometry(QtCore.QRect(570, 120, 541, 311))
        self.verticalLayoutWidget_23.setObjectName("verticalLayoutWidget_23")
        self.verticalLayout_22 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_23)
        self.verticalLayout_22.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_22.setObjectName("verticalLayout_22")
        self.label_19 = QtWidgets.QLabel(self.verticalLayoutWidget_23)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_19.setFont(font)
        self.label_19.setAutoFillBackground(False)
        self.label_19.setText("")
        self.label_19.setObjectName("label_19")
        self.verticalLayout_22.addWidget(self.label_19)
        self.checkBox_2 = QtWidgets.QCheckBox(self.verticalLayoutWidget_23)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.checkBox_2.setFont(font)
        self.checkBox_2.setAutoFillBackground(True)
        self.checkBox_2.setChecked(True)
        self.checkBox_2.setObjectName("checkBox_2")
        self.verticalLayout_22.addWidget(self.checkBox_2)
        self.scrollArea_7 = QtWidgets.QScrollArea(self.verticalLayoutWidget_23)
        self.scrollArea_7.setWidgetResizable(True)
        self.scrollArea_7.setObjectName("scrollArea_7")
        self.scrollAreaWidgetContents_7 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_7.setGeometry(QtCore.QRect(0, 0, 537, 259))
        self.scrollAreaWidgetContents_7.setObjectName("scrollAreaWidgetContents_7")
        self.scrollArea_7.setWidget(self.scrollAreaWidgetContents_7)
        self.verticalLayout_22.addWidget(self.scrollArea_7)
        self.verticalLayoutWidget_13 = QtWidgets.QWidget(self.depots_tab)
        self.verticalLayoutWidget_13.setGeometry(QtCore.QRect(10, 440, 541, 121))
        self.verticalLayoutWidget_13.setObjectName("verticalLayoutWidget_13")
        self.verticalLayout_24 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_13)
        self.verticalLayout_24.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_24.setObjectName("verticalLayout_24")
        self.pushButton_19 = QtWidgets.QPushButton(self.verticalLayoutWidget_13)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_19.setFont(font)
        self.pushButton_19.setObjectName("pushButton_19")
        self.verticalLayout_24.addWidget(self.pushButton_19)
        self.pushButton_20 = QtWidgets.QPushButton(self.verticalLayoutWidget_13)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_20.setFont(font)
        self.pushButton_20.setObjectName("pushButton_20")
        self.verticalLayout_24.addWidget(self.pushButton_20)
        self.pushButton_24 = QtWidgets.QPushButton(self.verticalLayoutWidget_13)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_24.setFont(font)
        self.pushButton_24.setObjectName("pushButton_24")
        self.verticalLayout_24.addWidget(self.pushButton_24)
        self.verticalLayoutWidget_24 = QtWidgets.QWidget(self.depots_tab)
        self.verticalLayoutWidget_24.setGeometry(QtCore.QRect(10, 120, 541, 311))
        self.verticalLayoutWidget_24.setObjectName("verticalLayoutWidget_24")
        self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_24)
        self.verticalLayout_6.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.label_11 = QtWidgets.QLabel(self.verticalLayoutWidget_24)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_11.setFont(font)
        self.label_11.setAutoFillBackground(False)
        self.label_11.setText("")
        self.label_11.setObjectName("label_11")
        self.verticalLayout_6.addWidget(self.label_11)
        self.checkBox_4 = QtWidgets.QCheckBox(self.verticalLayoutWidget_24)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.checkBox_4.setFont(font)
        self.checkBox_4.setAutoFillBackground(True)
        self.checkBox_4.setChecked(True)
        self.checkBox_4.setObjectName("checkBox_4")
        self.verticalLayout_6.addWidget(self.checkBox_4)
        self.scrollArea_5 = QtWidgets.QScrollArea(self.verticalLayoutWidget_24)
        self.scrollArea_5.setWidgetResizable(True)
        self.scrollArea_5.setObjectName("scrollArea_5")
        self.scrollAreaWidgetContents_5 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_5.setGeometry(QtCore.QRect(0, 0, 537, 237))
        self.scrollAreaWidgetContents_5.setObjectName("scrollAreaWidgetContents_5")
        self.scrollArea_5.setWidget(self.scrollAreaWidgetContents_5)
        self.verticalLayout_6.addWidget(self.scrollArea_5)
        self.label_37 = QtWidgets.QLabel(self.verticalLayoutWidget_24)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_37.setFont(font)
        self.label_37.setObjectName("label_37")
        self.verticalLayout_6.addWidget(self.label_37)
        self.verticalLayoutWidget_25 = QtWidgets.QWidget(self.depots_tab)
        self.verticalLayoutWidget_25.setGeometry(QtCore.QRect(570, 10, 541, 91))
        self.verticalLayoutWidget_25.setObjectName("verticalLayoutWidget_25")
        self.verticalLayout_25 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_25)
        self.verticalLayout_25.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_25.setObjectName("verticalLayout_25")
        self.label_20 = QtWidgets.QLabel(self.verticalLayoutWidget_25)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_20.setFont(font)
        self.label_20.setObjectName("label_20")
        self.verticalLayout_25.addWidget(self.label_20)
        self.pushButton_21 = QtWidgets.QPushButton(self.verticalLayoutWidget_25)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_21.setFont(font)
        self.pushButton_21.setObjectName("pushButton_21")
        self.verticalLayout_25.addWidget(self.pushButton_21)
        self.frame_4 = QtWidgets.QFrame(self.depots_tab)
        self.frame_4.setGeometry(QtCore.QRect(570, 570, 541, 201))
        self.frame_4.setAutoFillBackground(True)
        self.frame_4.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_4.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_4.setObjectName("frame_4")
        self.label_9 = QtWidgets.QLabel(self.frame_4)
        self.label_9.setGeometry(QtCore.QRect(10, 10, 481, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_9.setFont(font)
        self.label_9.setObjectName("label_9")
        self.verticalLayoutWidget_26 = QtWidgets.QWidget(self.frame_4)
        self.verticalLayoutWidget_26.setGeometry(QtCore.QRect(30, 30, 491, 141))
        self.verticalLayoutWidget_26.setObjectName("verticalLayoutWidget_26")
        self.verticalLayout_26 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_26)
        self.verticalLayout_26.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_26.setObjectName("verticalLayout_26")
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.label_21 = QtWidgets.QLabel(self.verticalLayoutWidget_26)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_21.setFont(font)
        self.label_21.setObjectName("label_21")
        self.horizontalLayout_7.addWidget(self.label_21)
        self.lineEdit_3 = QtWidgets.QLineEdit(self.verticalLayoutWidget_26)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit_3.setFont(font)
        self.lineEdit_3.setObjectName("lineEdit_3")
        self.horizontalLayout_7.addWidget(self.lineEdit_3)
        self.verticalLayout_26.addLayout(self.horizontalLayout_7)
        self.horizontalLayout_12 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_12.setObjectName("horizontalLayout_12")
        self.label_22 = QtWidgets.QLabel(self.verticalLayoutWidget_26)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_22.setFont(font)
        self.label_22.setObjectName("label_22")
        self.horizontalLayout_12.addWidget(self.label_22)
        self.lineEdit_4 = QtWidgets.QLineEdit(self.verticalLayoutWidget_26)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit_4.setFont(font)
        self.lineEdit_4.setObjectName("lineEdit_4")
        self.horizontalLayout_12.addWidget(self.lineEdit_4)
        self.verticalLayout_26.addLayout(self.horizontalLayout_12)
        self.pushButton_22 = QtWidgets.QPushButton(self.verticalLayoutWidget_26)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_22.setFont(font)
        self.pushButton_22.setObjectName("pushButton_22")
        self.verticalLayout_26.addWidget(self.pushButton_22)
        self.frame_6 = QtWidgets.QFrame(self.depots_tab)
        self.frame_6.setGeometry(QtCore.QRect(10, 570, 541, 201))
        self.frame_6.setAutoFillBackground(True)
        self.frame_6.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_6.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_6.setObjectName("frame_6")
        self.label_34 = QtWidgets.QLabel(self.frame_6)
        self.label_34.setGeometry(QtCore.QRect(10, 10, 481, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_34.setFont(font)
        self.label_34.setObjectName("label_34")
        self.verticalLayoutWidget_30 = QtWidgets.QWidget(self.frame_6)
        self.verticalLayoutWidget_30.setGeometry(QtCore.QRect(20, 30, 491, 141))
        self.verticalLayoutWidget_30.setObjectName("verticalLayoutWidget_30")
        self.verticalLayout_30 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_30)
        self.verticalLayout_30.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_30.setObjectName("verticalLayout_30")
        self.horizontalLayout_16 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_16.setObjectName("horizontalLayout_16")
        self.label_35 = QtWidgets.QLabel(self.verticalLayoutWidget_30)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_35.setFont(font)
        self.label_35.setObjectName("label_35")
        self.horizontalLayout_16.addWidget(self.label_35)
        self.lineEdit_11 = QtWidgets.QLineEdit(self.verticalLayoutWidget_30)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit_11.setFont(font)
        self.lineEdit_11.setObjectName("lineEdit_11")
        self.horizontalLayout_16.addWidget(self.lineEdit_11)
        self.verticalLayout_30.addLayout(self.horizontalLayout_16)
        self.horizontalLayout_17 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_17.setObjectName("horizontalLayout_17")
        self.label_36 = QtWidgets.QLabel(self.verticalLayoutWidget_30)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_36.setFont(font)
        self.label_36.setObjectName("label_36")
        self.horizontalLayout_17.addWidget(self.label_36)
        self.lineEdit_12 = QtWidgets.QLineEdit(self.verticalLayoutWidget_30)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit_12.setFont(font)
        self.lineEdit_12.setObjectName("lineEdit_12")
        self.horizontalLayout_17.addWidget(self.lineEdit_12)
        self.verticalLayout_30.addLayout(self.horizontalLayout_17)
        self.pushButton_28 = QtWidgets.QPushButton(self.verticalLayoutWidget_30)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_28.setFont(font)
        self.pushButton_28.setObjectName("pushButton_28")
        self.verticalLayout_30.addWidget(self.pushButton_28)
        self.verticalLayoutWidget_2 = QtWidgets.QWidget(self.depots_tab)
        self.verticalLayoutWidget_2.setGeometry(QtCore.QRect(570, 440, 541, 111))
        self.verticalLayoutWidget_2.setObjectName("verticalLayoutWidget_2")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_2)
        self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.pushButton_18 = QtWidgets.QPushButton(self.verticalLayoutWidget_2)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_18.setFont(font)
        self.pushButton_18.setObjectName("pushButton_18")
        self.verticalLayout_3.addWidget(self.pushButton_18)
        self.pushButton_17 = QtWidgets.QPushButton(self.verticalLayoutWidget_2)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_17.setFont(font)
        self.pushButton_17.setObjectName("pushButton_17")
        self.verticalLayout_3.addWidget(self.pushButton_17)
        self.pushButton_29 = QtWidgets.QPushButton(self.verticalLayoutWidget_2)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_29.setFont(font)
        self.pushButton_29.setObjectName("pushButton_29")
        self.verticalLayout_3.addWidget(self.pushButton_29)
        self.verticalLayoutWidget_29 = QtWidgets.QWidget(self.depots_tab)
        self.verticalLayoutWidget_29.setGeometry(QtCore.QRect(1120, 40, 581, 401))
        self.verticalLayoutWidget_29.setObjectName("verticalLayoutWidget_29")
        self.verticalLayout_31 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_29)
        self.verticalLayout_31.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_31.setObjectName("verticalLayout_31")
        self.verticalLayoutWidget_35 = QtWidgets.QWidget(self.depots_tab)
        self.verticalLayoutWidget_35.setGeometry(QtCore.QRect(1120, 10, 581, 31))
        self.verticalLayoutWidget_35.setObjectName("verticalLayoutWidget_35")
        self.verticalLayout_35 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_35)
        self.verticalLayout_35.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_35.setObjectName("verticalLayout_35")
        self.label_32 = QtWidgets.QLabel(self.verticalLayoutWidget_35)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_32.setFont(font)
        self.label_32.setObjectName("label_32")
        self.verticalLayout_35.addWidget(self.label_32)
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap("../.designer/backup/Depot.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.tabWidget.addTab(self.depots_tab, icon1, "")
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.verticalLayoutWidget_7 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_7.setGeometry(QtCore.QRect(10, 10, 491, 61))
        self.verticalLayoutWidget_7.setObjectName("verticalLayoutWidget_7")
        self.verticalLayout_13 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_7)
        self.verticalLayout_13.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_13.setObjectName("verticalLayout_13")
        self.label_25 = QtWidgets.QLabel(self.verticalLayoutWidget_7)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_25.setFont(font)
        self.label_25.setObjectName("label_25")
        self.verticalLayout_13.addWidget(self.label_25)
        self.verticalLayoutWidget_12 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_12.setGeometry(QtCore.QRect(10, 90, 501, 291))
        self.verticalLayoutWidget_12.setObjectName("verticalLayoutWidget_12")
        self.verticalLayout_17 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_12)
        self.verticalLayout_17.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_17.setObjectName("verticalLayout_17")
        self.label_26 = QtWidgets.QLabel(self.verticalLayoutWidget_12)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_26.setFont(font)
        self.label_26.setObjectName("label_26")
        self.verticalLayout_17.addWidget(self.label_26)
        self.checkBox_6 = QtWidgets.QCheckBox(self.verticalLayoutWidget_12)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.checkBox_6.setFont(font)
        self.checkBox_6.setAutoFillBackground(True)
        self.checkBox_6.setChecked(True)
        self.checkBox_6.setObjectName("checkBox_6")
        self.verticalLayout_17.addWidget(self.checkBox_6)
        self.scrollArea_8 = QtWidgets.QScrollArea(self.verticalLayoutWidget_12)
        self.scrollArea_8.setWidgetResizable(True)
        self.scrollArea_8.setObjectName("scrollArea_8")
        self.scrollAreaWidgetContents_8 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_8.setGeometry(QtCore.QRect(0, 0, 497, 217))
        self.scrollAreaWidgetContents_8.setObjectName("scrollAreaWidgetContents_8")
        self.scrollArea_8.setWidget(self.scrollAreaWidgetContents_8)
        self.verticalLayout_17.addWidget(self.scrollArea_8)
        self.label_42 = QtWidgets.QLabel(self.verticalLayoutWidget_12)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_42.setFont(font)
        self.label_42.setObjectName("label_42")
        self.verticalLayout_17.addWidget(self.label_42)
        self.frame_7 = QtWidgets.QFrame(self.tab)
        self.frame_7.setGeometry(QtCore.QRect(10, 540, 501, 191))
        self.frame_7.setAutoFillBackground(True)
        self.frame_7.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_7.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_7.setObjectName("frame_7")
        self.label_38 = QtWidgets.QLabel(self.frame_7)
        self.label_38.setGeometry(QtCore.QRect(10, 10, 481, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_38.setFont(font)
        self.label_38.setObjectName("label_38")
        self.verticalLayoutWidget_33 = QtWidgets.QWidget(self.frame_7)
        self.verticalLayoutWidget_33.setGeometry(QtCore.QRect(20, 30, 461, 141))
        self.verticalLayoutWidget_33.setObjectName("verticalLayoutWidget_33")
        self.verticalLayout_33 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_33)
        self.verticalLayout_33.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_33.setObjectName("verticalLayout_33")
        self.horizontalLayout_14 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_14.setObjectName("horizontalLayout_14")
        self.label_39 = QtWidgets.QLabel(self.verticalLayoutWidget_33)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_39.setFont(font)
        self.label_39.setObjectName("label_39")
        self.horizontalLayout_14.addWidget(self.label_39)
        self.lineEdit_13 = QtWidgets.QLineEdit(self.verticalLayoutWidget_33)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.lineEdit_13.setFont(font)
        self.lineEdit_13.setObjectName("lineEdit_13")
        self.horizontalLayout_14.addWidget(self.lineEdit_13)
        self.verticalLayout_33.addLayout(self.horizontalLayout_14)
        self.horizontalLayout_15 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_15.setObjectName("horizontalLayout_15")
        self.label_40 = QtWidgets.QLabel(self.verticalLayoutWidget_33)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_40.setFont(font)
        self.label_40.setObjectName("label_40")
        self.horizontalLayout_15.addWidget(self.label_40)
        self.spinBox = QtWidgets.QSpinBox(self.verticalLayoutWidget_33)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.spinBox.setFont(font)
        self.spinBox.setAutoFillBackground(False)
        self.spinBox.setMaximum(999999999)
        self.spinBox.setObjectName("spinBox")
        self.horizontalLayout_15.addWidget(self.spinBox)
        self.verticalLayout_33.addLayout(self.horizontalLayout_15)
        self.pushButton_30 = QtWidgets.QPushButton(self.verticalLayoutWidget_33)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_30.setFont(font)
        self.pushButton_30.setObjectName("pushButton_30")
        self.verticalLayout_33.addWidget(self.pushButton_30)
        self.verticalLayoutWidget_34 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_34.setGeometry(QtCore.QRect(10, 400, 501, 121))
        self.verticalLayoutWidget_34.setObjectName("verticalLayoutWidget_34")
        self.verticalLayout_34 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_34)
        self.verticalLayout_34.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_34.setObjectName("verticalLayout_34")
        self.pushButton_32 = QtWidgets.QPushButton(self.verticalLayoutWidget_34)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_32.setFont(font)
        self.pushButton_32.setObjectName("pushButton_32")
        self.verticalLayout_34.addWidget(self.pushButton_32)
        self.pushButton_27 = QtWidgets.QPushButton(self.verticalLayoutWidget_34)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_27.setFont(font)
        self.pushButton_27.setObjectName("pushButton_27")
        self.verticalLayout_34.addWidget(self.pushButton_27)
        self.pushButton_25 = QtWidgets.QPushButton(self.verticalLayoutWidget_34)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_25.setFont(font)
        self.pushButton_25.setObjectName("pushButton_25")
        self.verticalLayout_34.addWidget(self.pushButton_25)
        self.line_3 = QtWidgets.QFrame(self.tab)
        self.line_3.setGeometry(QtCore.QRect(520, 30, 21, 711))
        self.line_3.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_3.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_3.setObjectName("line_3")
        self.verticalLayoutWidget_36 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_36.setGeometry(QtCore.QRect(550, 10, 531, 61))
        self.verticalLayoutWidget_36.setObjectName("verticalLayoutWidget_36")
        self.verticalLayout_36 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_36)
        self.verticalLayout_36.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_36.setObjectName("verticalLayout_36")
        self.label_33 = QtWidgets.QLabel(self.verticalLayoutWidget_36)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_33.setFont(font)
        self.label_33.setObjectName("label_33")
        self.verticalLayout_36.addWidget(self.label_33)
        self.verticalLayoutWidget_37 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_37.setGeometry(QtCore.QRect(550, 90, 531, 291))
        self.verticalLayoutWidget_37.setObjectName("verticalLayoutWidget_37")
        self.verticalLayout_37 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_37)
        self.verticalLayout_37.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_37.setObjectName("verticalLayout_37")
        self.label_41 = QtWidgets.QLabel(self.verticalLayoutWidget_37)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_41.setFont(font)
        self.label_41.setObjectName("label_41")
        self.verticalLayout_37.addWidget(self.label_41)
        self.scrollArea_9 = QtWidgets.QScrollArea(self.verticalLayoutWidget_37)
        self.scrollArea_9.setWidgetResizable(True)
        self.scrollArea_9.setObjectName("scrollArea_9")
        self.scrollAreaWidgetContents_9 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_9.setGeometry(QtCore.QRect(0, 0, 527, 243))
        self.scrollAreaWidgetContents_9.setObjectName("scrollAreaWidgetContents_9")
        self.scrollArea_9.setWidget(self.scrollAreaWidgetContents_9)
        self.verticalLayout_37.addWidget(self.scrollArea_9)
        self.label_44 = QtWidgets.QLabel(self.verticalLayoutWidget_37)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_44.setFont(font)
        self.label_44.setObjectName("label_44")
        self.verticalLayout_37.addWidget(self.label_44)
        self.verticalLayoutWidget_38 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_38.setGeometry(QtCore.QRect(550, 400, 531, 121))
        self.verticalLayoutWidget_38.setObjectName("verticalLayoutWidget_38")
        self.verticalLayout_38 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_38)
        self.verticalLayout_38.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_38.setObjectName("verticalLayout_38")
        self.pushButton_33 = QtWidgets.QPushButton(self.verticalLayoutWidget_38)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_33.setFont(font)
        self.pushButton_33.setObjectName("pushButton_33")
        self.verticalLayout_38.addWidget(self.pushButton_33)
        self.pushButton_31 = QtWidgets.QPushButton(self.verticalLayoutWidget_38)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_31.setFont(font)
        self.pushButton_31.setObjectName("pushButton_31")
        self.verticalLayout_38.addWidget(self.pushButton_31)
        self.line_4 = QtWidgets.QFrame(self.tab)
        self.line_4.setGeometry(QtCore.QRect(1090, 30, 21, 711))
        self.line_4.setFrameShape(QtWidgets.QFrame.VLine)
        self.line_4.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line_4.setObjectName("line_4")
        self.verticalLayoutWidget_39 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_39.setGeometry(QtCore.QRect(1120, 10, 601, 61))
        self.verticalLayoutWidget_39.setObjectName("verticalLayoutWidget_39")
        self.verticalLayout_39 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_39)
        self.verticalLayout_39.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_39.setObjectName("verticalLayout_39")
        self.label_43 = QtWidgets.QLabel(self.verticalLayoutWidget_39)
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.label_43.setFont(font)
        self.label_43.setObjectName("label_43")
        self.verticalLayout_39.addWidget(self.label_43)
        self.verticalLayoutWidget_40 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_40.setGeometry(QtCore.QRect(1120, 90, 601, 291))
        self.verticalLayoutWidget_40.setObjectName("verticalLayoutWidget_40")
        self.verticalLayout_40 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_40)
        self.verticalLayout_40.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_40.setObjectName("verticalLayout_40")
        self.label_45 = QtWidgets.QLabel(self.verticalLayoutWidget_40)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_45.setFont(font)
        self.label_45.setObjectName("label_45")
        self.verticalLayout_40.addWidget(self.label_45)
        self.gridLayout_2 = QtWidgets.QGridLayout()
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.label_24 = QtWidgets.QLabel(self.verticalLayoutWidget_40)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_24.setFont(font)
        self.label_24.setObjectName("label_24")
        self.gridLayout_2.addWidget(self.label_24, 0, 1, 1, 1)
        self.label_23 = QtWidgets.QLabel(self.verticalLayoutWidget_40)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_23.setFont(font)
        self.label_23.setObjectName("label_23")
        self.gridLayout_2.addWidget(self.label_23, 0, 0, 1, 1)
        self.label_47 = QtWidgets.QLabel(self.verticalLayoutWidget_40)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_47.setFont(font)
        self.label_47.setObjectName("label_47")
        self.gridLayout_2.addWidget(self.label_47, 0, 2, 1, 1)
        self.verticalLayout_40.addLayout(self.gridLayout_2)
        self.scrollArea_10 = QtWidgets.QScrollArea(self.verticalLayoutWidget_40)
        self.scrollArea_10.setWidgetResizable(True)
        self.scrollArea_10.setObjectName("scrollArea_10")
        self.scrollAreaWidgetContents_10 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_10.setGeometry(QtCore.QRect(0, 0, 597, 219))
        self.scrollAreaWidgetContents_10.setObjectName("scrollAreaWidgetContents_10")
        self.scrollArea_10.setWidget(self.scrollAreaWidgetContents_10)
        self.verticalLayout_40.addWidget(self.scrollArea_10)
        self.label_46 = QtWidgets.QLabel(self.verticalLayoutWidget_40)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_46.setFont(font)
        self.label_46.setObjectName("label_46")
        self.verticalLayout_40.addWidget(self.label_46)
        self.verticalLayoutWidget_41 = QtWidgets.QWidget(self.tab)
        self.verticalLayoutWidget_41.setGeometry(QtCore.QRect(1120, 400, 601, 121))
        self.verticalLayoutWidget_41.setObjectName("verticalLayoutWidget_41")
        self.verticalLayout_41 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_41)
        self.verticalLayout_41.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_41.setObjectName("verticalLayout_41")
        self.pushButton_34 = QtWidgets.QPushButton(self.verticalLayoutWidget_41)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_34.setFont(font)
        self.pushButton_34.setObjectName("pushButton_34")
        self.verticalLayout_41.addWidget(self.pushButton_34)
        self.pushButton_35 = QtWidgets.QPushButton(self.verticalLayoutWidget_41)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_35.setFont(font)
        self.pushButton_35.setObjectName("pushButton_35")
        self.verticalLayout_41.addWidget(self.pushButton_35)
        self.tabWidget.addTab(self.tab, "")
        self.tab_3 = QtWidgets.QWidget()
        self.tab_3.setObjectName("tab_3")
        self.verticalLayoutWidget_8 = QtWidgets.QWidget(self.tab_3)
        self.verticalLayoutWidget_8.setGeometry(QtCore.QRect(10, 10, 1091, 71))
        self.verticalLayoutWidget_8.setObjectName("verticalLayoutWidget_8")
        self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_8)
        self.verticalLayout_7.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.label_12 = QtWidgets.QLabel(self.verticalLayoutWidget_8)
        font = QtGui.QFont()
        font.setPointSize(14)
        font.setBold(True)
        font.setWeight(75)
        self.label_12.setFont(font)
        self.label_12.setObjectName("label_12")
        self.verticalLayout_7.addWidget(self.label_12)
        self.pushButton_8 = QtWidgets.QPushButton(self.verticalLayoutWidget_8)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_8.setFont(font)
        self.pushButton_8.setObjectName("pushButton_8")
        self.verticalLayout_7.addWidget(self.pushButton_8)
        self.verticalLayoutWidget_31 = QtWidgets.QWidget(self.tab_3)
        self.verticalLayoutWidget_31.setGeometry(QtCore.QRect(1110, 10, 621, 501))
        self.verticalLayoutWidget_31.setObjectName("verticalLayoutWidget_31")
        self.verticalLayout_29 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_31)
        self.verticalLayout_29.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_29.setObjectName("verticalLayout_29")
        self.label_27 = QtWidgets.QLabel(self.verticalLayoutWidget_31)
        self.label_27.setObjectName("label_27")
        self.verticalLayout_29.addWidget(self.label_27)
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        self.comboBox = QtWidgets.QComboBox(self.verticalLayoutWidget_31)
        self.comboBox.setObjectName("comboBox")
        self.horizontalLayout_10.addWidget(self.comboBox)
        self.pushButton_36 = QtWidgets.QPushButton(self.verticalLayoutWidget_31)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_36.setFont(font)
        self.pushButton_36.setObjectName("pushButton_36")
        self.horizontalLayout_10.addWidget(self.pushButton_36)
        self.verticalLayout_29.addLayout(self.horizontalLayout_10)
        self.scrollArea = QtWidgets.QScrollArea(self.verticalLayoutWidget_31)
        self.scrollArea.setWidgetResizable(True)
        self.scrollArea.setObjectName("scrollArea")
        self.scrollAreaWidgetContents = QtWidgets.QWidget()
        self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 617, 437))
        self.scrollAreaWidgetContents.setObjectName("scrollAreaWidgetContents")
        self.scrollArea.setWidget(self.scrollAreaWidgetContents)
        self.verticalLayout_29.addWidget(self.scrollArea)
        self.verticalLayoutWidget_5 = QtWidgets.QWidget(self.tab_3)
        self.verticalLayoutWidget_5.setGeometry(QtCore.QRect(10, 90, 1091, 681))
        self.verticalLayoutWidget_5.setObjectName("verticalLayoutWidget_5")
        self.verticalLayout_8 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_5)
        self.verticalLayout_8.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.frame_8 = QtWidgets.QFrame(self.tab_3)
        self.frame_8.setGeometry(QtCore.QRect(1110, 530, 621, 231))
        self.frame_8.setAutoFillBackground(True)
        self.frame_8.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_8.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_8.setObjectName("frame_8")
        self.gridLayoutWidget = QtWidgets.QWidget(self.frame_8)
        self.gridLayoutWidget.setGeometry(QtCore.QRect(50, 20, 471, 131))
        self.gridLayoutWidget.setObjectName("gridLayoutWidget")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.gridLayoutWidget)
        self.gridLayout_3.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_3.setObjectName("gridLayout_3")
        self.label_53 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_53.setFont(font)
        self.label_53.setText("")
        self.label_53.setObjectName("label_53")
        self.gridLayout_3.addWidget(self.label_53, 0, 2, 1, 1)
        self.label_56 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.label_56.setFont(font)
        self.label_56.setObjectName("label_56")
        self.gridLayout_3.addWidget(self.label_56, 1, 1, 1, 1)
        self.label_52 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.label_52.setFont(font)
        self.label_52.setObjectName("label_52")
        self.gridLayout_3.addWidget(self.label_52, 0, 1, 1, 1)
        self.label_57 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_57.setFont(font)
        self.label_57.setText("")
        self.label_57.setObjectName("label_57")
        self.gridLayout_3.addWidget(self.label_57, 1, 2, 1, 1)
        self.label_54 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.label_54.setFont(font)
        self.label_54.setObjectName("label_54")
        self.gridLayout_3.addWidget(self.label_54, 2, 1, 1, 1)
        self.label_55 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_55.setFont(font)
        self.label_55.setText("")
        self.label_55.setObjectName("label_55")
        self.gridLayout_3.addWidget(self.label_55, 2, 2, 1, 1)
        self.label_58 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.label_58.setFont(font)
        self.label_58.setObjectName("label_58")
        self.gridLayout_3.addWidget(self.label_58, 3, 1, 1, 1)
        self.label_59 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QtGui.QFont()
        font.setPointSize(11)
        font.setBold(True)
        font.setWeight(75)
        self.label_59.setFont(font)
        self.label_59.setText("")
        self.label_59.setObjectName("label_59")
        self.gridLayout_3.addWidget(self.label_59, 3, 2, 1, 1)
        self.label_60 = QtWidgets.QLabel(self.frame_8)
        self.label_60.setGeometry(QtCore.QRect(10, 190, 601, 29))
        font = QtGui.QFont()
        font.setPointSize(11)
        self.label_60.setFont(font)
        self.label_60.setObjectName("label_60")
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap("../.designer/backup/run.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.tabWidget.addTab(self.tab_3, icon2, "")
        self.tab_4 = QtWidgets.QWidget()
        self.tab_4.setObjectName("tab_4")
        self.verticalLayoutWidget_9 = QtWidgets.QWidget(self.tab_4)
        self.verticalLayoutWidget_9.setGeometry(QtCore.QRect(10, 10, 501, 31))
        self.verticalLayoutWidget_9.setObjectName("verticalLayoutWidget_9")
        self.verticalLayout_14 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_9)
        self.verticalLayout_14.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_14.setObjectName("verticalLayout_14")
        self.label_14 = QtWidgets.QLabel(self.verticalLayoutWidget_9)
        font = QtGui.QFont()
        font.setPointSize(14)
        font.setBold(True)
        font.setWeight(75)
        self.label_14.setFont(font)
        self.label_14.setObjectName("label_14")
        self.verticalLayout_14.addWidget(self.label_14)
        self.verticalLayoutWidget_15 = QtWidgets.QWidget(self.tab_4)
        self.verticalLayoutWidget_15.setGeometry(QtCore.QRect(10, 380, 501, 361))
        self.verticalLayoutWidget_15.setObjectName("verticalLayoutWidget_15")
        self.verticalLayout_20 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_15)
        self.verticalLayout_20.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_20.setObjectName("verticalLayout_20")
        self.verticalLayoutWidget_18 = QtWidgets.QWidget(self.tab_4)
        self.verticalLayoutWidget_18.setGeometry(QtCore.QRect(10, 260, 551, 91))
        self.verticalLayoutWidget_18.setObjectName("verticalLayoutWidget_18")
        self.verticalLayout_23 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_18)
        self.verticalLayout_23.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_23.setObjectName("verticalLayout_23")
        self.lineEdit_5 = QtWidgets.QLineEdit(self.verticalLayoutWidget_18)
        self.lineEdit_5.setObjectName("lineEdit_5")
        self.verticalLayout_23.addWidget(self.lineEdit_5)
        self.pushButton_7 = QtWidgets.QPushButton(self.verticalLayoutWidget_18)
        font = QtGui.QFont()
        font.setPointSize(10)
        self.pushButton_7.setFont(font)
        self.pushButton_7.setObjectName("pushButton_7")
        self.verticalLayout_23.addWidget(self.pushButton_7)
        self.verticalLayoutWidget_14 = QtWidgets.QWidget(self.tab_4)
        self.verticalLayoutWidget_14.setGeometry(QtCore.QRect(10, 60, 571, 21))
        self.verticalLayoutWidget_14.setObjectName("verticalLayoutWidget_14")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_14)
        self.verticalLayout_4.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.label_2 = QtWidgets.QLabel(self.verticalLayoutWidget_14)
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setItalic(False)
        self.label_2.setFont(font)
        self.label_2.setAcceptDrops(False)
        self.label_2.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.label_2.setAutoFillBackground(False)
        self.label_2.setFrameShadow(QtWidgets.QFrame.Plain)
        self.label_2.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.label_2.setWordWrap(True)
        self.label_2.setObjectName("label_2")
        self.verticalLayout_4.addWidget(self.label_2)
        self.verticalLayoutWidget_20 = QtWidgets.QWidget(self.tab_4)
        self.verticalLayoutWidget_20.setGeometry(QtCore.QRect(10, 90, 571, 41))
        self.verticalLayoutWidget_20.setObjectName("verticalLayoutWidget_20")
        self.verticalLayout_9 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_20)
        self.verticalLayout_9.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_9.setObjectName("verticalLayout_9")
        self.label_6 = QtWidgets.QLabel(self.verticalLayoutWidget_20)
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setItalic(False)
        self.label_6.setFont(font)
        self.label_6.setWordWrap(True)
        self.label_6.setObjectName("label_6")
        self.verticalLayout_9.addWidget(self.label_6)
        self.verticalLayoutWidget_21 = QtWidgets.QWidget(self.tab_4)
        self.verticalLayoutWidget_21.setGeometry(QtCore.QRect(10, 150, 571, 51))
        self.verticalLayoutWidget_21.setObjectName("verticalLayoutWidget_21")
        self.verticalLayout_10 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_21)
        self.verticalLayout_10.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_10.setObjectName("verticalLayout_10")
        self.label_7 = QtWidgets.QLabel(self.verticalLayoutWidget_21)
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setItalic(False)
        self.label_7.setFont(font)
        self.label_7.setWordWrap(True)
        self.label_7.setObjectName("label_7")
        self.verticalLayout_10.addWidget(self.label_7)
        self.verticalLayoutWidget_22 = QtWidgets.QWidget(self.tab_4)
        self.verticalLayoutWidget_22.setGeometry(QtCore.QRect(10, 210, 521, 31))
        self.verticalLayoutWidget_22.setObjectName("verticalLayoutWidget_22")
        self.verticalLayout_11 = QtWidgets.QVBoxLayout(self.verticalLayoutWidget_22)
        self.verticalLayout_11.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_11.setObjectName("verticalLayout_11")
        self.label_4 = QtWidgets.QLabel(self.verticalLayoutWidget_22)
        font = QtGui.QFont()
        font.setFamily("Lucida Sans")
        font.setPointSize(9)
        font.setItalic(False)
        font.setUnderline(True)
        self.label_4.setFont(font)
        self.label_4.setAcceptDrops(False)
        self.label_4.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.label_4.setAutoFillBackground(False)
        self.label_4.setFrameShadow(QtWidgets.QFrame.Plain)
        self.label_4.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignTop)
        self.label_4.setWordWrap(True)
        self.label_4.setObjectName("label_4")
        self.verticalLayout_11.addWidget(self.label_4)
        icon3 = QtGui.QIcon()
        icon3.addPixmap(QtGui.QPixmap("../.designer/backup/settings.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.tabWidget.addTab(self.tab_4, icon3, "")
        self.verticalLayout.addWidget(self.tabWidget)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1763, 22))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)


        #########################################################################################################################################
        ##########################IMPORTANTE#####################################################################################################
        
        self.scroll_area_4_layout = QFormLayout(self.scrollAreaWidgetContents_4)
        self.scrollArea_6_layout = QFormLayout(self.scrollAreaWidgetContents_6)
        self.scrollArea_5_layout = QFormLayout(self.scrollAreaWidgetContents_5)
        self.scrollArea_7_layout = QFormLayout(self.scrollAreaWidgetContents_7)
        self.scrollArea_8_layout = QFormLayout(self.scrollAreaWidgetContents_8)
        self.scrollArea_9_layout = QFormLayout(self.scrollAreaWidgetContents_9)
        self.ScrollArea_layout = QFormLayout(self.scrollAreaWidgetContents)
        self.scrollArea_10_layout = QGridLayout(self.scrollAreaWidgetContents_10)
        ##self.scrollArea_layout = QFormLayout(self.scrollAreaWidgetContents)

        try:
            if os.path.isfile("Base_Datos_Clientes.txt"):
                base = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')

                if base.empty == False:
                    self.label_17.setText("Los clientes dentro de la base son:")
                    for i in range(base.shape[0]):
                        ID = base.loc[i,"ID"]
                        direccion = base.loc[i,"DIRECCION"]
                        self.display_in_scrollA(ID,direccion,self.scrollArea_6_layout)
        except:
            print('OK')
            
        try:
            if os.path.isfile("Base_Datos_Depots.txt"):
                base_dep = pd.read_csv('Base_Datos_Depots.txt', sep=';', encoding='latin-1')

                if base_dep.empty == False:
                    self.label_19.setText("Los clientes dentro de la base son:")
                    for i in range(base.shape[0]):
                        ID_dep = base_dep.loc[i,"ID"]
                        direccion_dep = base_dep.loc[i,"DIRECCION"]
                        self.display_in_scrollA(ID_dep,direccion_dep,self.scrollArea_7_layout)
        except:
            print('OK')

        try:
            if os.path.isfile("Base_Datos_vehiculos.txt"):
                base_veh = pd.read_csv('Base_Datos_vehiculos.txt', sep=';', encoding='latin-1')

                if base_veh.empty == False:
                    for i in range(base.shape[0]):
                        ID_veh = base_veh.loc[i,"ID"]
                        capacidad = base_veh.loc[i,"CAPACIDAD"]
                        self.display_in_scroll_spinbox_vehiculos(ID_veh,capacidad,self.scrollArea_8_layout)
        except:
            print('OK')
            
            


    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.label.setText(_translate("MainWindow", "Sistema Inteligente de Ruteo de Vehículos"))
        self.checkBox_3.setText(_translate("MainWindow", "Seleccionar/deseleccionar todos"))
        self.label_3.setText(_translate("MainWindow", "Clientes"))
        self.pushButton.setText(_translate("MainWindow", "Carga masiva de Clientes"))
        self.pushButton_4.setText(_translate("MainWindow", "Cargar Base de Clientes"))
        self.pushButton_2.setText(_translate("MainWindow", "Descargar Template"))
        self.label_8.setText(_translate("MainWindow", "Añadir cliente individual a base de datos"))
        self.label_16.setText(_translate("MainWindow", "ID:"))
        self.lineEdit.setPlaceholderText(_translate("MainWindow", "Uniandes"))
        self.label_18.setText(_translate("MainWindow", "Dirección:"))
        self.lineEdit_2.setPlaceholderText(_translate("MainWindow", "Carrera 1 18A 12, Bogotá, Colombia"))
        self.pushButton_14.setText(_translate("MainWindow", "Añadir Cliente a la Base"))
        self.pushButton_11.setText(_translate("MainWindow", "Guardar datos de clientes para ruteo"))
        self.pushButton_12.setText(_translate("MainWindow", "Añadir los clientes seleccionados a la base de datos"))
        self.pushButton_23.setText(_translate("MainWindow", "Limpiar ventana"))
        self.label_15.setText(_translate("MainWindow", "Base de Clientes"))
        self.pushButton_13.setText(_translate("MainWindow", "Mostrar Base de Clientes"))
        self.checkBox.setText(_translate("MainWindow", "Seleccionar/deseleccionar todos"))
        self.label_28.setText(_translate("MainWindow", "Añadir cliente individual a orden"))
        self.label_29.setText(_translate("MainWindow", "ID:"))
        self.lineEdit_7.setPlaceholderText(_translate("MainWindow", "Uniandes"))
        self.label_30.setText(_translate("MainWindow", "Dirección:"))
        self.lineEdit_8.setPlaceholderText(_translate("MainWindow", "Carrera 1 18A 12, Bogotá, Colombia"))
        self.pushButton_26.setText(_translate("MainWindow", "Añadir Cliente a la Orden"))
        self.pushButton_15.setText(_translate("MainWindow", "Limpiar ventana"))
        self.pushButton_16.setText(_translate("MainWindow", "Guardar cambios"))
        self.pushButton_9.setText(_translate("MainWindow", "Eliminar selección"))
        self.label_31.setText(_translate("MainWindow", "Ubicaciones de clientes"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_clientes), _translate("MainWindow", "Clientes"))
        self.label_5.setText(_translate("MainWindow", "Depósitos"))
        self.pushButton_3.setText(_translate("MainWindow", "Carga masiva depósitos"))
        self.pushButton_5.setText(_translate("MainWindow", "Cargar Base depósitos"))
        self.pushButton_6.setText(_translate("MainWindow", "Descargar Template"))
        self.checkBox_2.setText(_translate("MainWindow", "Seleccionar/deseleccionar todos"))
        self.pushButton_19.setText(_translate("MainWindow", "Guardar datos de depósito para ruteo"))
        self.pushButton_20.setText(_translate("MainWindow", "Añadir los depósitos seleccionados a la base de datos"))
        self.pushButton_24.setText(_translate("MainWindow", "Limpiar ventana"))
        self.checkBox_4.setText(_translate("MainWindow", "Seleccionar/deseleccionar todos"))
        self.label_37.setText(_translate("MainWindow", "Nota: Únicamente seleccione un depósito"))
        self.label_20.setText(_translate("MainWindow", "Base de Depósitos"))
        self.pushButton_21.setText(_translate("MainWindow", "Cargar Base de Depósitos"))
        self.label_9.setText(_translate("MainWindow", "Añadir depósito individual a base de datos"))
        self.label_21.setText(_translate("MainWindow", "ID:"))
        self.lineEdit_3.setPlaceholderText(_translate("MainWindow", "Uniandes"))
        self.label_22.setText(_translate("MainWindow", "Dirección:"))
        self.lineEdit_4.setPlaceholderText(_translate("MainWindow", "Carrera 1 18A 12, Bogotá, Colombia"))
        self.pushButton_22.setText(_translate("MainWindow", "Añadir Depósito a la Base"))
        self.label_34.setText(_translate("MainWindow", "Añadir depósito individual a la orden"))
        self.label_35.setText(_translate("MainWindow", "ID:"))
        self.lineEdit_11.setPlaceholderText(_translate("MainWindow", "Uniandes"))
        self.label_36.setText(_translate("MainWindow", "Dirección:"))
        self.lineEdit_12.setPlaceholderText(_translate("MainWindow", "Carrera 1 18A 12, Bogotá, Colombia"))
        self.pushButton_28.setText(_translate("MainWindow", "Añadir Depósito a la orden"))
        self.pushButton_18.setText(_translate("MainWindow", "Limpiar Ventana"))
        self.pushButton_17.setText(_translate("MainWindow", "Guardar Cambios"))
        self.pushButton_29.setText(_translate("MainWindow", "Eliminar selección"))
        self.label_32.setText(_translate("MainWindow", "Ubicaciones"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.depots_tab), _translate("MainWindow", "Depósitos"))
        self.label_25.setText(_translate("MainWindow", "Vehículos"))
        self.label_26.setText(_translate("MainWindow", "Los vehículos guardados son:"))
        self.checkBox_6.setText(_translate("MainWindow", "Seleccionar/deseleccionar todos"))
        self.label_42.setText(_translate("MainWindow", "Nota: Únicamente seleccione un vehículo."))
        self.label_38.setText(_translate("MainWindow", "Añadir vehículo"))
        self.label_39.setText(_translate("MainWindow", "ID:"))
        self.lineEdit_13.setPlaceholderText(_translate("MainWindow", "Vehículo 1"))
        self.label_40.setText(_translate("MainWindow", "Capacidad"))
        self.pushButton_30.setText(_translate("MainWindow", "Añadir vehículo"))
        self.pushButton_32.setText(_translate("MainWindow", "Guardar vehículo para ruteo"))
        self.pushButton_27.setText(_translate("MainWindow", "Guardar cambios"))
        self.pushButton_25.setText(_translate("MainWindow", "Eliminar selección"))
        self.label_33.setText(_translate("MainWindow", "Demandas"))
        self.label_41.setText(_translate("MainWindow", "Ingrese la demanda de cada cliente"))
        self.label_44.setText(_translate("MainWindow", "Ingrese únicamente números."))
        self.pushButton_33.setText(_translate("MainWindow", "Guardar demandas"))
        self.pushButton_31.setText(_translate("MainWindow", "Limpiar ventana"))
        self.label_43.setText(_translate("MainWindow", "Ventanas de Tiempo"))
        self.label_45.setText(_translate("MainWindow", "Ingrese los tiempos de servicio de cada cliente"))
        self.label_24.setText(_translate("MainWindow", "Hora inicio"))
        self.label_23.setText(_translate("MainWindow", "ID"))
        self.label_47.setText(_translate("MainWindow", "Hora Fin"))
        self.label_46.setText(_translate("MainWindow", "Ingrese únicamente números."))
        self.pushButton_34.setText(_translate("MainWindow", "Guardar ventanas de tiempo"))
        self.pushButton_35.setText(_translate("MainWindow", "Limpiar ventana"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("MainWindow", "Vehículos/Restricciones"))
        self.label_12.setText(_translate("MainWindow", "Ruteo"))
        self.pushButton_8.setText(_translate("MainWindow", "Establecer condiciones de ruteo"))
        self.label_27.setText(_translate("MainWindow", "Seleccione la ruta a mostrar:"))
        self.pushButton_36.setText(_translate("MainWindow", "Actualizar"))
        self.label_56.setText(_translate("MainWindow", "Distancia (kilometros):"))
        self.label_52.setText(_translate("MainWindow", "Distancia (metros):"))
        self.label_54.setText(_translate("MainWindow", "Tiempo prom. (minutos):"))
        self.label_58.setText(_translate("MainWindow", "Tiempo prom. (horas):"))
        self.label_60.setText(_translate("MainWindow", "Nota: Se asume una velocidad promedio de 60 km/h."))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_3), _translate("MainWindow", "Ruteo"))
        self.label_14.setText(_translate("MainWindow", "Opciones de corrida"))
        self.pushButton_7.setText(_translate("MainWindow", "Cambiar Ubicación"))
        self.label_2.setText(_translate("MainWindow", "La ubicación por default se encuentra en Bogotá, Colombia."))
        self.label_6.setText(_translate("MainWindow", "Si desea cambiar la locación, esto tomará un poco de tiempo."))
        self.label_7.setText(_translate("MainWindow", "Por favor ingrese a continuación la nueva ubicación con el siguiente formato:"))
        self.label_4.setText(_translate("MainWindow", "Ciudad, Departamento/Estado, País"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_4), _translate("MainWindow", "Ajustes"))

        ########################################## INTERFAZ ARRIBA ##################################################
        
        self.data_clientes = pd.DataFrame()
        self.data_deposito = pd.DataFrame()
        self.data_tiempos = pd.DataFrame()
        self.data_cargas = pd.DataFrame()
        self.data_vehiculo = pd.DataFrame()

        #Crear geolocator y mapa
        self.geolocator = ArcGIS()
        self.graph_area = "Bogotá, Distrito Capital, Colombia"
        self.G = ox.graph_from_place(self.graph_area, network_type='drive', simplify=True)
        # OSM data are sometime incomplete so we use the speed module of osmnx to add missing edge speeds and travel times
        self.G = ox.add_edge_speeds(self.G)
        self.G = ox.add_edge_travel_times(self.G)        
        
        
        #Set up mapa depots
        self.web_view_depots = QWebEngineView()
        self.verticalLayout_31.addWidget(self.web_view_depots)
        # Set up Folium map- inicializacion
        # self.map = folium.Map(location=[4.6097, -74.06508], zoom_start=12)
        self.map_depots = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
        # Convert Folium map to HTML and display in web view
        self.html_depots = self.map_depots._repr_html_()
        self.web_view_depots.setHtml(self.html_depots)
        
        #Set up mapa clientes
        self.web_view_clientes = QWebEngineView()
        self.verticalLayout_27.addWidget(self.web_view_clientes)
        # Set up Folium map- inicializacion
        # self.map = folium.Map(location=[4.6097, -74.06508], zoom_start=12)
        self.map_clientes = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
        # Convert Folium map to HTML and display in web view
        self.html_clientes = self.map_clientes._repr_html_()
        self.web_view_clientes.setHtml(self.html_clientes)
        
        # Set up de mapa inicial ruteo
        self.web_view = QWebEngineView()
        self.verticalLayout_8.addWidget(self.web_view)
        # Set up Folium map- inicializacion
        # self.map = folium.Map(location=[4.60302, -74.06508], zoom_start=12)
        self.map = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
        # Convert Folium map to HTML and display in web view
        self.html = self.map._repr_html_()
        self.web_view.setHtml(self.html)
        
        #### Matrices
        self.matriz_distancias = []
        self.base_lat_lon = []
        self.capacidad_vehiculo = 99999999999999999999
        #Velocidad promedio 1000 m/min o 60km/h
        self.vel_promedio = 1000

        self.camino_sublistas =  []
        self.camino_entero = []

        self.mapa_completo = []

        self.subset_lat_lon = []
        
        #Link a botones-acciones
        self.pushButton.clicked.connect(self.carga_masiva_clientes)
        self.pushButton_4.clicked.connect(self.cargar_base_clientes)
        self.pushButton_2.clicked.connect(self.descargar_template_clientes)
        self.pushButton_23.clicked.connect(self.clear_layout_clientes)
        self.pushButton_12.clicked.connect(self.escribir_sobre_base_clientes)
        self.pushButton_11.clicked.connect(self.extraer_clientes_corrida)
        self.pushButton_13.clicked.connect(self.display_base_clientes)
        self.pushButton_16.clicked.connect(self.guardar_cambios_clientes)
        self.pushButton_15.clicked.connect(self.clear_layout_base_clientes)
        self.pushButton_26.clicked.connect(self.anadir_cliente_ind_orden)
        self.pushButton_14.clicked.connect(self.anadir_cliente_ind_base)
        self.pushButton_9.clicked.connect(self.eliminar_clientes)
        self.pushButton_3.clicked.connect(self.carga_masiva_depositos)
        self.pushButton_5.clicked.connect(self.cargar_base_depots)
        self.pushButton_6.clicked.connect(self.descargar_template_depots)
        self.pushButton_20.clicked.connect(self.escribir_sobre_base_depots)
        self.pushButton_24.clicked.connect(self.clear_layout_depots)
        self.pushButton_21.clicked.connect(self.display_base_depots)
        self.pushButton_17.clicked.connect(self.guardar_cambios_depots)
        self.pushButton_18.clicked.connect(self.clear_layout_base_depots)
        self.pushButton_29.clicked.connect(self.eliminar_depots)
        self.pushButton_28.clicked.connect(self.anadir_depot_ind_orden)
        self.pushButton_22.clicked.connect(self.anadir_depot_ind_base)
        self.pushButton_19.clicked.connect(self.extraer_deposito_corrida)
        self.pushButton_8.clicked.connect(self.abrir_opciones_correr)
        self.pushButton_7.clicked.connect(self.cambiar_ubicacion)
        self.pushButton_30.clicked.connect(self.agregar_vehiculo)
        self.pushButton_27.clicked.connect(self.guardar_cambios_vehiculos)
        self.pushButton_25.clicked.connect(self.eliminar_vehiculos)
        self.pushButton_31.clicked.connect(self.clear_layout_carga)
        self.pushButton_32.clicked.connect(self.extraer_capacidad_vehiculo)
        self.pushButton_33.clicked.connect(self.extraer_df_cargas)
        self.pushButton_34.clicked.connect(self.crear_dataframe_tiempos)
        self.pushButton_35.clicked.connect(self.clear_layout_tiempos)
        self.pushButton_36.clicked.connect(self.actualizar_resultado)



        self.checkBox.stateChanged.connect(self.seleccionar_todos_clientes_base)
        self.checkBox_3.stateChanged.connect(self.seleccionar_todos_clientes)
        self.checkBox_4.stateChanged.connect(self.seleccionar_todos_depots)
        self.checkBox_2.stateChanged.connect(self.seleccionar_todos_depots_base)
        self.checkBox_6.stateChanged.connect(self.seleccionar_todos_vehiculos)

        #self.comboBox.currentIndexChanged.connect(self.actualizar_resultado)
        
        
        #########################################################################################################################
        ############################### TAB CLIENTES ############################################################################
        #########################################################################################################################
        
    def carga_masiva_clientes(self):
        # open file dialog to select CSV file
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        fileFilters = "Text Files (*.txt);;All Files (*)"
        self.file_path, _ = QFileDialog.getOpenFileName(self, "Open File", "", fileFilters, options=options)
        try:    
            if self.file_path:
                direcciones_clientes = pd.read_csv(self.file_path, sep=';')
                if direcciones_clientes.shape[1] == 2:
                    self.checkboxes = []
                    comunes = []
                    self.label_10.setText("Los clientes de la orden son:")
                    for i in range(direcciones_clientes.shape[0]):
                        ID = direcciones_clientes.loc[i,"ID"]
                        direccion = direcciones_clientes.loc[i,"DIRECCION"]
                        geo_punto = self.geolocator.geocode(direccion, timeout=180)
                        if geo_punto:
                            self.display_in_scrollA(ID,direccion,self.scroll_area_4_layout)
                        else:
                            n = i + 1
                            string = ID + ' (Linea ' + str(n) + ')'
                            comunes.append(string)
                    if len(comunes) > 0:
                            array_str = ', '.join(str(elem) for elem in comunes)
                            text = f'Los siguientes IDs tienen una dirección inválida: {array_str}'
                            QMessageBox.warning(self, "Warning", text)
                    # else:
                    #     df_temp = self.crear_dataframe_clientes()
                        
                    #     self.df_lat_lon_clientes = sacar_lat_lon_clientes(df_temp,self.geolocator,self.G)
                    #     index_list = self.df_lat_lon_clientes.index.values.tolist()
                    #     m_temp = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
                    #     for i in range(0,self.df_lat_lon_clientes.shape[0]):
                    #         folium.Marker(location=[self.df_lat_lon_clientes.iloc[i]['lat'], self.df_lat_lon_clientes.iloc[i]['lon']], popup=index_list[i]).add_to(m_temp)
                    #     self.html_clientes = m_temp._repr_html_()
                    #     self.web_view_clientes.setHtml(self.html_clientes)
                else: 
                    QMessageBox.warning(self, "Warning", "Revise que el archivo cargado cumple con el formato")
            else:
                self.label_10.setText("Cargue un archivo válido:")
        except:
            QMessageBox.warning(self, "Warning", "Verifique que el archivo cargado cumple con los requisitos")
            
    def display_in_scrollA(self,name, direction, scrollA):
        # layout = QHBoxLayout()

        checkbox = QCheckBox(name, self)
        checkbox.setObjectName(name)
        checkbox.setChecked(True)
        fc = checkbox.font()
        fc.setPointSize(7)
        checkbox.setFont(fc)

        lineedit = QLineEdit(direction)
        lineedit.setObjectName(name)
        f = lineedit.font()
        f.setPointSize(7)
        lineedit.setFont(f)
        
        scrollA.addRow(checkbox, lineedit)

    def display_in_scroll_con_carga_masiva(self,name, carga, scrollA):
        # layout = QHBoxLayout()

        checkbox = QCheckBox(name, self)
        checkbox.setObjectName(name)
        checkbox.setChecked(True)
        checkbox.setEnabled(False)
        fc = checkbox.font()
        fc.setPointSize(7)
        checkbox.setFont(fc)

        lineedit = QLineEdit()
        lineedit.setObjectName(name)
        lineedit.setText(str(carga))
        f = lineedit.font()
        f.setPointSize(7)
        lineedit.setFont(f)
        
        scrollA.addRow(checkbox, lineedit)

    def cargar_base_clientes(self):
        if os.path.isfile("Base_Datos_Clientes.txt"):
            direcciones_clientes = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
            self.checkboxes = []

            if direcciones_clientes.empty == False:
                self.label_10.setText("Seleccione los clientes para la orden:")
                for i in range(direcciones_clientes.shape[0]):
                    ID = direcciones_clientes.loc[i,"ID"]
                    direccion = direcciones_clientes.loc[i,"DIRECCION"]
                    self.display_in_scrollA(ID,direccion,self.scroll_area_4_layout)  
            else:
                QMessageBox.warning(self, "Warning", "La base de datos está vacia")
            return
        else:
            QMessageBox.warning(self, "Warning", "No existe base de datos")
        return

    def clear_layout_clientes(self):
        n = self.scroll_area_4_layout.rowCount()
        if n >0:
            for i in reversed(range(n)):
                self.scroll_area_4_layout.removeRow(i)          
        self.map_clientes = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
        # Convert Folium map to HTML and display in web view
        self.html_clientes = self.map_clientes._repr_html_()
        self.web_view_clientes.setHtml(self.html_clientes)
                         
    def descargar_template_clientes(self):
        # Get the URL of the file to download
        with open('Template Agregar Clientes.txt', 'w') as f:
            f.write("Para agregar clientes de forma masiva debe ingresarlos con el siguiente formato en un archivo .txt, separado por punto y coma:")
            f.write('\n')
            f.write('\n')
            f.write("Ejemplo 1: Clientes sin demanda/carga")
            f.write('\n')
            f.write("ID;DIRECCION")
            f.write("Uniandes;Carrera 1 18A 12, Bogotá, Colombia")
            f.write('\n')
            f.write("Nota: Agregue únicamente un cliente por linea. Dejar en la primera linea 'ID;DIRECCION'")
        QMessageBox.information(self, "Information", "El template fue descargado en la misma carpeta que la aplicación.")
            
    def crear_dataframe_clientes(self):
        items = self.scrollArea_4.findChildren(QWidget)
        data = []
        for item in items:
            if isinstance(item, QCheckBox) and item.isChecked():
                name = item.objectName()
                direction = item.parent().findChild(QLineEdit, name).text()
                data.append([name, direction])

        df = pd.DataFrame(data, columns=["ID", "DIRECCION"])
        return(df)   
    
    def extraer_clientes_corrida(self):
        self.data_clientes = self.crear_dataframe_clientes()
        if self.data_clientes.empty:
            QMessageBox.warning(self, "Warning", "Debe seleccionar al menos un cliente para la corrida")
        else:
            self.clear_layout_carga()
            self.clear_layout_tiempos()
            for i in range(self.data_clientes.shape[0]):
                ID = self.data_clientes.loc[i, "ID"]
                self.display_in_scroll_cargas(ID, self.scrollArea_9_layout)

            # Display en scroll tiempos
            for i in range(self.data_clientes.shape[0]):
                ID = self.data_clientes.loc[i, "ID"]

                checkbox = QCheckBox(ID,self)
                checkbox.setObjectName(ID)
                checkbox.setChecked(True)
                checkbox.setEnabled(False)
                fc = checkbox.font()
                fc.setPointSize(7)
                checkbox.setFont(fc)

                time_inicio = QTimeEdit()
                nombre_inicio = ID + "_inicio" 
                time_inicio.setObjectName(nombre_inicio)
                fc = time_inicio.font()
                fc.setPointSize(7)
                time_inicio.setFont(fc)

                time_fin = QTimeEdit()
                nombre_fin = ID + "_fin" 
                time_fin.setObjectName(nombre_fin)
                fc = time_fin.font()
                fc.setPointSize(7)
                time_fin.setFont(fc)

                self.scrollArea_10_layout.addWidget(checkbox, i, 0)
                self.scrollArea_10_layout.addWidget(time_inicio, i, 1)
                self.scrollArea_10_layout.addWidget(time_fin, i, 2)

                if os.path.isfile("Base_lat_lon.txt"):
                    try:
                        base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep = ";", index_col = 0, encoding='latin-1')
                        self.df_lat_lon_clientes = base_lat_lon.loc[self.data_clientes["ID"]]
                        index_list = self.df_lat_lon_clientes.index.values.tolist()
                        m_temp = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
                        for i in range(0,self.df_lat_lon_clientes.shape[0]):
                            folium.Marker(location=[self.df_lat_lon_clientes.iloc[i]['lat'], self.df_lat_lon_clientes.iloc[i]['lon']], popup=index_list[i]).add_to(m_temp)
                        self.html_clientes = m_temp._repr_html_()
                        self.web_view_clientes.setHtml(self.html_clientes)
                    except:
                        self.df_lat_lon_clientes = sacar_lat_lon_clientes(self.data_clientes,self.geolocator,self.G)
                        index_list = self.df_lat_lon_clientes.index.values.tolist()
                        m_temp = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
                        for i in range(0,self.df_lat_lon_clientes.shape[0]):
                            folium.Marker(location=[self.df_lat_lon_clientes.iloc[i]['lat'], self.df_lat_lon_clientes.iloc[i]['lon']], popup=index_list[i]).add_to(m_temp)
                        self.html_clientes = m_temp._repr_html_()
                        self.web_view_clientes.setHtml(self.html_clientes)

                else:
                    self.df_lat_lon_clientes = sacar_lat_lon_clientes(self.data_clientes,self.geolocator,self.G)
                    index_list = self.df_lat_lon_clientes.index.values.tolist()
                    m_temp = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
                    for i in range(0,self.df_lat_lon_clientes.shape[0]):
                        folium.Marker(location=[self.df_lat_lon_clientes.iloc[i]['lat'], self.df_lat_lon_clientes.iloc[i]['lon']], popup=index_list[i]).add_to(m_temp)
                    self.html_clientes = m_temp._repr_html_()
                    self.web_view_clientes.setHtml(self.html_clientes)

            QMessageBox.information(self, "Information", "El/Los Clientes han sido guardados, puede continuar.")
         
    def escribir_sobre_base_clientes(self):
        QMessageBox.information(self, "Information", "A continuación almacenará los clientes a la base de datos y guardará su distancia entre ellos mismos, esto tomará un poco de tiempo.\nPor favor, no oprima ningún botón hasta que el sistema indique que los clientes fueron agregados a la base ")
        df = self.crear_dataframe_clientes()
        self.base_lat_lon = sacar_lat_lon_clientes(df,self.geolocator,self.G)
        if df.empty == False:
            if os.path.isfile("Base_Datos_Clientes.txt"):
                base = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
                common_elements = base[base['ID'].isin(df['ID'])]['ID']
                if common_elements.empty == False:
                    array_str = ', '.join(str(elem) for elem in common_elements)
                    text = f'Los siguientes IDs ya se encuentran en la base de datos: {array_str}'
                    QMessageBox.warning(self, "Warning", text)
                else:

                    f = open('Base_Datos_Clientes.txt', "a")
                    f.write("\n")
                    for index, row in df.iterrows():
                        f.write(row["ID"] + ";" + row["DIRECCION"] + "\n")
                    f.close()

                    #Escribir en base de lat lon 
                    if os.path.isfile("Base_lat_lon.txt"):
                        with open("Base_lat_lon.txt", mode="a") as f:
                            self.base_lat_lon.to_csv(f, sep=";", header=False)
                    else:
                        self.base_lat_lon.to_csv("Base_lat_lon.txt", sep=";", index=True)

                    if os.path.isfile("matriz_distancias.txt"):
                        matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                        base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                        derecha_temporal = pd.DataFrame(index = matriz_distancias.index, columns = df['ID'])
                        for fila in matriz_distancias.index:
                            nodoA = base_lat_lon.loc[fila,'nodo']
                            for col in df['ID']:
                                nodoB = base_lat_lon.loc[col,'nodo']
                                try:
                                    distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                    derecha_temporal.loc[fila,col] = distancia
                                except:
                                    distancia = "NoDisponible"
                                    derecha_temporal.loc[fila,col] = distancia

                        abajo_temporal = pd.DataFrame(index = df['ID'], columns = matriz_distancias.index)
                        for fila in df['ID']:
                            nodoA = base_lat_lon.loc[fila,'nodo']
                            for col in matriz_distancias.index:
                                nodoB = base_lat_lon.loc[col,'nodo']
                                try:
                                    distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                    abajo_temporal.loc[fila,col] = distancia
                                except:
                                    distancia = "NoDisponible"
                                    abajo_temporal.loc[fila,col] = distancia

                        identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                        concat1 = pd.concat([matriz_distancias, abajo_temporal])
                        concat2 = pd.concat([derecha_temporal, identidad_temporal])

                        nueva_matriz = pd.concat([concat1, concat2], axis = 1)

                        ids_NoDisponibles = []
                        for fila in nueva_matriz.index:
                            conteo = 0
                            # Iterar sobre las columnas del DataFrame
                            for col in nueva_matriz.index:
                                if nueva_matriz.loc[fila,col] == "NoDisponible":
                                    conteo += 1
                            if conteo == nueva_matriz.shape[1] -1:
                                ids_NoDisponibles.append(fila)

                        if len(ids_NoDisponibles) > 0:
                            nueva_matriz = nueva_matriz.drop(ids_NoDisponibles, axis = 1)
                            nueva_matriz = nueva_matriz.drop(ids_NoDisponibles)
                            array_str = ', '.join(str(elem) for elem in ids_NoDisponibles)
                            text = f'Los siguientes IDs tienen una dirección fuera de la geografía delimitada: {array_str}. \n Por favor revise'
                            QMessageBox.warning(self, "Warning", text)

                            base_clientes = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
                            base_clientes = base_clientes.drop(ids_NoDisponibles)
                            base_clientes.to_csv('Base_Datos_Clientes.txt', index = True, sep=';')

                            base_lat_lon = pd.read_csv('Base_lat_lon.txt', sep=';', encoding='latin-1')
                            base_lat_lon = base_lat_lon.drop(ids_NoDisponibles)
                            base_lat_lon.to_csv('Base_lat_lon.txt', index = True, sep=';')


                        nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                        QMessageBox.information(self, "Information", "El/Los clientes han sido agregados a la base de datos")
                    else:
                        nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                        ids_NoDisponibles = []
                        for fila in nueva_matriz.index:
                            conteo = 0
                            # Iterar sobre las columnas del DataFrame
                            for col in nueva_matriz.index:
                                if nueva_matriz.loc[fila,col] == "NoDisponible":
                                    conteo += 1
                            if conteo == nueva_matriz.shape[1] -1:
                                ids_NoDisponibles.append(fila)

                        if len(ids_NoDisponibles) > 0:
                            nueva_matriz = nueva_matriz.drop(ids_NoDisponibles, axis = 1)
                            nueva_matriz = nueva_matriz.drop(ids_NoDisponibles)
                            array_str = ', '.join(str(elem) for elem in ids_NoDisponibles)
                            text = f'Los siguientes IDs tienen una dirección fuera de la geografía delimitada: {array_str}'
                            QMessageBox.warning(self, "Warning", text)

                            base_clientes = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
                            base_clientes = base_clientes.drop(ids_NoDisponibles)
                            base_clientes.to_csv('Base_Datos_Clientes.txt', index = True, sep=';')

                            base_lat_lon = pd.read_csv('Base_lat_lon.txt', sep=';', encoding='latin-1')
                            base_lat_lon = base_lat_lon.drop(ids_NoDisponibles)
                            base_lat_lon.to_csv('Base_lat_lon.txt', index = True, sep=';')

                        nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')    
                        QMessageBox.information(self, "Information", "El/Los clientes han sido agregados a la base de datos")  

                    self.clear_layout_clientes()
                    self.clear_layout_base_clientes()
                    time.sleep(0.02)
                    self.display_base_clientes()
            else:
                f = open('Base_Datos_Clientes.txt', "a")
                f.write("ID;DIRECCION")
                f.write("\n")
                for index, row in df.iterrows():
                    f.write(row["ID"] + ";" + row["DIRECCION"] + "\n")
                f.close()
                
                if os.path.isfile("Base_lat_lon.txt"):
                    with open("Base_lat_lon.txt", mode="a") as f:
                        self.base_lat_lon.to_csv(f, sep=";", header=False)
                else:
                    self.base_lat_lon.to_csv("Base_lat_lon.txt", sep=";", index=True)
                
                if os.path.isfile("matriz_distancias.txt"):
                    matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                    base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                    derecha_temporal = pd.DataFrame(index = matriz_distancias.index, columns = df['ID'])
                    for fila in matriz_distancias.index:
                        nodoA = base_lat_lon.loc[fila,'nodo']
                        for col in df['ID']:
                            nodoB = base_lat_lon.loc[col,'nodo']
                            try:
                                distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                derecha_temporal.loc[fila,col] = distancia
                            except:
                                distancia = "NoDisponible"
                                derecha_temporal.loc[fila,col] = distancia

                    abajo_temporal = pd.DataFrame(index = df['ID'], columns = matriz_distancias.index)
                    for fila in df['ID']:
                        nodoA = base_lat_lon.loc[fila,'nodo']
                        for col in matriz_distancias.index:
                            nodoB = base_lat_lon.loc[col,'nodo']
                            try:
                                distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                abajo_temporal.loc[fila,col] = distancia
                            except:
                                distancia = "NoDisponible"
                                abajo_temporal.loc[fila,col] = distancia

                    identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                    concat1 = pd.concat([matriz_distancias, abajo_temporal])
                    concat2 = pd.concat([derecha_temporal, identidad_temporal])

                    nueva_matriz = pd.concat([concat1, concat2], axis = 1)

                    ids_NoDisponibles = []
                    for fila in nueva_matriz.index:
                        conteo = 0
                        # Iterar sobre las columnas del DataFrame
                        for col in nueva_matriz.index:
                            if nueva_matriz.loc[fila,col] == "NoDisponible":
                                conteo += 1
                        if conteo == nueva_matriz.shape[1] -1:
                            ids_NoDisponibles.append(fila)

                    if len(ids_NoDisponibles) > 0:
                        nueva_matriz = nueva_matriz.drop(ids_NoDisponibles, axis = 1)
                        nueva_matriz = nueva_matriz.drop(ids_NoDisponibles)
                        array_str = ', '.join(str(elem) for elem in ids_NoDisponibles)
                        text = f'Los siguientes IDs tienen una dirección fuera de la geografía delimitada: {array_str}. \n Por favor revise'
                        QMessageBox.warning(self, "Warning", text)

                        base_clientes = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
                        base_clientes = base_clientes.drop(ids_NoDisponibles)
                        base_clientes.to_csv('Base_Datos_Clientes.txt', index = True, header = True, sep=';')

                        base_lat_lon = pd.read_csv('Base_lat_lon.txt', sep=';', encoding='latin-1')
                        base_lat_lon = base_lat_lon.drop(ids_NoDisponibles)
                        base_lat_lon.to_csv('Base_lat_lon.txt', index = True, header = True, sep=';')


                    nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')

                    QMessageBox.information(self, "Information", "El/Los clientes han sido agregados a la base de datos")
                else:
                    nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                    nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')  
                    ids_NoDisponibles = []
                    for fila in nueva_matriz.index:
                        conteo = 0
                        # Iterar sobre las columnas del DataFrame
                        for col in nueva_matriz.index:
                            if nueva_matriz.loc[fila,col] == "NoDisponible":
                                conteo += 1
                        if conteo == nueva_matriz.shape[1] -1:
                            ids_NoDisponibles.append(fila)

                    if len(ids_NoDisponibles) > 0:
                        nueva_matriz = nueva_matriz.drop(ids_NoDisponibles, axis = 1)
                        nueva_matriz = nueva_matriz.drop(ids_NoDisponibles)
                        array_str = ', '.join(str(elem) for elem in ids_NoDisponibles)
                        text = f'Los siguientes IDs tienen una dirección fuera de la geografía delimitada: {array_str}'
                        QMessageBox.warning(self, "Warning", text)

                        base_clientes = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
                        base_clientes = base_clientes.drop(ids_NoDisponibles)
                        base_clientes.to_csv('Base_Datos_Clientes.txt', index = True, sep=';')

                        base_lat_lon = pd.read_csv('Base_lat_lon.txt', sep=';', encoding='latin-1')
                        base_lat_lon = base_lat_lon.drop(ids_NoDisponibles)
                        base_lat_lon.to_csv('Base_lat_lon.txt', index = True, sep=';')

                    nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')                  
                    QMessageBox.information(self, "Information", "El/Los clientes han sido agregados a la base de datos")
                self.clear_layout_clientes()
                self.clear_layout_base_clientes()
                time.sleep(0.02)
                self.display_base_clientes()
        else:
            QMessageBox.warning(self, "Warning", "Debe seleccionar al menos un cliente para ser guardado en la base de datos")
        
    def display_base_clientes(self):
        if os.path.isfile("Base_Datos_Clientes.txt"):
            base = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
            self.checkboxes_base_clientes = []

            if base.empty == False:
                self.label_17.setText("Los clientes dentro de la base son:")
                for i in range(base.shape[0]):
                    ID = base.loc[i,"ID"]
                    direccion = base.loc[i,"DIRECCION"]
                    self.display_in_scrollA(ID,direccion,self.scrollArea_6_layout)  
            else:
                QMessageBox.warning(self, "Warning", "La base de datos está vacia")
            return
        else:
            QMessageBox.warning(self, "Warning", "No existen registros en la base")
        return
     
    def guardar_cambios_clientes(self):
        QMessageBox.information(self, "Information", "A continuación guardará los cambios y actualizará la base de datos, esto tomará un poco de tiempo. \nPor favor, no oprima ningún botón hasta que el sistema indique que los datos fueron guardados")
        items = self.scrollArea_6.findChildren(QWidget)
        data = []
        if items is not None:
            for item in items:
                if isinstance(item, QCheckBox):
                    name = item.objectName()
                    direction = item.parent().findChild(QLineEdit, name).text()
                    data.append([name, direction])

            df = pd.DataFrame(data, columns=["ID", "DIRECCION"])
            f = open('Base_Datos_Clientes.txt', "w")
            f.write("ID;DIRECCION")
            f.write("\n")
            for index, row in df.iterrows():
                f.write(row["ID"] + ";" + row["DIRECCION"] + "\n")
            f.close()

            try:
                self.base_lat_lon = sacar_lat_lon_clientes(df,self.geolocator,self.G)
                #Escribir en base de lat lon 
                if os.path.isfile("Base_lat_lon.txt"):
                    base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                    mascara = ~base_lat_lon.index.isin(df['ID'])
                    base_filtrada = base_lat_lon[mascara]
                    nueva_base = pd.concat([base_filtrada, self.base_lat_lon])
                    nueva_base.to_csv("Base_lat_lon.txt", sep=";", index=True)

                if os.path.isfile("matriz_distancias.txt"):
                    matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                    if matriz_distancias.empty == True:
                        nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                        ids_NoDisponibles = []
                        for fila in nueva_matriz.index:
                            conteo = 0
                            # Iterar sobre las columnas del DataFrame
                            for col in nueva_matriz.index:
                                if nueva_matriz.loc[fila,col] == "NoDisponible":
                                    conteo += 1
                            if conteo == nueva_matriz.shape[1] -1:
                                ids_NoDisponibles.append(fila)

                        if len(ids_NoDisponibles) > 0:
                            nueva_matriz = nueva_matriz.drop(ids_NoDisponibles, axis = 1)
                            nueva_matriz = nueva_matriz.drop(ids_NoDisponibles)
                            array_str = ', '.join(str(elem) for elem in ids_NoDisponibles)
                            text = f'Los siguientes IDs tienen una dirección fuera de la geografía delimitada: {array_str}'
                            QMessageBox.warning(self, "Warning", text)

                            base_clientes = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
                            base_clientes = base_clientes.drop(ids_NoDisponibles)
                            base_clientes.to_csv('Base_Datos_Clientes.txt', index = True, sep=';')

                            base_lat_lon = pd.read_csv('Base_lat_lon.txt', sep=';', encoding='latin-1')
                            base_lat_lon = base_lat_lon.drop(ids_NoDisponibles)
                            base_lat_lon.to_csv('Base_lat_lon.txt', index = True, sep=';')

                        nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                    else:
                        submatriz_depots = matriz_distancias.drop(index = df['ID'], columns = df['ID'])

                        base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                        derecha_temporal = pd.DataFrame(index = submatriz_depots.index, columns = df['ID'])
                        for fila in submatriz_depots.index:
                            nodoA = base_lat_lon.loc[fila,'nodo']
                            for col in df['ID']:
                                nodoB = base_lat_lon.loc[col,'nodo']
                                try:
                                    distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                    derecha_temporal.loc[fila,col] = distancia
                                except:
                                    distancia = "NoDisponible"
                                    derecha_temporal.loc[fila,col] = distancia

                        abajo_temporal = pd.DataFrame(index = df['ID'], columns = submatriz_depots.index)
                        for fila in df['ID']:
                            nodoA = base_lat_lon.loc[fila,'nodo']
                            for col in submatriz_depots.index:
                                nodoB = base_lat_lon.loc[col,'nodo']
                                try:
                                    distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                    abajo_temporal.loc[fila,col] = distancia
                                except:
                                    distancia = "NoDisponible"
                                    abajo_temporal.loc[fila,col] = distancia

                        identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                        concat1 = pd.concat([submatriz_depots, abajo_temporal])
                        concat2 = pd.concat([derecha_temporal, identidad_temporal])

                        nueva_matriz = pd.concat([concat1, concat2], axis = 1)

                        ids_NoDisponibles = []
                        for fila in nueva_matriz.index:
                            conteo = 0
                            # Iterar sobre las columnas del DataFrame
                            for col in nueva_matriz.index:
                                if nueva_matriz.loc[fila,col] == "NoDisponible":
                                    conteo += 1
                            if conteo == nueva_matriz.shape[1] -1:
                                ids_NoDisponibles.append(fila)

                        if len(ids_NoDisponibles) > 0:
                            nueva_matriz = nueva_matriz.drop(ids_NoDisponibles, axis = 1)
                            nueva_matriz = nueva_matriz.drop(ids_NoDisponibles)
                            array_str = ', '.join(str(elem) for elem in ids_NoDisponibles)
                            text = f'Los siguientes IDs tienen una dirección fuera de la geografía delimitada: {array_str}'
                            QMessageBox.warning(self, "Warning", text)

                            base_clientes = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
                            base_clientes = base_clientes.drop(ids_NoDisponibles)
                            base_clientes.to_csv('Base_Datos_Clientes.txt', index = True, sep=';')

                            base_lat_lon = pd.read_csv('Base_lat_lon.txt', sep=';', encoding='latin-1')
                            base_lat_lon = base_lat_lon.drop(ids_NoDisponibles)
                            base_lat_lon.to_csv('Base_lat_lon.txt', index = True, sep=';')

                        nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')

                else:
                    nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                    ids_NoDisponibles = []
                    for fila in nueva_matriz.index:
                        conteo = 0
                        # Iterar sobre las columnas del DataFrame
                        for col in nueva_matriz.index:
                            if nueva_matriz.loc[fila,col] == "NoDisponible":
                                conteo += 1
                        if conteo == nueva_matriz.shape[1] -1:
                            ids_NoDisponibles.append(fila)

                    if len(ids_NoDisponibles) > 0:
                        nueva_matriz = nueva_matriz.drop(ids_NoDisponibles, axis = 1)
                        nueva_matriz = nueva_matriz.drop(ids_NoDisponibles)
                        array_str = ', '.join(str(elem) for elem in ids_NoDisponibles)
                        text = f'Los siguientes IDs tienen una dirección fuera de la geografía delimitada: {array_str}'
                        QMessageBox.warning(self, "Warning", text)

                        base_clientes = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')
                        base_clientes = base_clientes.drop(ids_NoDisponibles)
                        base_clientes.to_csv('Base_Datos_Clientes.txt', index = True, sep=';')

                        base_lat_lon = pd.read_csv('Base_lat_lon.txt', sep=';', encoding='latin-1')
                        base_lat_lon = base_lat_lon.drop(ids_NoDisponibles)
                        base_lat_lon.to_csv('Base_lat_lon.txt', index = True, sep=';')

                    nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                QMessageBox.information(self, "Information", "Los cambios han sido guardados")
                self.clear_layout_base_clientes()
                time.sleep(0.03)
                self.display_base_clientes()
            except:
                QMessageBox.warning(self, "Warning", 'Alguna dirección modificada no es válida')
    
    def clear_layout_base_clientes(self):
        n = self.scrollArea_6_layout.rowCount()
        if n >0:
            for i in reversed(range(n)):
                self.scrollArea_6_layout.removeRow(i)
                
    def anadir_cliente_ind_orden(self):
        name = self.lineEdit_7.text()
        direction = self.lineEdit_8.text()
        if name == "" or direction == "":
            QMessageBox.warning(self, "Warning", "Agregue un ID y dirección válida")
        else:
            self.lineEdit_7.clear()
            self.lineEdit_8.clear()
            geo_punto = self.geolocator.geocode(direction, timeout=180)
            if geo_punto:
                self.display_in_scrollA(name, direction, self.scroll_area_4_layout)
            else:
                QMessageBox.warning(self, "Warning", "La dirección ingresada no existe")
            
    def anadir_cliente_ind_base(self):
        name = self.lineEdit.text()
        direction = self.lineEdit_2.text()
        geo_punto = self.geolocator.geocode(direction, timeout=180)
        
        if name == "" or direction == "":
            QMessageBox.warning(self, "Warning", "Agregue un ID y dirección válida")
        else:
            if geo_punto:
                try:
                    if os.path.isfile("Base_Datos_Clientes.txt"):
                        base = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1')

                        if name in base["ID"].values:
                            text = f'El cliente con el ID: "{name}" ya se encuentra en la base de datos'
                            QMessageBox.warning(self, "Warning", text)
                        else:
                            f = open('Base_Datos_Clientes.txt', "a")
                            f.write("\n"+ name + ";" + direction)
                            f.close()
                            QMessageBox.information(self, "Information", "Añadir un cliente tomará un tiempo ya que se deben recalcular ciertos parámetros.\nPor favor, no oprima ningún botón hasta que el sistema indique que los datos fueron guardados")
                            self.lineEdit.clear()
                            self.lineEdit_2.clear()
                            time.sleep(0.03)
                            
                            data = {"ID": [name], "DIRECCION": [direction]}
                            # Creamos el DataFrame a partir del diccionario
                            df = pd.DataFrame(data)
                            self.base_lat_lon = sacar_lat_lon_clientes(df,self.geolocator,self.G)
                
                            #Escribir en base de lat lon 
                            if os.path.isfile("Base_lat_lon.txt"):
                                with open("Base_lat_lon.txt", mode="a") as f:
                                    self.base_lat_lon.to_csv(f, sep=";", header=False)
                            else:
                                self.base_lat_lon.to_csv("Base_lat_lon.txt", sep=";", index=True)
                                                    
                            if os.path.isfile("matriz_distancias.txt"):
                                matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                                base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                                derecha_temporal = pd.DataFrame(index = matriz_distancias.index, columns = [name])
                                for fila in matriz_distancias.index:
                                    nodoA = base_lat_lon.loc[fila,'nodo']
                                    nodoB = base_lat_lon.loc[name,'nodo']
                                    distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                    derecha_temporal.loc[fila,name] = distancia

                                abajo_temporal = pd.DataFrame(index = [name], columns = matriz_distancias.index)
                                nodoA = base_lat_lon.loc[name,'nodo']
                                for col in matriz_distancias.index:
                                    nodoB = base_lat_lon.loc[col,'nodo']
                                    distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                    abajo_temporal.loc[name,col] = distancia

                                identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                                concat1 = pd.concat([matriz_distancias, abajo_temporal])
                                concat2 = pd.concat([derecha_temporal, identidad_temporal])

                                nueva_matriz = pd.concat([concat1, concat2], axis = 1)
                                nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                                QMessageBox.information(self, "Information", "El/Los clientes han sido agregados a la base de datos")
                            else:
                                nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                                nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')    
                                QMessageBox.information(self, "Information", "El/Los clientes han sido agregados a la base de datos")
                            self.clear_layout_base_clientes()
                            time.sleep(0.05)
                            self.display_base_clientes()
                    else:
                        f = open('Base_Datos_Clientes.txt', "a")
                        f.write("ID;DIRECCION")
                        f.write("\n")
                        f.write(name + ";" + direction)
                        f.close()
                        
                        self.lineEdit.clear()
                        self.lineEdit_2.clear()
                        time.sleep(0.03)
                        
                        data = {"ID": [name], "DIRECCION": [direction]}
                        # Creamos el DataFrame a partir del diccionario
                        df = pd.DataFrame(data)
                        self.base_lat_lon = sacar_lat_lon_clientes(df,self.geolocator,self.G)
                
                        if os.path.isfile("Base_lat_lon.txt"):
                            with open("Base_lat_lon.txt", mode="a") as f:
                                self.base_lat_lon.to_csv(f, sep=";", header=False)
                        else:
                            self.base_lat_lon.to_csv("Base_lat_lon.txt", sep=";", index=True)
                                
                        if os.path.isfile("matriz_distancias.txt"):
                            matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                            base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                            derecha_temporal = pd.DataFrame(index = matriz_distancias.index, columns = [name])
                            for fila in matriz_distancias.index:
                                nodoA = base_lat_lon.loc[fila,'nodo']
                                nodoB = base_lat_lon.loc[name,'nodo']
                                distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                derecha_temporal.loc[fila,name] = distancia

                            abajo_temporal = pd.DataFrame(index = [name], columns = matriz_distancias.index)
                            nodoA = base_lat_lon.loc[name,'nodo']
                            for col in matriz_distancias.index:
                                nodoB = base_lat_lon.loc[col,'nodo']
                                distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                abajo_temporal.loc[name,col] = distancia

                            identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                            concat1 = pd.concat([matriz_distancias, abajo_temporal])
                            concat2 = pd.concat([derecha_temporal, identidad_temporal])

                            nueva_matriz = pd.concat([concat1, concat2], axis = 1)
                            nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                            QMessageBox.information(self, "Information", "El/Los clientes han sido agregados a la base de datos")
                        else:
                            nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                            nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep=";")    
                            QMessageBox.information(self, "Information", "El/Los clientes han sido agregados a la base de datos")
                        self.clear_layout_base_clientes()
                        time.sleep(0.05)
                        self.display_base_clientes()
                except:
                    QMessageBox.warning(self, "Warning", "La dirección ingresada no es válida dentro de la geografía limitada")
            else:
                QMessageBox.warning(self, "Warning", "La dirección ingresada no existe")
                
    def eliminar_clientes(self):
        if os.path.isfile("Base_Datos_Clientes.txt"):
            reply = QMessageBox.question(self, 'Confirmar Acción', '¿Desea eliminar los clientes seleccionados?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.Yes:
                base = pd.read_csv('Base_Datos_Clientes.txt', sep=';', encoding='latin-1', index_col = 0)
                items = self.scrollArea_6.findChildren(QWidget)
                data = []
                if items is not None:
                    for item in items:
                        if isinstance(item, QCheckBox) and item.isChecked():
                            name = item.objectName()
                            direction = item.parent().findChild(QLineEdit, name).text()
                            data.append([name, direction])

                    df = pd.DataFrame(data, columns=["ID", "DIRECCION"])


                    if df.shape[0] == base.shape[0]:
                        os.remove('Base_Datos_Clientes.txt')
                    else:
                        mascara = ~base.index.isin(df['ID'])
                        base_filtrada = base[mascara]
                        with open("Base_Datos_Clientes.txt", mode="w") as f:
                            base_filtrada.to_csv(f, sep=";", header=True)

                    if os.path.isfile("matriz_distancias.txt"):
                        try:
                            matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                            sub_matriz = matriz_distancias.drop(index = df['ID'], columns = df['ID'])
                            sub_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                        except:
                            QMessageBox.warning(self, "Warning", "Error Fatal, debe reestablecer el sistema. Dirijase a la ventana de ajustes y oprima el boton reestablecer. Esto eliminará todos los datos guardados ")
                        

                    if os.path.isfile("Base_lat_lon.txt"):
                        try:
                            base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                            mascara = ~base_lat_lon.index.isin(df['ID'])
                            base_filtrada = base_lat_lon[mascara]
                            with open("Base_lat_lon.txt", mode="w") as f:
                                base_filtrada.to_csv(f, sep=";", header=True)
                        except:
                            QMessageBox.warning(self, "Warning", "Error Fatal, debe reestablecer el sistema. Dirijase a la ventana de ajustes y oprima el boton reestablecer. Esto eliminará todos los datos guardados ")
                        

                self.clear_layout_base_clientes()
                time.sleep(0.03)
                self.display_base_clientes()
                QMessageBox.information(self, "Information", "Los clientes han sido eliminados")
        else:
            QMessageBox.information(self, "Information", "No hay registro de clientes en la base de datos")
              
    def seleccionar_todos_clientes_base(self, state):
        widgets = self.scrollArea_6.findChildren(QWidget)
        if widgets:
            for widget in widgets:
                if isinstance(widget, QCheckBox):
                    widget.setCheckState(state)

    def seleccionar_todos_clientes(self, state):
        widgets = self.scrollArea_4.findChildren(QWidget)
        if widgets:
            for widget in widgets:
                if isinstance(widget, QCheckBox):
                    widget.setCheckState(state)

            
            
###############################################################################################################################################################            
############################### TAB DEPOSITOS ################################################################################################################
##################################################################################################################################################################


    def display_in_scroll_depots(self,name, direction, scrollA):
        # layout = QHBoxLayout()

        checkbox = QCheckBox(name, self)
        checkbox.setObjectName(name)
        checkbox.setChecked(True)
        fc = checkbox.font()
        fc.setPointSize(7)
        checkbox.setFont(fc)

        lineedit = QLineEdit(direction)
        lineedit.setObjectName(name)
        f = lineedit.font()
        f.setPointSize(7)
        lineedit.setFont(f)
        
        scrollA.addRow(checkbox, lineedit)    
        
    def carga_masiva_depositos(self):
        # open file dialog to select CSV file
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        fileFilters = "Text Files (*.txt);;All Files (*)"
        self.file_path_depots, _ = QFileDialog.getOpenFileName(self, "Select Excel File", "", fileFilters, options=options)
        try:    
            if self.file_path_depots:
                direcciones_depots = pd.read_csv(self.file_path_depots, sep=';')
                self.checkboxes = []
                comunes = []
                self.label_11.setText("Seleccione el depósito de salida")
                for i in range(direcciones_depots.shape[0]):
                    ID = direcciones_depots.loc[i,"ID"]
                    direccion = direcciones_depots.loc[i,"DIRECCION"]
                    geo_punto = self.geolocator.geocode(direccion, timeout=180)
                    if geo_punto:
                        self.display_in_scroll_depots(ID,direccion,self.scrollArea_5_layout)
                    else:
                        n = i + 1
                        string = ID + ' (Linea ' + str(n) + ')'
                        comunes.append(string)
                        
                if len(comunes) > 0:
                        array_str = ', '.join(str(elem) for elem in comunes)
                        text = f'Los siguientes IDs tienen una dirección inválida: {array_str}'
                        QMessageBox.warning(self, "Warning", text)
            else:
                self.label_10.setText("Cargue un archivo válido:")
        except:
            QMessageBox.warning(self, "Warning", "Verifique que el archivo cargado cumple con los requisitos")

    def cargar_base_depots(self):
        if os.path.isfile("Base_Datos_Depots.txt"):
            direcciones_depots = pd.read_csv('Base_Datos_Depots.txt', sep=';', encoding='latin-1')
            self.checkboxes_depots = []

            if direcciones_depots.empty == False:
                self.label_11.setText("Seleccione el depósito de salida.")
                for i in range(direcciones_depots.shape[0]):
                    ID = direcciones_depots.loc[i,"ID"]
                    direccion = direcciones_depots.loc[i,"DIRECCION"]
                    self.display_in_scroll_depots(ID,direccion,self.scrollArea_5_layout)  
            else:
                QMessageBox.warning(self, "Warning", "La base de datos está vacia")
            return
        else:
            QMessageBox.warning(self, "Warning", "No existen registros en la base de datos")
        return

    def descargar_template_depots(self):
        # Get the URL of the file to download
        with open('Template Agregar Depósitos.txt', 'w') as f:
            f.write("Para agregar depósitos de forma masiva debe ingresarlos con el siguiente formato en un archivo .txt:")
            f.write('\n')
            f.write('\n')
            f.write("ID;Direccion")
            f.write('\n')
            f.write('\n')
            f.write("Ejemplo:")
            f.write('\n')
            f.write("ID;Direccion")
            f.write('\n')
            f.write("Uniandes;Carrera 1 18A 12, Bogotá, Colombia")
            f.write('\n')
            f.write('\n')
            f.write("Nota: Agregue únicamente un depósito por linea. Dejar en la primera linea 'ID;Direccion'")
        QMessageBox.information(self, "Information", "El template fue descargado en la misma carpeta que la aplicación.")
        
    def crear_dataframe_depots(self):
        items = self.scrollArea_5.findChildren(QWidget)
        data = []
        for item in items:
            if isinstance(item, QCheckBox) and item.isChecked():
                name = item.objectName()
                direction = item.parent().findChild(QLineEdit, name).text()
                data.append([name, direction])

        df = pd.DataFrame(data, columns=["ID", "DIRECCION"])
        return(df)
           
    def escribir_sobre_base_depots(self):
        QMessageBox.information(self, "Information", "A continuación almacenará los depósitos a la base de datos y guardará sus atributos, esto tomará un poco de tiempo.\nPor favor, no oprima ningún botón hasta que el sistema indique que los depósitos fueron agregados a la base ")
        df = self.crear_dataframe_depots()
        self.base_lat_lon = sacar_lat_lon_clientes(df,self.geolocator,self.G)
        if df.empty == False:
            if os.path.isfile("Base_Datos_Depots.txt"):
                base = pd.read_csv('Base_Datos_Depots.txt', sep=';', encoding='latin-1')
                common_elements = base[base['ID'].isin(df['ID'])]['ID']
                if common_elements.empty == False:
                    array_str = ', '.join(str(elem) for elem in common_elements)
                    text = f'Los siguientes IDs ya se encuentran en la base de datos: {array_str}'
                    QMessageBox.warning(self, "Warning", text)
                else:
                    f = open('Base_Datos_Depots.txt', "a")
                    f.write("\n")
                    for index, row in df.iterrows():
                        f.write(row["ID"] + ";" + row["DIRECCION"] + "\n")
                    f.close()

                    #Escribir en base de lat lon 
                    if os.path.isfile("Base_lat_lon.txt"):
                        with open("Base_lat_lon.txt", mode="a") as f:
                            self.base_lat_lon.to_csv(f, sep=";", header=False)
                    else:
                        self.base_lat_lon.to_csv("Base_lat_lon.txt", sep=";", index=True)
                    
                    if os.path.isfile("matriz_distancias.txt"):
                        matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                        base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                        derecha_temporal = pd.DataFrame(index = matriz_distancias.index, columns = df['ID'])
                        for fila in matriz_distancias.index:
                            nodoA = base_lat_lon.loc[fila,'nodo']
                            for col in df['ID']:
                                nodoB = base_lat_lon.loc[col,'nodo']
                                distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                derecha_temporal.loc[fila,col] = distancia

                        abajo_temporal = pd.DataFrame(index = df['ID'], columns = matriz_distancias.index)
                        for fila in df['ID']:
                            nodoA = base_lat_lon.loc[fila,'nodo']
                            for col in matriz_distancias.index:
                                nodoB = base_lat_lon.loc[col,'nodo']
                                distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                abajo_temporal.loc[fila,col] = distancia

                        identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                        concat1 = pd.concat([matriz_distancias, abajo_temporal])
                        concat2 = pd.concat([derecha_temporal, identidad_temporal])

                        nueva_matriz = pd.concat([concat1, concat2], axis = 1)
                        nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                        QMessageBox.information(self, "Information", "El/Los depósitos han sido agregados a la base de datos")
                    else:
                        nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                        nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')   
                        QMessageBox.information(self, "Information", "El/Los depósitos han sido agregados a la base de datos") 
                    self.clear_layout_depots()
                    self.clear_layout_base_depots()
                    time.sleep(0.02)
                    self.display_base_depots()
            else:
                f = open('Base_Datos_Depots.txt', "a")
                f.write("ID;DIRECCION")
                f.write("\n")
                for index, row in df.iterrows():
                    f.write(row["ID"] + ";" + row["DIRECCION"] + "\n")
                f.close()
                
                if os.path.isfile("Base_lat_lon.txt"):
                    with open("Base_lat_lon.txt", mode="a") as f:
                        self.base_lat_lon.to_csv(f, sep=";", header=False)
                else:
                    self.base_lat_lon.to_csv("Base_lat_lon.txt", sep=";", index=True)
                
                if os.path.isfile("matriz_distancias.txt"):
                    matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                    base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                    derecha_temporal = pd.DataFrame(index = matriz_distancias.index, columns = df['ID'])
                    for fila in matriz_distancias.index:
                        nodoA = base_lat_lon.loc[fila,'nodo']
                        for col in df['ID']:
                            nodoB = base_lat_lon.loc[col,'nodo']
                            distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                            derecha_temporal.loc[fila,col] = distancia

                    abajo_temporal = pd.DataFrame(index = df['ID'], columns = matriz_distancias.index)
                    for fila in df['ID']:
                        nodoA = base_lat_lon.loc[fila,'nodo']
                        for col in matriz_distancias.index:
                            nodoB = base_lat_lon.loc[col,'nodo']
                            distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                            abajo_temporal.loc[fila,col] = distancia

                    identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                    concat1 = pd.concat([matriz_distancias, abajo_temporal])
                    concat2 = pd.concat([derecha_temporal, identidad_temporal])

                    nueva_matriz = pd.concat([concat1, concat2], axis = 1)
                    nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')

                    QMessageBox.information(self, "Information", "El/Los depósitos han sido agregados a la base de datos")
                else:
                    nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                    nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')                  
                    QMessageBox.information(self, "Information", "El/Los depósitos han sido agregados a la base de datos")
                self.clear_layout_depots()
                self.clear_layout_base_depots()
                time.sleep(0.02)
                self.display_base_depots()
        else:
            QMessageBox.warning(self, "Warning", "Debe selccionar algun depósito para ser añadido a la base de datos")
            
    def clear_layout_depots(self):
        n = self.scrollArea_5_layout.rowCount()
        if n >0:
            for i in reversed(range(n)):
                self.scrollArea_5_layout.removeRow(i)
        self.map_depots = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
        # Convert Folium map to HTML and display in web view
        self.html_depots = self.map_depots._repr_html_()
        self.web_view_depots.setHtml(self.html_depots)
                
    def display_base_depots(self):
        if os.path.isfile("Base_Datos_Depots.txt"):
            base = pd.read_csv('Base_Datos_Depots.txt', sep=';', encoding='latin-1')
            self.checkboxes_base_depots = []

            if base.empty == False:
                self.label_19.setText("Los depósitos en la base son:")
                for i in range(base.shape[0]):
                    ID = base.loc[i,"ID"]
                    direccion = base.loc[i,"DIRECCION"]
                    self.display_in_scrollA(ID,direccion,self.scrollArea_7_layout)  
            else:
                QMessageBox.warning(self, "Warning", "La base de datos está vacia")
            return
        else:
            QMessageBox.warning(self, "Warning", "No existen registros de depósitos en la base de datos")
        return

    def guardar_cambios_depots(self):
        QMessageBox.information(self, "Information", "A continuación guardará los cambios y actualizará la base de datos, esto puede tomar un poco de tiempo. \nPor favor, no oprima ningún botón hasta que el sistema indique que los datos fueron guardados")
        items = self.scrollArea_7.findChildren(QWidget)
        data = []
        if items is not None:
            for item in items:
                if isinstance(item, QCheckBox):
                    name = item.objectName()
                    direction = item.parent().findChild(QLineEdit, name).text()
                    data.append([name, direction])

            df = pd.DataFrame(data, columns=["ID", "DIRECCION"])
            f = open('Base_Datos_Depots.txt', "w")
            f.write("ID;DIRECCION")
            f.write("\n")
            for index, row in df.iterrows():
                f.write(row["ID"] + ";" + row["DIRECCION"] + "\n")
            f.close()
    
            try:
                self.base_lat_lon = sacar_lat_lon_clientes(df,self.geolocator,self.G)
                #Escribir en base de lat lon 
                if os.path.isfile("Base_lat_lon.txt"):
                    base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                    mascara = ~base_lat_lon.index.isin(df['ID'])
                    base_filtrada = base_lat_lon[mascara]
                    nueva_base = pd.concat([base_filtrada, self.base_lat_lon])
                    nueva_base.to_csv("Base_lat_lon.txt", sep=";", index=True)

                if os.path.isfile("matriz_distancias.txt"):
                    matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                    submatriz_depots = matriz_distancias.drop(index = df['ID'], columns = df['ID'])

                    base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                    derecha_temporal = pd.DataFrame(index = submatriz_depots.index, columns = df['ID'])
                    for fila in submatriz_depots.index:
                        nodoA = base_lat_lon.loc[fila,'nodo']
                        for col in df['ID']:
                            nodoB = base_lat_lon.loc[col,'nodo']
                            distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                            derecha_temporal.loc[fila,col] = distancia

                    abajo_temporal = pd.DataFrame(index = df['ID'], columns = submatriz_depots.index)
                    for fila in df['ID']:
                        nodoA = base_lat_lon.loc[fila,'nodo']
                        for col in submatriz_depots.index:
                            nodoB = base_lat_lon.loc[col,'nodo']
                            distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                            abajo_temporal.loc[fila,col] = distancia

                    identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                    concat1 = pd.concat([submatriz_depots, abajo_temporal])
                    concat2 = pd.concat([derecha_temporal, identidad_temporal])

                    nueva_matriz = pd.concat([concat1, concat2], axis = 1)
                    nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                else:
                    nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                    nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                QMessageBox.information(self, "Information", "Los cambios han sido guardados")
                self.clear_layout_base_clientes()
                time.sleep(0.03)
                self.display_base_clientes()
            except:
                QMessageBox.warning(self, "Warning", 'Alguna dirección modificada no es válida')   
    
    def clear_layout_base_depots(self):
        n = self.scrollArea_7_layout.rowCount()
        if n >0:
            for i in reversed(range(n)):
                self.scrollArea_7_layout.removeRow(i)
    
    def eliminar_depots(self):
        if os.path.isfile("Base_Datos_Depots.txt"):
            reply = QMessageBox.question(self, 'Confirmar Acción', '¿Desea eliminar el/los depósitos seleccionados?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.Yes:
                base = pd.read_csv('Base_Datos_Depots.txt', sep=';', encoding='latin-1', index_col = 0)
                items = self.scrollArea_7.findChildren(QWidget)
                data = []
                if items is not None:
                    for item in items:
                        if isinstance(item, QCheckBox) and item.isChecked():
                            name = item.objectName()
                            direction = item.parent().findChild(QLineEdit, name).text()
                            data.append([name, direction])

                    df = pd.DataFrame(data, columns=["ID", "DIRECCION"])

                    mascara = ~base.index.isin(df['ID'])
                    base_filtrada = base[mascara]
                    with open("Base_Datos_Depots.txt", mode="w") as f:
                        base_filtrada.to_csv(f, sep=";", header=True)

                    if os.path.isfile("matriz_distancias.txt"):
                        matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                        sub_matriz = matriz_distancias.drop(index = df['ID'], columns = df['ID'])
                        sub_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                        

                    if os.path.isfile("Base_lat_lon.txt"):
                        base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                        mascara = ~base_lat_lon.index.isin(df['ID'])
                        base_filtrada = base_lat_lon[mascara]
                        with open("Base_lat_lon.txt", mode="w") as f:
                            base_filtrada.to_csv(f, sep=";", header=True)

                    self.clear_layout_base_depots()
                    time.sleep(0.03)
                    self.display_base_depots()
                    QMessageBox.information(self, "Information", "Los depósitos han sido eliminados")
        else:
            QMessageBox.information(self, "Information", "No hay registro de depósitos en la base de datos")
            
    def anadir_depot_ind_orden(self):
        name = self.lineEdit_11.text()
        direction = self.lineEdit_12.text()
        if name == "" or direction == "":
            QMessageBox.warning(self, "Warning", "Agregue un ID y dirección válida")
        else:
            self.lineEdit_11.clear()
            self.lineEdit_12.clear()
            geo_punto = self.geolocator.geocode(direction, timeout=180)
            if geo_punto:
                self.display_in_scrollA(name, direction, self.scrollArea_5_layout)
                time.sleep(0.01)
                df_temp = self.crear_dataframe_depots()
                df = sacar_lat_lon_clientes(df_temp,self.geolocator,self.G)
                index_list = df.index.values.tolist()
                m_temp = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=11)
                for i in range(0,df.shape[0]):
                    folium.Marker(location=[df.iloc[i]['lat'], df.iloc[i]['lon']], popup=index_list[i]).add_to(m_temp)
                self.html_depots = m_temp._repr_html_()
                self.web_view_depots.setHtml(self.html_depots)
            else:
                QMessageBox.warning(self, "Warning", "La dirección ingresada no existe")

    def anadir_depot_ind_base(self):
        QMessageBox.information(self, "Information", "Añadir un depósito podrá tomar un tiempo ya que se deben recalcular ciertos parámetros.\nPor favor, no oprima ningún botón hasta que el sistema indique que los datos fueron guardados")
        name = self.lineEdit_3.text()
        direction = self.lineEdit_4.text()
        geo_punto = self.geolocator.geocode(direction, timeout=180)
        if name == "" or direction == "":
            QMessageBox.warning(self, "Warning", "Agregue un ID y dirección válida")
        else:
            if geo_punto:
                if os.path.isfile("Base_Datos_Depots.txt"):
                    base = pd.read_csv('Base_Datos_Depots.txt', sep=';', encoding='latin-1')

                    if name in base["ID"].values:
                        text = f'El depósito con el ID: "{name}" ya se encuentra en la base de datos'
                        QMessageBox.warning(self, "Warning", text)
                    else:
                        f = open('Base_Datos_Depots.txt', "a")
                        f.write("\n"+ name + ";" + direction)
                        f.close()
                        self.lineEdit_3.clear()
                        self.lineEdit_4.clear()
                        time.sleep(0.03)
                        
                        data = {"ID": [name], "DIRECCION": [direction]}
                        # Creamos el DataFrame a partir del diccionario
                        df = pd.DataFrame(data)
                        self.base_lat_lon = sacar_lat_lon_clientes(df,self.geolocator,self.G)

                        #Escribir en base de lat lon 
                        if os.path.isfile("Base_lat_lon.txt"):
                            with open("Base_lat_lon.txt", mode="a") as f:
                                self.base_lat_lon.to_csv(f, sep=";", header=False)
                        else:
                            self.base_lat_lon.to_csv("Base_lat_lon.txt", sep=";", index=True)
                        
                        if os.path.isfile("matriz_distancias.txt"):
                            matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                            base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                            derecha_temporal = pd.DataFrame(index = matriz_distancias.index, columns = [name])
                            for fila in matriz_distancias.index:
                                nodoA = base_lat_lon.loc[fila,'nodo']
                                nodoB = base_lat_lon.loc[name,'nodo']
                                distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                derecha_temporal.loc[fila,name] = distancia

                            abajo_temporal = pd.DataFrame(index = [name], columns = matriz_distancias.index)
                            nodoA = base_lat_lon.loc[name,'nodo']
                            for col in matriz_distancias.index:
                                nodoB = base_lat_lon.loc[col,'nodo']
                                distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                                abajo_temporal.loc[name,col] = distancia

                            identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                            concat1 = pd.concat([matriz_distancias, abajo_temporal])
                            concat2 = pd.concat([derecha_temporal, identidad_temporal])

                            nueva_matriz = pd.concat([concat1, concat2], axis = 1)
                            nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                            QMessageBox.information(self, "Information", "El depósito han sido agregado a la base de datos")
                        else:
                            nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                            nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')    
                            QMessageBox.information(self, "Information", "El depósito han sido agregado a la base de datos")
                        self.clear_layout_base_depots()
                        time.sleep(0.03)
                        self.display_base_depots()
                else:
                    f = open('Base_Datos_Depots.txt', "a")
                    f.write("ID;DIRECCION")
                    f.write("\n")
                    f.write(name + ";" + direction)
                    f.close()
                    
                    self.lineEdit_3.clear()
                    self.lineEdit_4.clear()
                    time.sleep(0.03)
                    
                    data = {"ID": [name], "DIRECCION": [direction]}
                    # Creamos el DataFrame a partir del diccionario
                    df = pd.DataFrame(data)
                    self.base_lat_lon = sacar_lat_lon_clientes(df,self.geolocator,self.G)

                    if os.path.isfile("Base_lat_lon.txt"):
                        with open("Base_lat_lon.txt", mode="a") as f:
                            self.base_lat_lon.to_csv(f, sep=";", header=False)
                    else:
                        self.base_lat_lon.to_csv("Base_lat_lon.txt", sep=";", index=True)
                    
                    if os.path.isfile("matriz_distancias.txt"):
                        matriz_distancias = pd.read_csv("matriz_distancias.txt", sep=";", index_col=0)
                        base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep=";", index_col=0, encoding='latin-1')
                        derecha_temporal = pd.DataFrame(index = matriz_distancias.index, columns = [name])
                        for fila in matriz_distancias.index:
                            nodoA = base_lat_lon.loc[fila,'nodo']
                            nodoB = base_lat_lon.loc[name,'nodo']
                            distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                            derecha_temporal.loc[fila,name] = distancia

                        abajo_temporal = pd.DataFrame(index = [name], columns = matriz_distancias.index)
                        nodoA = base_lat_lon.loc[name,'nodo']
                        for col in matriz_distancias.index:
                            nodoB = base_lat_lon.loc[col,'nodo']
                            distancia = nx.shortest_path_length(self.G, nodoA, nodoB, weight='length')
                            abajo_temporal.loc[name,col] = distancia

                        identidad_temporal = crear_matriz_distancias(df,self.base_lat_lon,self.G)

                        concat1 = pd.concat([matriz_distancias, abajo_temporal])
                        concat2 = pd.concat([derecha_temporal, identidad_temporal])

                        nueva_matriz = pd.concat([concat1, concat2], axis = 1)
                        nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')
                        QMessageBox.information(self, "Information", "El depósito han sido agregado a la base de datos")
                    else:
                        nueva_matriz = crear_matriz_distancias(df,self.base_lat_lon,self.G)
                        nueva_matriz.to_csv('matriz_distancias.txt', index = True, sep = ';')    
                        QMessageBox.information(self, "Information", "El depósito han sido agregado a la base de datos")
                    self.clear_layout_base_depots()
                    time.sleep(0.03)
                    self.display_base_depots()
            else:
                QMessageBox.warning(self, "Warning", "La dirección ingresada no existe") 
    
    def extraer_deposito_corrida(self):
        self.data_deposito = self.crear_dataframe_depots()
        if self.data_deposito.empty:
            QMessageBox.warning(self, "Warning", "Debe seleccionar un depósito para el ruteo.")
        elif self.data_deposito.shape[0] > 1:
            QMessageBox.warning(self, "Warning", "Debe seleccionar ÚNICAMENTE un depósito para el ruteo.")
        else:             
            
            if os.path.isfile("Base_lat_lon.txt"):
                try:
                    base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep = ";", index_col = 0, encoding='latin-1')
                    self.df_lat_lon_depots = base_lat_lon.loc[self.data_deposito["ID"]]
                    index_list = self.df_lat_lon_depots.index.values.tolist()
                    m_temp = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=10)
                    for i in range(0,self.df_lat_lon_depots.shape[0]):
                        folium.Marker(location=[self.df_lat_lon_depots.iloc[i]['lat'], self.df_lat_lon_depots.iloc[i]['lon']], popup=index_list[i]).add_to(m_temp)
                    self.html_depots = m_temp._repr_html_()
                    self.web_view_depots.setHtml(self.html_depots)
                except:
                    self.df_lat_lon_depots = sacar_lat_lon_clientes(self.data_deposito,self.geolocator,self.G)
                    index_list = self.df_lat_lon_depots.index.values.tolist()
                    m_temp = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=10)
                    for i in range(0,self.df_lat_lon_depots.shape[0]):
                        folium.Marker(location=[self.df_lat_lon_depots.iloc[i]['lat'], self.df_lat_lon_depots.iloc[i]['lon']], popup=index_list[i]).add_to(m_temp)
                    self.html_depots = m_temp._repr_html_()
                    self.web_view_depots.setHtml(self.html_depots)
            else:

                self.df_lat_lon_depots = sacar_lat_lon_clientes(self.data_deposito,self.geolocator,self.G)
                index_list = self.df_lat_lon_depots.index.values.tolist()
                m_temp = folium.Map(location=[4.6097,-74.0817], tiles="OpenStreetMap", zoom_start=10)
                for i in range(0,self.df_lat_lon_depots.shape[0]):
                    folium.Marker(location=[self.df_lat_lon_depots.iloc[i]['lat'], self.df_lat_lon_depots.iloc[i]['lon']], popup=index_list[i]).add_to(m_temp)
                self.html_depots = m_temp._repr_html_()
                self.web_view_depots.setHtml(self.html_depots)

            QMessageBox.information(self, "Information", "El depósito ha sido guardado, puede continuar.") 
  


    def seleccionar_todos_depots(self, state):
        widgets = self.scrollArea_5.findChildren(QWidget)
        if widgets:
            for widget in widgets:
                if isinstance(widget, QCheckBox):
                    widget.setCheckState(state)

    def seleccionar_todos_depots_base(self, state):
        widgets = self.scrollArea_7.findChildren(QWidget)
        if widgets:
            for widget in widgets:
                if isinstance(widget, QCheckBox):
                    widget.setCheckState(state)    

    def clear_layout_resultado(self):
            n = self.ScrollArea_layout.rowCount()
            if n >0:
                for i in reversed(range(n)):
                    self.ScrollArea_layout.removeRow(i)

    def display_resultado(self,name, direction, scrollA):
        # layout = QHBoxLayout()

        label_id = QLabel(name, self)
        #checkbox.setObjectName(name)
        #checkbox.setChecked(True)
        fc = label_id.font()
        fc.setPointSize(11)
        label_id.setFont(fc)

        direccion = QLabel(direction)
        direccion.setObjectName(name)
        f = direccion.font()
        f.setPointSize(11)
        direccion.setFont(f)
        
        scrollA.addRow(label_id, direccion) 
    
    def cambiar_ubicacion(self):
        self.graph_area = self.lineEdit_5.text()
        try:
            self.G = ox.graph_from_place(self.graph_area, network_type='drive', simplify=True)
            # OSM data are sometime incomplete so we use the speed module of osmnx to add missing edge speeds and travel times
            self.G = ox.add_edge_speeds(self.G)
            self.G = ox.add_edge_travel_times(self.G)  
            QMessageBox.information(self, "Information", "La ciudad fue cambiada con éxito")
            self.lineEdit_5.clear()
        except:
            QMessageBox.warning(self, "Warning", "La ciudad ingresada no puede ser cargada, intente nuevamente")
            self.lineEdit_5.clear()

###############################################################################################################################################################            
############################### RESTRICCIONES ################################################################################################################
##################################################################################################################################################################

    def crear_dataframe_cargas(self):
        items = self.scrollArea_9.findChildren(QWidget)
        data = []
        for item in items:
            if isinstance(item, QCheckBox) and item.isChecked():
                name = item.objectName()
                carga = item.parent().findChild(QSpinBox, name).value()
                data.append([name, carga])

        df = pd.DataFrame(data, columns=["ID", "CARGA"])
        return(df)

    def extraer_df_cargas(self):
        self.data_cargas = self.crear_dataframe_cargas()
        QMessageBox.warning(self, "Information", "Las demandas han sido guardadas, puede continuar")
        
    def clear_layout_carga(self):
        n = self.scrollArea_9_layout.rowCount()
        if n >0:
            for i in reversed(range(n)):
                self.scrollArea_9_layout.removeRow(i)

    def clear_layout_tiempos(self):
        for i in reversed(range(self.scrollArea_10_layout.count())):
            item = self.scrollArea_10_layout.itemAt(i)
            if item is not None:
                widget = item.widget()
                self.scrollArea_10_layout.removeWidget(widget)
                widget.deleteLater()
        time.sleep(0.5)

    def display_in_scroll_cargas(self,name, scrollA):
        # layout = QHBoxLayout()
        checkbox = QCheckBox(name, self)
        checkbox.setObjectName(name)
        checkbox.setChecked(True)
        checkbox.setEnabled(False)
        fc = checkbox.font()
        fc.setPointSize(7)
        checkbox.setFont(fc)

        spin_carga = QSpinBox()
        spin_carga.setRange(0,999999999)
        spin_carga.setObjectName(name)
        f = spin_carga.font()
        f.setPointSize(7)
        spin_carga.setFont(f)
        
        scrollA.addRow(checkbox, spin_carga)

    def crear_dataframe_tiempos(self):
        items = self.scrollArea_10.findChildren(QWidget)
        data = []
        for item in items:
            if isinstance(item, QCheckBox) and item.isChecked():
                name = item.objectName()
                nombre_inicio = name + "_inicio"
                nombre_fin = name + "_fin"
                tiempo_inicio = item.parent().findChild(QTimeEdit, nombre_inicio).time()
                tiempo_inicio_str = tiempo_inicio.toString()
                tiempo_fin = item.parent().findChild(QTimeEdit, nombre_fin).time()
                tiempo_fin_str = tiempo_fin.toString()

                data.append([name, tiempo_inicio_str, tiempo_fin_str])

        df = pd.DataFrame(data, columns=["ID", "HORA_INICIO", "HORA_FIN"])
        self.data_tiempos = df
        print(self.data_tiempos)
        QMessageBox.warning(self, "Information", "Las ventanas de tiempo han sido guardadas, puede continuar")
        

###############################################################################################################################################################            
###############################  VEHICULOS ################################################################################################################
##################################################################################################################################################################
    
    def display_in_scroll_spinbox_vehiculos(self, name, capacidad, scrollA):
        checkbox = QCheckBox(name, self)
        checkbox.setObjectName(name)
        checkbox.setChecked(True)
        fc = checkbox.font()
        fc.setPointSize(7)
        checkbox.setFont(fc)

        spin_carga = QSpinBox()
        spin_carga.setRange(0,999999999)
        spin_carga.setObjectName(name)
        spin_carga.setValue(capacidad)
        f = spin_carga.font()
        f.setPointSize(7)
        spin_carga.setFont(f)
        
        scrollA.addRow(checkbox, spin_carga)

    def display_in_scroll_spinbox(self, name, capacidad, scrollA):
        checkbox = QCheckBox(name, self)
        checkbox.setObjectName(name)
        checkbox.setChecked(True)
        checkbox.setEnabled(False)
        fc = checkbox.font()
        fc.setPointSize(7)
        checkbox.setFont(fc)

        spin_carga = QSpinBox()
        spin_carga.setRange(0,999999999)
        spin_carga.setObjectName(name)
        spin_carga.setValue(capacidad)
        f = spin_carga.font()
        f.setPointSize(7)
        spin_carga.setFont(f)
        
        scrollA.addRow(checkbox, spin_carga)

    def agregar_vehiculo(self):
        name = self.lineEdit_13.text()
        capacidad = self.spinBox.value()
        if os.path.isfile("Base_Datos_vehiculos.txt"):
            base = pd.read_csv('Base_Datos_vehiculos.txt', sep=';', encoding='latin-1')
            if base.empty == True:
                f = open('Base_Datos_vehiculos.txt', "a")
                f.write("ID;CAPACIDAD")
                f.write("\n")
                f.write(name + ";" + str(capacidad))
                f.close()
                self.lineEdit_13.clear()
                self.spinBox.setValue(0)
                self.display_in_scroll_spinbox_vehiculos(name, capacidad, self.scrollArea_8_layout)
            else:
                if name in base["ID"].values:
                    text = f'El vehículo con el ID: "{name}" ya se encuentra en la base de datos'
                    QMessageBox.warning(self, "Warning", text)
                else:
                    f = open('Base_Datos_vehiculos.txt', "a")
                    f.write("\n"+ name + ";" + str(capacidad))
                    f.close()
                    self.lineEdit_13.clear()
                    self.spinBox.setValue(0)
                    self.display_in_scroll_spinbox_vehiculos(name, capacidad, self.scrollArea_8_layout)
        else:
            f = open('Base_Datos_vehiculos.txt', "a")
            f.write("ID;CAPACIDAD")
            f.write("\n")
            f.write(name + ";" + str(capacidad))
            f.close()
            self.lineEdit_13.clear()
            self.spinBox.setValue(0)
            self.display_in_scroll_spinbox_vehiculos(name, capacidad, self.scrollArea_8_layout)

    def clear_vehiculos(self):
        n = self.scrollArea_8_layout.rowCount()
        if n >0:
            for i in reversed(range(n)):
                self.scrollArea_8_layout.removeRow(i)

    def eliminar_vehiculos(self):
        if os.path.isfile("Base_Datos_vehiculos.txt"):
            reply = QMessageBox.question(self, 'Confirmar Acción', '¿Desea eliminar el/los vehículos seleccionados?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.Yes:
                base = pd.read_csv('Base_Datos_vehiculos.txt', sep=';', encoding='latin-1', index_col = 0)
                items = self.scrollArea_8.findChildren(QWidget)
                data = []
                if items is not None:
                    for item in items:
                        if isinstance(item, QCheckBox) and item.isChecked():
                            name = item.objectName()
                            capacidad = item.parent().findChild(QSpinBox, name).value()
                            data.append([name, capacidad])

                    df = pd.DataFrame(data, columns=["ID", "CAPACIDAD"])

                    mascara = ~base.index.isin(df['ID'])
                    base_filtrada = base[mascara]
                    with open("Base_Datos_vehiculos.txt", mode="w") as f:
                        base_filtrada.to_csv(f, sep=";", header=True)

                    self.clear_vehiculos()
                    time.sleep(0.02)
                    self.display_base_vehiculos()

    def display_base_vehiculos(self):
        if os.path.isfile("Base_Datos_vehiculos.txt"):
            base = pd.read_csv('Base_Datos_vehiculos.txt', sep=';', encoding='latin-1')
            self.checkboxes_base_depots = []

            if base.empty == False:
                for i in range(base.shape[0]):
                    ID = base.loc[i,"ID"]
                    capacidad = base.loc[i,"CAPACIDAD"]
                    self.display_in_scroll_spinbox_vehiculos(ID,capacidad,self.scrollArea_8_layout)  
            else:
                QMessageBox.warning(self, "Warning", "La base de datos está vacia")
            return
        else:
            QMessageBox.warning(self, "Warning", "No existen registros de depósitos en la base de datos")
        return

    def guardar_cambios_vehiculos(self):
        items = self.scrollArea_8.findChildren(QWidget)
        data = []
        if items is not None:
            for item in items:
                if isinstance(item, QCheckBox):
                    name = item.objectName()
                    direction = item.parent().findChild(QSpinBox, name).value()
                    data.append([name, direction])

            df = pd.DataFrame(data, columns=["ID", "CAPACIDAD"])
            df.to_csv('Base_Datos_vehiculos.txt', index = False, sep = ';')
            self.clear_vehiculos()
            time.sleep(0.02)
            self.display_base_vehiculos()
            QMessageBox.warning(self, "Information", 'Los cambios fueron guardados')

    def crear_dataframe_vehiculo(self):
        items = self.scrollArea_8.findChildren(QWidget)
        data = []
        for item in items:
            if isinstance(item, QCheckBox) and item.isChecked():
                name = item.objectName()
                capacidad = item.parent().findChild(QSpinBox, name).value()
                data.append([name, capacidad])

        df = pd.DataFrame(data, columns=["ID", "CAPACIDAD"])
        return(df)

    def extraer_capacidad_vehiculo(self):
        df = self.crear_dataframe_vehiculo()
        if df.empty:
            QMessageBox.warning(self, "Warning", "Debe seleccionar un vehículo para el ruteo")
        elif df.shape[0] > 1:
            QMessageBox.warning(self, "Warning", "Debe seleccionar ÚNICAMENTE un vehículo para el ruteo")
        else:             
            QMessageBox.information(self, "Information", "El vehículo ha sido guardado, puede continuar a la pestaña de ruteo.")
            self.data_vehiculo = df
            self.capacidad_vehiculo = df.loc[0, "CAPACIDAD"]

    def seleccionar_todos_vehiculos(self, state):
        widgets = self.scrollArea_8.findChildren(QWidget)
        if widgets:
            for widget in widgets:
                if isinstance(widget, QCheckBox):
                    widget.setCheckState(state)

    def hacer_sub_caminos(self, camino):
        ###### OJO: Si el camino retorna a depósito, se debe omitir el ultimo elemento de las sublistas porque esta vacio. Si no retorna, tomar completo
        lista = camino
        sublistas = []
        sublista_actual = []

        for elemento in lista:
            if elemento == 0:
                if sublista_actual:
                    sublista_actual.append(0)
                    sublistas.append(sublista_actual)
                    sublista_actual = [0]
                else:
                    sublista_actual.append(0)
            else:
                sublista_actual.append(elemento)

        if sublista_actual:
            sublista_actual.append(0)
            sublistas.append(sublista_actual)

        return(sublistas)

    def anadir_elementos_comboBox(self,n):
        self.comboBox.clear()
        self.comboBox.addItem("Ruta completa")
        if n > 1:
            for i in range(1,n+1):
                ruta = f"Ruta {i}"
                self.comboBox.addItem(ruta)

    def actualizar_resultado(self,index):
        opcion_actual = self.comboBox.currentText()

        if opcion_actual == "":
            QMessageBox.information(self, "information", "Debe correr un modelo")
        elif opcion_actual == "Ruta completa":
            self.clear_layout_resultado()
            self.map = self.mapa_completo
            self.html = self.map._repr_html_()
            self.web_view.setHtml(self.html)
            for i in self.camino_entero:
                self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

            #self.distancia_total = acumular_distancia(self.subset_matriz_dist,self.secuencia_completa)
            self.label_53.setText(str(round(self.distancia_total,2)))
            self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
            self.label_57.setText(str(round(self.distancia_total/1000,2)))
            self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))

        else:
            self.clear_layout_resultado()
            indice_espacio = opcion_actual.find(" ")
            subcadena = opcion_actual[indice_espacio + 1:]
            indice = int(subcadena) - 1
            camino_temporal = self.camino_sublistas[indice]
            secuencia = self.data_completa.loc[camino_temporal, 'ID']
            direcciones = self.data_completa.loc[camino_temporal, 'DIRECCION']
            rutas_pegadas = ruta_nodos(camino_temporal,self.subset_lat_lon,self.G)
            mapa = mapa_ruta_auxiliar(rutas_pegadas, self.subset_lat_lon, self.G, secuencia)
            self.map = mapa
            self.html = self.map._repr_html_()
            self.web_view.setHtml(self.html)
            for i in camino_temporal:
                self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

            distancia = acumular_distancia(self.subset_matriz_dist,secuencia)
            self.label_53.setText(str(round(distancia,2)))
            self.label_55.setText(str(round(distancia/self.vel_promedio,2)))
            self.label_57.setText(str(round(distancia/1000,2)))
            self.label_59.setText(str(round((distancia/self.vel_promedio)/60,2)))

    def abrir_opciones_correr(self):
        dialog = CustomDialog2()
        if dialog.exec_() == QDialog.Accepted:
            radioB_1 = dialog.radioButton_heuris_nn
            radioB_2 = dialog.radioButton_2
            radioB_3 = dialog.radioButton_3

            #Checkbuox para usar demandas/ventanas de tiempo y retorno a deposito al finalizar
            check_demandas = dialog.checkBox_demandas
            check_time_win = dialog.checkBox_vent_tiempo
            check_no_retorna = dialog.checkBox_regreso

            if self.data_clientes.empty or self.data_deposito.empty:
                QMessageBox.warning(self, "Warning", "Debe seleccionar y guardar al menos un cliente y un depósito para el ruteo")
            else:
                self.distancia_total = 0
                self.clear_layout_resultado()
                self.comboBox.clear()
                time.sleep(0.04)
                if radioB_1.isChecked():
                    if check_time_win.isChecked():
                        QMessageBox.warning(self, "Warning", "Opciones aún no disponibles.")

                    #Correr con demandas
                    elif  check_demandas.isChecked() == True:
                        if self.data_cargas.empty or self.capacidad_vehiculo == 99999999999999999999:
                            QMessageBox.warning(self, "Warning", "No se han guardado demandas o vehículo, por favor revise e intente nuevamente")
                        else:
                            df_cargas1 = self.data_cargas
                            df_cargas = df_cargas1.drop("ID", axis = 1)
                            clientes_con_cargas = pd.concat([self.data_clientes, df_cargas], axis = 1)
                            df_depot_aux = self.data_deposito
                            df_depot_aux["CARGA"] = 0

                            frames = [df_depot_aux, clientes_con_cargas]
                            self.data_completa = pd.concat(frames, ignore_index = True)
                            self.label_27.setText('Seleccione la ruta a mostrar:')

                            try:
                                matriz_distancias  = pd.read_csv("matriz_distancias.txt", sep=";", index_col = 0)
                                self.subset_matriz_dist = matriz_distancias.loc[self.data_completa["ID"],self.data_completa["ID"]]
                                base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep = ";", index_col = 0, encoding='latin-1')
                                self.subset_lat_lon = base_lat_lon.loc[self.data_completa["ID"]]

                                if check_no_retorna.isChecked():
                                    vuelve = "No"
                                    camino = heuristica_nn_carga(self.subset_matriz_dist, self.data_completa, capacidad = self.capacidad_vehiculo)
                                    print(camino)
                                    if camino == 'Infactible':
                                        QMessageBox.warning(self, "Warning", "El problema es infactible, alguna de las demandas es mayor a la capacidad del vehículo")
                                    else:
                                        camino_sin_ultimo = camino[:-1]
                                        secuencia = self.data_completa.loc[camino_sin_ultimo, 'ID']
                                        direcciones = self.data_completa.loc[camino_sin_ultimo, 'DIRECCION']
                                        completo = secuencia + ": " + direcciones

                                        rutas_pegadas = ruta_nodos(camino_sin_ultimo,self.subset_lat_lon,self.G)

                                        mapa = mapa_ruta(rutas_pegadas,self.subset_lat_lon,self.G,secuencia, vuelve)
                                        self.mapa_completo = mapa
                                        self.map = mapa
                                        self.html = self.map._repr_html_()
                                        self.web_view.setHtml(self.html)
                                        
                                        for i in camino_sin_ultimo:
                                            self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

                                        self.camino_entero = camino_sin_ultimo
                                        self.camino_sublistas = self.hacer_sub_caminos(camino_sin_ultimo)
                                        n = len(self.camino_sublistas)
                                        self.anadir_elementos_comboBox(n)

                                        self.distancia_total = acumular_distancia(self.subset_matriz_dist,secuencia)
                                        self.label_53.setText(str(round(self.distancia_total,2)))
                                        self.secuencia_completa = secuencia
                                        self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
                                        self.label_57.setText(str(round(self.distancia_total/1000,2)))
                                        self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))


                                else:
                                    vuelve = "Si"
                                    camino = heuristica_nn_carga(self.subset_matriz_dist, self.data_completa, capacidad = self.capacidad_vehiculo)
                                    print(camino)
                                    if camino == 'Infactible':
                                        QMessageBox.warning(self, "Warning", "El problema es infactible, alguna de las demandas es mayor a la capacidad del vehículo")
                                    else:
                                        secuencia = self.data_completa.loc[camino, 'ID']
                                        print(secuencia)
                                        direcciones = self.data_completa.loc[camino, 'DIRECCION']
                                        completo = secuencia + ": " + direcciones
                                        rutas_pegadas = ruta_nodos(camino,self.subset_lat_lon,self.G)

                                        mapa = mapa_ruta(rutas_pegadas,self.subset_lat_lon,self.G,secuencia, vuelve)
                                        self.mapa_completo = mapa
                                        self.map = mapa
                                        self.html = self.map._repr_html_()
                                        self.web_view.setHtml(self.html)
                                        
                                        for i in camino:
                                            self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

                                        self.camino_entero = camino
                                        self.camino_sublistas = self.hacer_sub_caminos(camino)
                                        self.camino_sublistas = self.camino_sublistas[:-1]
                                        n = len(self.camino_sublistas)
                                        self.anadir_elementos_comboBox(n)

                                        self.distancia_total = acumular_distancia(self.subset_matriz_dist,secuencia)
                                        self.label_53.setText(str(round(self.distancia_total,2)))
                                        self.secuencia_completa = secuencia
                                        self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
                                        self.label_57.setText(str(round(self.distancia_total/1000,2)))
                                        self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))

                            except:
                                reply = QMessageBox.question(self, 'Confirmar Acción', 'Alguno de los clientes o depósito no está en la base de datos. Se sugiere guardarlo. Si desea continuar, la solución tardará un tiempo considerable. \n¿Desea continuar?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                                if reply == QMessageBox.Yes:
                                    if check_no_retorna.isChecked():
                                        vuelve = "No"
                                        df = sacar_lat_lon_clientes(self.data_completa, self.geolocator, self.G)
                                        self.subset_lat_lon = df
                                        matriz = crear_matriz_distancias(self.data_completa, df, self.G)
                                        self.subset_matriz_dist = matriz
                                        camino = heuristica_nn_carga(matriz,self.data_completa, capacidad = self.capacidad_vehiculo)
                                        if camino == 'Infactible':
                                            QMessageBox.warning(self, "Warning", "El problema es infactible, alguna de las demandas es mayor a la capacidad del vehículo")
                                        else:
                                            camino_sin_ultimo = camino[:-1]
                                            secuencia = self.data_completa.loc[camino_sin_ultimo, 'ID']
                                            direcciones = self.data_completa.loc[camino_sin_ultimo, 'DIRECCION']
                                            completo = secuencia + ": " + direcciones

                                            rutas_pegadas = ruta_nodos(camino_sin_ultimo,df,self.G)

                                            mapa = mapa_ruta(rutas_pegadas,df,self.G,secuencia, vuelve)
                                            self.mapa_completo = mapa
                                            self.map = mapa
                                            self.html = self.map._repr_html_()
                                            self.web_view.setHtml(self.html)
                                            
                                            for i in camino_sin_ultimo:
                                                self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

                                            self.camino_entero = camino_sin_ultimo
                                            self.camino_sublistas = self.hacer_sub_caminos(camino_sin_ultimo)
                                            n = len(self.camino_sublistas)
                                            self.anadir_elementos_comboBox(n)

                                            self.distancia_total = acumular_distancia(self.subset_matriz_dist,secuencia)
                                            self.label_53.setText(str(round(self.distancia_total,2)))
                                            self.secuencia_completa = secuencia
                                            self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
                                            self.label_57.setText(str(round(self.distancia_total/1000,2)))
                                            self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))

                                    else:
                                        metodo = "h"
                                        vuelve = "Si"
                                        df = sacar_lat_lon_clientes(self.data_completa,self.geolocator,self.G)
                                        self.subset_lat_lon = df
                                        matriz = crear_matriz_distancias(self.data_completa,df,self.G)
                                        self.subset_matriz_dist = matriz
                                        camino = heuristica_nn_carga(matriz,self.data_completa, capacidad = self.capacidad_vehiculo)
                                        if camino == 'Infactible':
                                            QMessageBox.warning(self, "Warning", "El problema es infactible, alguna de las demandas es mayor a la capacidad del vehículo")
                                        else:
                                            secuencia = self.data_completa.loc[camino, 'ID']
                                            direcciones = self.data_completa.loc[camino, 'DIRECCION']
                                            completo = secuencia + ": " + direcciones
                                            rutas_pegadas = ruta_nodos(camino, df, self.G)
                                            mapa = mapa_ruta(rutas_pegadas, df, self.G, secuencia, vuelve)
                                            #mapa, camino= todo(self.data_completa,metodo,self.geolocator,self.G, secuencia, vuelve)
                                            self.mapa_completo = mapa
                                            self.map = mapa
                                            self.html = self.map._repr_html_()
                                            self.web_view.setHtml(self.html)
                                            
                                            for i in camino:
                                                self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

                                            self.camino_entero = camino
                                            self.camino_sublistas = self.hacer_sub_caminos(camino)
                                            self.camino_sublistas = self.camino_sublistas[:-1]
                                            n = len(self.camino_sublistas)
                                            self.anadir_elementos_comboBox(n)

                                            self.distancia_total = acumular_distancia(self.subset_matriz_dist,secuencia)
                                            self.label_53.setText(str(round(self.distancia_total,2)))
                                            self.secuencia_completa = secuencia
                                            self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
                                            self.label_57.setText(str(round(self.distancia_total/1000,2)))
                                            self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))

                    #Correr sin demandas
                    elif check_demandas.isChecked() == False: 
                        self.capacidad_vehiculo == 99999999999999999999
                        frames = [self.data_deposito, self.data_clientes]
                        self.data_completa = pd.concat(frames, ignore_index = True)
                        self.label_27.setText('Seleccione la ruta a mostrar:')

                        try:
                            matriz_distancias  = pd.read_csv("matriz_distancias.txt", sep=";", index_col = 0)
                            self.subset_matriz_dist = matriz_distancias.loc[self.data_completa["ID"],self.data_completa["ID"]]
                            base_lat_lon = pd.read_csv("Base_lat_lon.txt", sep = ";", index_col = 0, encoding='latin-1')
                            self.subset_lat_lon = base_lat_lon.loc[self.data_completa["ID"]]

                            if check_no_retorna.isChecked():
                                vuelve = "No"
                                camino = heuristica_nn(self.subset_matriz_dist)
                                camino_sin_ultimo = camino[:-1]
                                secuencia = self.data_completa.loc[camino_sin_ultimo, 'ID']
                                direcciones = self.data_completa.loc[camino_sin_ultimo, 'DIRECCION']
                                completo = secuencia + ": " + direcciones

                                rutas_pegadas = ruta_nodos(camino_sin_ultimo,self.subset_lat_lon,self.G)

                                mapa = mapa_ruta(rutas_pegadas,self.subset_lat_lon,self.G,secuencia, vuelve)
                                self.mapa_completo = mapa
                                self.map = mapa
                                self.html = self.map._repr_html_()
                                self.web_view.setHtml(self.html)
                                
                                for i in camino_sin_ultimo:
                                    self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

                                self.camino_entero = camino_sin_ultimo
                                self.camino_sublistas = self.hacer_sub_caminos(camino_sin_ultimo)
                                n = len(self.camino_sublistas)
                                self.anadir_elementos_comboBox(n)

                                self.distancia_total = acumular_distancia(self.subset_matriz_dist,secuencia)
                                self.label_53.setText(str(round(self.distancia_total,2)))
                                self.secuencia_completa = secuencia
                                self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
                                self.label_57.setText(str(round(self.distancia_total/1000,2)))
                                self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))

                            else:
                                vuelve = "Si"
                                camino = heuristica_nn(self.subset_matriz_dist)
                                secuencia = self.data_completa.loc[camino, 'ID']
                                direcciones = self.data_completa.loc[camino, 'DIRECCION']
                                completo = secuencia + ": " + direcciones
                                rutas_pegadas = ruta_nodos(camino,self.subset_lat_lon,self.G)

                                mapa = mapa_ruta(rutas_pegadas,self.subset_lat_lon,self.G,secuencia, vuelve)
                                self.mapa_completo = mapa
                                self.map = mapa
                                self.html = self.map._repr_html_()
                                self.web_view.setHtml(self.html)
                                
                                for i in camino:
                                    self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

                                self.camino_entero = camino
                                self.camino_sublistas = self.hacer_sub_caminos(camino)
                                self.camino_sublistas = self.camino_sublistas[:-1]
                                n = len(self.camino_sublistas)
                                self.anadir_elementos_comboBox(n)

                                self.distancia_total = acumular_distancia(self.subset_matriz_dist,secuencia)
                                self.label_53.setText(str(round(self.distancia_total,2)))
                                self.secuencia_completa = secuencia
                                self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
                                self.label_57.setText(str(round(self.distancia_total/1000,2)))
                                self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))
                        except:
                                reply = QMessageBox.question(self, 'Confirmar Acción', 'Alguno de los clientes o depósito no está en la base de datos. Se sugiere guardarlo. Si desea continuar, la solución tardará un tiempo considerable. \n¿Desea continuar?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                                if reply == QMessageBox.Yes:
                                    if check_no_retorna.isChecked():
                                        vuelve = "No"
                                        df = sacar_lat_lon_clientes(self.data_completa, self.geolocator, self.G)
                                        self.subset_lat_lon = df
                                        matriz = crear_matriz_distancias(self.data_completa, df, self.G)
                                        self.subset_matriz_dist = matriz
                                        camino = heuristica_nn(matriz)
                                        camino_sin_ultimo = camino[:-1]
                                        secuencia = self.data_completa.loc[camino_sin_ultimo, 'ID']
                                        direcciones = self.data_completa.loc[camino_sin_ultimo, 'DIRECCION']
                                        completo = secuencia + ": " + direcciones

                                        rutas_pegadas = ruta_nodos(camino_sin_ultimo,df,self.G)

                                        mapa = mapa_ruta(rutas_pegadas,df,self.G,secuencia, vuelve)
                                        self.mapa_completo = mapa
                                        self.map = mapa
                                        self.html = self.map._repr_html_()
                                        self.web_view.setHtml(self.html)
                                        
                                        for i in camino_sin_ultimo:
                                            self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

                                        self.camino_entero = camino_sin_ultimo
                                        self.camino_sublistas = self.hacer_sub_caminos(camino_sin_ultimo)
                                        n = len(self.camino_sublistas)
                                        self.anadir_elementos_comboBox(n)

                                        self.distancia_total = acumular_distancia(self.subset_matriz_dist,secuencia)
                                        self.label_53.setText(str(round(self.distancia_total,2)))
                                        self.secuencia_completa = secuencia
                                        self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
                                        self.label_57.setText(str(round(self.distancia_total/1000,2)))
                                        self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))

                                    else:
                                        vuelve = "Si"
                                        df = sacar_lat_lon_clientes(self.data_completa,self.geolocator,self.G)
                                        self.subset_lat_lon = df
                                        matriz = crear_matriz_distancias(self.data_completa,df,self.G)
                                        self.subset_matriz_dist = matriz
                                        camino = heuristica_nn(matriz)
                                        secuencia = self.data_completa.loc[camino, 'ID']
                                        direcciones = self.data_completa.loc[camino, 'DIRECCION']
                                        completo = secuencia + ": " + direcciones
                                        rutas_pegadas = ruta_nodos(camino, df, self.G)
                                        mapa = mapa_ruta(rutas_pegadas, df, self.G, secuencia, vuelve)
                                        #mapa, camino= todo(self.data_completa,metodo,self.geolocator,self.G, secuencia, vuelve)
                                        self.mapa_completo = mapa
                                        self.map = mapa
                                        self.html = self.map._repr_html_()
                                        self.web_view.setHtml(self.html)
                                        
                                        for i in camino:
                                            self.display_resultado(self.data_completa.loc[i, 'ID'], self.data_completa.loc[i, 'DIRECCION'], self.ScrollArea_layout)

                                        self.camino_entero = camino
                                        self.camino_sublistas = self.hacer_sub_caminos(camino)
                                        self.camino_sublistas = self.camino_sublistas[:-1]
                                        n = len(self.camino_sublistas)
                                        self.anadir_elementos_comboBox(n)

                                        self.distancia_total = acumular_distancia(self.subset_matriz_dist,secuencia)
                                        self.label_53.setText(str(round(self.distancia_total,2)))
                                        self.secuencia_completa = secuencia
                                        self.label_55.setText(str(round(self.distancia_total/self.vel_promedio,2)))
                                        self.label_57.setText(str(round(self.distancia_total/1000,2)))
                                        self.label_59.setText(str(round((self.distancia_total/self.vel_promedio)/60,2)))


                elif radioB_2.isChecked():
                    QMessageBox.warning(self, "Warning", "Opciones aún no disponibles.")
                elif radioB_3.isChecked():
                    QMessageBox.warning(self, "Warning", "Opciones aún no disponibles.")




class CustomDialog2(QDialog):
    def __init__(self):
        super().__init__()

        self.setWindowTitle("Opciones de Ruteo")
        self.resize(300,200)
        #self.setGeometry(200, 200, 500, 300)

        titulo = QLabel("Opciones de Ruteo")
        font = QtGui.QFont()
        font.setPointSize(14)
        font.setBold(True)
        font.setWeight(75)
        titulo.setFont(font)

        label_aux = QLabel("Seleccione las configuraciones para el ruteo")
        font = QtGui.QFont()
        font.setPointSize(10)
        label_aux.setFont(font)


        layout = QVBoxLayout()
        layout.addWidget(titulo)
        layout.addWidget(label_aux)

        hor_layout = QHBoxLayout()

        self.radioButton_heuris_nn = QRadioButton("Heurística vecino más cercano")
        self.radioButton_heuris_nn.setFont(font)
        self.radioButton_heuris_nn.setAutoFillBackground(True)
        self.radioButton_heuris_nn.setChecked(True)
        self.radioButton_heuris_nn.setFont(font)
        self.radioButton_heuris_nn.setObjectName("radioButton_heuris_nn")

        self.radioButton_2 = QRadioButton("Botón disponible para trabajo futuro")
        self.radioButton_2.setFont(font)
        self.radioButton_2.setAutoFillBackground(True)
        self.radioButton_2.setChecked(False)
        self.radioButton_2.setFont(font)
        self.radioButton_2.setObjectName("radioButton_2")

        self.radioButton_3 = QRadioButton("Botón disponible para trabajo futuro")
        self.radioButton_3.setFont(font)
        self.radioButton_3.setAutoFillBackground(True)
        self.radioButton_3.setChecked(False)
        self.radioButton_3.setFont(font)
        self.radioButton_3.setObjectName("radioButton_3")

        
        self.checkBox_demandas = QCheckBox("Utilizar demandas")
        self.checkBox_demandas.setFont(font)
        self.checkBox_demandas.setObjectName("checkBox_demandas")

        self.checkBox_vent_tiempo = QCheckBox("Utilizar ventanas de tiempo")
        self.checkBox_vent_tiempo.setFont(font)
        self.checkBox_vent_tiempo.setObjectName("checkBox_vent_tiempo")

        self.checkBox_regreso = QCheckBox("No regresar al depósito al finalizar")
        self.checkBox_regreso.setFont(font)
        self.checkBox_regreso.setObjectName("checkBox_regreso")

        v1_layout = QVBoxLayout()
        v2_layout = QVBoxLayout()

        v1_layout.addWidget(self.radioButton_heuris_nn)
        v1_layout.addWidget(self.radioButton_2)
        v1_layout.addWidget(self.radioButton_3)

        v2_layout.addWidget(self.checkBox_demandas)
        v2_layout.addWidget(self.checkBox_vent_tiempo)
        v2_layout.addWidget(self.checkBox_regreso)

        hor_layout.addLayout(v1_layout)
        hor_layout.addLayout(v2_layout)

        layout.addLayout(hor_layout)

        ok_button = QPushButton("Correr")
        cancel_button = QPushButton("Cancelar")

        h2_layout = QHBoxLayout()

        h2_layout.addWidget(ok_button)
        h2_layout.addWidget(cancel_button)

        layout.addLayout(h2_layout)


        # Set the layout for the dialog
        self.setLayout(layout)

        # Connect the button signals to slots
        ok_button.clicked.connect(self.accept)
        cancel_button.clicked.connect(self.reject) 

class Load_Window(QDialog):
    def __init__(self):
        QDialog.__init__(self)
        #self.setGeometry(QtCore.QRect(400,400,500,300))

        self.setWindowTitle("SIR- Uniandes wa.fontalvo10")
        self.resize(500,300)

        title = QLabel(self)
        pixmap = QPixmap('inicio2.jpg')
        title.setPixmap(pixmap)
        self.resize(pixmap.width(),pixmap.height())
        #title.setAlignment(QtCore.Qt.AlignCenter)
        #title.move(200,200)
        self.show()



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
     # Create a QLabel instance with the desired message
    LoadWin = Load_Window()
    app.processEvents()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    # Hide the prompt label and show the main window
    LoadWin.close()
    MainWindow.show()
    sys.exit(app.exec_())
